%% 
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%% Abstract: 
%%   This TLC library file contains all the code for generating system output
%%   code.
%%

%include "sysarglib.tlc"

%if EXISTS("_SYSLIB_") == 0
%assign _SYSLIB_ = 1

%%---------------------------------------------------------------%
%% FunctionRecord - record used for defining function prototypes %
%%---------------------------------------------------------------%
%%
%% Create a record for defining function prototypes.  The identifiers of
%% FcnRec are used as follows
%%
%%   Declaration: void foo(int_T tid);
%%   Call Syntax: foo(tid);
%%
%%   Name    = "foo"
%%   Returns = "void"
%%   Params  = "int_T tid"
%%   Args    = "tid"

%assign FunctionRecord = FcnRec\
  {\
    Name       "";\
    Returns    "";\
    Params     "";\
    CommonPrms "";\
    CommonArgs ""\
  }

%% Function: FcnResetFunctionRecord ============================================
%% Abstract:
%%    A routine to reset the function record.
%%
%function FcnResetFunctionRecord() void
  %assign ::FcnRec.Name       = ""
  %assign ::FcnRec.Returns    = ""
  %assign ::FcnRec.Params     = ""
  %assign ::FcnRec.CommonPrms = ""
  %assign ::FcnRec.CommonArgs = "" 
%endfunction

%% Function: FcnAddArgument ====================================================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record.
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%%
%function FcnAddArgument(type, var, arg) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma  = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = type + var
  %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
  %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
%endfunction


%% Function: FcnAddArgumentWithCompilerAbstraction ==============================
%% Abstract:
%%   Add an argument to the parameter and argument fields of the FcnRec
%%   record with AUTOSAR compiler abstraction macros
%%
%%   Arguments:
%%     type: the type for the argument
%%      var: the variable name for the argument
%%
%function FcnAddArgumentWithCompilerAbstraction(isConst, datatype, isPtr, ptrIsConst, var, arg) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma  = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, ptrIsConst, var, "DataAutomatic")
  %assign ::FcnRec.Params     = ::FcnRec.Params + comma + dataDef
  %assign ::FcnRec.CommonArgs = ::FcnRec.CommonArgs + comma + arg
%endfunction

%% Function: FcnAddParameter ===================================================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%%
%function FcnAddParameter(type, var) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = type + var
  %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
%endfunction

%% Function: FcnAddParameterWithCompilerAbstraction =============================
%% Abstract:
%%   Add an argument definition to the parameter field of the FcnRec record.
%%
%%   Arguments:
%%     type: the type for the argument definition
%%      var: the variable name for the argument definition
%%
%function FcnAddParameterWithCompilerAbstraction(isConst, datatype, isPtr, var) void
  %if !WHITE_SPACE(::FcnRec.Params)
    %assign comma = ", "
  %else
    %assign comma = ""
  %endif
  %assign dataDef = SLibAutosarCompilerAbstractionForDataDecl(isConst, datatype, isPtr, TLC_FALSE, var, "DataAutomatic")
  %assign ::FcnRec.Params = ::FcnRec.Params + comma + dataDef
%endfunction

%% Function: FcnPassCanonicalInputByPtr ========================================
%% Abstract:
%%   Return whether a canonical input should be passed by pointer
%function FcnPassCanonicalInputByPtr(ci)
  %return ci.DeclareAsPointer == "yes"
%endfunction

%% Function: FcnPassCanonicalInputAsConst ======================================
%% Abstract:
%%   Return whether a canonical input should be passed using const
%%   qualifier
%function FcnPassCanonicalInputAsConst(ci)
  %return FcnPassCanonicalInputByPtr(ci) || (LibGetRecordWidth(ci) > 1)
%endfunction
  
%% Function: FcnAddParametersAndReturn =========================================
%% Abstract:
%%   This function adds the needed parameters and return to the function 
%%   prototype, e.g. "u0, u1, localB, ..."
%%   refer to GetFunctionStr for the order of parameters.
%%
%function FcnAddParametersAndReturn(sysFcn, sysIdx) void
  %assign cTID = System[sysIdx].CurrentTID
  %assign isRG = SLibSystemFcnRateGrouping(System[sysIdx], sysFcn)

  %if sysFcn == "SetDims"
    %assert !SLibAutosarCompilerAbstractionRequired()
    %<FcnAddParameter("int_T ", "oIdx")>
    %<FcnAddParameter("int_T ", "rIdx")>
  %endif

  %if (sysFcn == "OutputUpdate") && SLibFcnProtoCtrlActive() && ...
    IsModelReferenceBaseSys(System[sysIdx])
    
    %assign FPC = FcnGetFunctionPrototypeRecord()
  %else  
    %assign FPC = []
  %endif
  
  %if sysFcn == "OutputUpdate" && ...
      GenerateClassInterface && ...
      IsModelReferenceBaseSys(System[sysIdx])
    
    %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
    
  %endif
  
  %with System[sysIdx].Interface
  %if LibSystemIsReusedFcn(System[sysIdx])
    %if ISEMPTY(FPC)
      %assign numArgs = NumCanonicalInputArgDefs + NumCanonicalOutputArgDefs
    %else
      %assign numArgs = FPC.NumArgSpecData
    %endif
    %assign isISSReuseDiffNumIters = SLibGetIsImplicitIterSSReuseWithDiffNumIters(System[sysIdx]) 
    
    %foreach argIdx = numArgs
      %if ISEMPTY(FPC)
        %if argIdx < NumCanonicalInputArgDefs
          %assign portIdx = argIdx
          %assign SLObjectType = "Inport"
        %else
          %assign portIdx = argIdx - NumCanonicalInputArgDefs
          %assign SLObjectType = "Outport"
        %endif
      %else
        %assign portIdx = FPC.ArgSpecData[argIdx].PortNum
        %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
      %endif
      %%
      %% Canonical input argument
      %%
      %if SLObjectType == "Inport"
        %if !ISEMPTY(FPC) || ...
          SysFcnArgNeeded(sysFcn, CanonicalInputArgDef[portIdx], cTID, isRG)
          %assign skipThisArg = 0
          %if ISEMPTY(FPC)
            %assign ci = CanonicalInputArgDef[portIdx]
            %if IDNUM(ci.SignalSrc[0])[0] == "F"
              %assign skipThisArg = 1
            %endif	
            %assign dataType = SLibGetRecordDataTypeName(ci, "")
            %assign width = LibGetRecordWidth(ci)
            %assign optWidth = LibOptionalVectorWidth(width)
          %else
            %assign ei = ExternalInputs.ExternalInput[portIdx]
            %assign dataType = SLibGetRecordDataTypeName(ei, "")
            %assign width = LibGetRecordWidth(ei)
            %assign optWidth = LibOptionalVectorWidth(width)
          %endif
          %if skipThisArg==0   
            %if ISEMPTY(FPC)
              %assign passByPtr = FcnPassCanonicalInputByPtr(ci)
              %assign passConst = FcnPassCanonicalInputAsConst(ci)
              %assign optConst = passConst ? "const " : ""
              %assign optStar  = passByPtr ? "*" : ""
              %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters && !ISEMPTY(optWidth)
                %% Always pass pointer for var-dims signal or Implicit Iterator
                %% subsystem reused for different number of iterations.
                %assign argDef = " %<LibGetRecordIdentifier(ci)>[]"
              %else
                %assign argDef = "%<optStar>%<LibGetRecordIdentifier(ci)>%<optWidth>"
              %endif
            %else
              %assign passByPtr = FPC.ArgSpecData[argIdx].Category == "Pointer" && width == 1
              %assign isReference = (FPC.ArgSpecData[argIdx].Category == "Reference")
              %assign qualifier = FPC.ArgSpecData[argIdx].Qualifier
              %assign argDef = ""
              %switch qualifier
                %case "none"
                  %assign optConst = ""
                  %if passByPtr
                    %assign argDef = "*"
                  %elseif isReference
                    %assign argDef = "&"
                  %endif
                  %break
                %case "const"
                  %assign optConst = "const "
                  %assign argDef = ""
                  %break
                %case "const *"
                  %assign optConst = "const "
                  %if LibGetRecordWidth(ei) == 1
                    %assign argDef = "*"
                  %endif
                  %break
                %case "const * const"
                  %assign optConst = "const "
                  %if LibGetRecordWidth(ei) == 1
                    %assign argDef = "*const "
                  %endif
                  %break
                %case "const &"
                  %assign optConst = "const "
                  %assign argDef = "&"
                  %break
                %default
                  %assign errTxt = "Unhandled qualifier"
                  %<LibReportFatalError(errTxt)>
                  %break
              %endswitch
              
              %if !ISEMPTY(optWidth) && isReference
                 %assign argDef = ...
                  "(%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>)%<optWidth>"
              %else
                %assign argDef = ...
                  "%<argDef>%<FPC.ArgSpecData[argIdx].ArgName>%<optWidth>"
              %endif
            %endif
            %if SLibAutosarCompilerAbstractionRequired()
              %if SLibGetCanIOIsVarDims(ci) || isISSReuseDiffNumIters
                %assign argDef = "%<LibGetRecordIdentifier(ci)>[]"
              %else
                %assign argDef = "%<LibGetRecordIdentifier(ci)>%<optWidth>"
              %endif
              %<FcnAddParameterWithCompilerAbstraction(passConst, dataType, passByPtr, argDef)>
            %else
              %assign dataType = "%<optConst>%<dataType> "
              %<FcnAddParameter(dataType, argDef)>
            %endif
          %endif
        %endif %% SysFcnArgNeeded
        
        %if ISEMPTY(FPC)
          %% Add vardims argument for the canonical input 
          %<FcnAddNeededCanDimSizeDWForCanInp(sysFcn, sysIdx, portIdx)>
        %endif
        
        %%
        %% Canonical output arguments
      %else  
        %if !ISEMPTY(FPC) || ...
          SysFcnArgNeeded(sysFcn, CanonicalOutputArgDef[portIdx], cTID, isRG)
          %if ISEMPTY(FPC)
            %assign       co = CanonicalOutputArgDef[portIdx]
            %assign dataType = SLibGetRecordDataTypeName(co, "")
            %assign   identi = LibGetRecordIdentifier(co)
            %assign  optStar = LibGetRecordWidth(co) == 1 ? " *" : " "
            %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
            %if SLibAutosarCompilerAbstractionRequired()
              %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                %% Always pass pointer for var-dims signal or Implicit Iterator
                %% subsystem reused for different number of iterations.
                %assign argDef = " " + identi + "[]"
              %else
                %assign argDef = identi + optWidth
              %endif
              %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, (LibGetRecordWidth(co) == 1), argDef)>
            %else
              %if SLibGetCanIOIsVarDims(co) || isISSReuseDiffNumIters
                %% Always pass pointer for var-dims signal or Implicit Iterator
                %% subsystem reused for different number of iterations.
                %assign argDef = " " + identi + "[]"
              %else
                %assign argDef = optStar + identi + optWidth
              %endif
              %<FcnAddParameter(dataType, argDef)>
            %endif
          %else
            %assign eo = ExternalOutputs.ExternalOutput[portIdx]
            %assign dataType = SLibGetRecordDataTypeName(eo, "")
            %if FPC.ArgSpecData[argIdx].Category == "Value"
              %assign ::FcnRec.Returns = dataType
            %else
              %assign   identi = FPC.ArgSpecData[argIdx].ArgName
              %assign   isReference = (FPC.ArgSpecData[argIdx].Category == "Reference")
              %assign   optStarOrRef = isReference ? " &" : ...
                             (LibGetRecordWidth(eo) == 1 ? " *" : " ")
              %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(eo))
              %if !ISEMPTY(optWidth) && isReference
                %assign argDef = "(" + optStarOrRef + identi +")" + optWidth
              %else
                %assign argDef = optStarOrRef + identi + optWidth
              %endif
              %% SLibAutosarCompilerAbstractionRequired() not supported for FPC
              %<FcnAddParameter(dataType, argDef)>
            %endif
          %endif
        %endif
        
        %if ISEMPTY(FPC)
          %% Add vardims argument for the canonical output 
          %% Function FinalizeDims and SetDims only need canonical dim-size
          %% dwork. They don't need canonical output.
          %<FcnAddNeededCanDimSizeDWForCanOut(sysFcn, sysIdx, portIdx)>
        %endif
        
      %endif  
    %endforeach
    %%
    %% Is a model reference scalable build - some args are accessed as globals
    %% Skip these args.
    %assign isScalableMRSys = !System[sysIdx].GeneratingSubFunctions && ...
      IsModelReferenceBaseSys(System[sysIdx]) && IsModelRefScalableBuild()
    
    %% Is a model reference build and in C++ encapsulation mode
    %assign isCPPEncapMdlRef = GenerateClassInterface && ...
      IsModelReferenceBaseSys(System[sysIdx])
    %%
    %% rtModel argument
    %%
    %if SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && !isCPPEncapMdlRef
      %if !isScalableMRSys
        %<FcnAddParameter(tSimStructType, " *const %<tSimStruct>")>
      %else
        %openfile localRTMVar
        %<tSimStructType> *const %<tSimStruct> = &(%<FcnGetSFcnDWorkIdentifier(System[sysIdx])>.rtm);
        %closefile localRTMVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localRTMVar)>
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %% Block IO argument
    %%
    %if SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG) && !isCPPEncapMdlRef
      %assign dataType = FcnSysVarGroupType(System[sysIdx],"BlockIO") + " "
      %if !isScalableMRSys
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = FcnSysVarGroupType(System[sysIdx],"BlockIO")
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localB")>
        %else
          %<FcnAddParameter(dataType, "*localB")>
        %endif
      %else
        %openfile localBIOVar
        %<dataType> *localB = &(%<FcnGetSFcnDWorkIdentifier(System[sysIdx])>.rtb);
        %closefile localBIOVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localBIOVar)>
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %% Constant block IO argument
    %%
    %if SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG) && !isCPPEncapMdlRef
      %assert !isScalableMRSys
      %if SLibAutosarCompilerAbstractionRequired()
        %assign dataType = FcnSysVarGroupType(System[sysIdx],"ConstBlockIO") 
        %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localC")>
      %else
        %assign dataType = FcnSysVarGroupType(System[sysIdx],"ConstBlockIO") + " " 
        %<FcnAddParameter(dataType, "*localC")>
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %% DWork argument
    %%
    %if SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG) && !isCPPEncapMdlRef
      %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"DWork")
      %if !isScalableMRSys
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = varGroupType
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localDW")>
        %else
          %assign dataType = varGroupType + " "
          %<FcnAddParameter(dataType, "*localDW")>
          %endif
      %else
        %openfile localDWVar
        %<varGroupType> *localDW = &(%<FcnGetSFcnDWorkIdentifier(System[sysIdx])>.rtdw);
        %closefile localDWVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localDWVar)>
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %% Parameter H-Struct argument
    %%
    %if SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
      %%
      %% Does a passthrough parameter structure argument exists ?
      %%
      %assert( !isScalableMRSys || IsModelReferenceInlineOffTarget())
      %if (InlineParameters && ParameterArgDef.PassthroughSystemIdx > -1)
	%assign prmSysIdx = ParameterArgDef.PassthroughSystemIdx
      %else
	%assign prmSysIdx = sysIdx
      %endif
      %assign numsys = GetNumSystemsForCodeGen()
      %if prmSysIdx < numsys-1 %% not the root system
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter")
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localP")>
        %else
          %assign dataType = FcnSysVarGroupType(System[prmSysIdx],"Parameter") + " "
          %<FcnAddParameter(dataType, "*localP")>
        %endif
      %elseif IsModelReferenceInlineOffTarget() 
          %% Do not add parameters to the function arguments for the root system.
          %% Use local rtP_ parameter structure
          %assign dataType = tParametersType
          %assign paramsName = "%<::CompiledModel.Name>_P"
          %openfile localPVar
          %<dataType> *localP = &%<paramsName>;
          %closefile localPVar
          %<FcnCacheModelRefLocalVars(System[prmSysIdx], sysFcn, cTID, localPVar)>
      %else
	%%
	%% The child function has the root parameter structure as
	%% a passthrough argument
	%%
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = tParametersType
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, LibGetParametersStruct())>
        %else
          %assign dataType = tParametersType + " "
          %<FcnAddParameter(dataType, "*%<LibGetParametersStruct()>")>
        %endif
            
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %% Continuous States argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
      %assign dataType = isScalableMRSys ? "real_T " : ...
        "%<FcnSysVarGroupType(System[sysIdx],"ContStates")> "
      %assign paramName= isScalableMRSys ? "*localX_" : "*localX"
      %assert !isCPPEncapMdlRef
      %<FcnAddParameter(dataType, paramName)>
      %if isScalableMRSys
        %openfile localCStateVar
        %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"ContStates")
        %<varGroupType> *localX = (%<varGroupType> *) localX_;
        %closefile localCStateVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localCStateVar)>
      %endif
    %endif
    %%
    %% Continuous States Derivative argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
      %assign dataType = isScalableMRSys ? "real_T " : "%<FcnSysVarGroupType(System[sysIdx],"ContStatesDerivative")> "
      %assign paramName= isScalableMRSys ? "*localXdot_" : "*localXdot"
      %assert !isCPPEncapMdlRef
      %% SLibAutosarCompilerAbstraction not needed for continuous states
      %<FcnAddParameter(dataType, paramName)>
      %if isScalableMRSys
        %openfile localCStateVar
        %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"ContStatesDerivative")
        %<varGroupType> *localXdot = (%<varGroupType> *) localXdot_;
        %closefile localCStateVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localCStateVar)>
      %endif
    %endif
    %%
    %% Continuous States Disabled argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
      %assign dataType = isScalableMRSys ? "real_T " : "%<FcnSysVarGroupType(System[sysIdx],"ContStatesDisabled")> "
      %assign paramName= isScalableMRSys ? "*localXdis_" : "*localXdis"
      %assert !isCPPEncapMdlRef
      %% SLibAutosarCompilerAbstraction not needed for continuous states
      %<FcnAddParameter(dataType, paramName)>
      %if isScalableMRSys
        %openfile localCStateVar
        %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"ContStatesDisabled")
        %<varGroupType> *localXdis = (%<varGroupType> *) localXdis_;
        %closefile localCStateVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localCStateVar)>
      %endif
    %endif
    %%
    %% ZcSignalValue  argument
    %%
    %if SysFcnArgNeeded(sysFcn,ZCSVArgDef, cTID, isRG)
      %if SLibAutosarCompilerAbstractionRequired()
        %assign dataType = isScalableMRSys ? "real_T" : "%<FcnSysVarGroupType(System[sysIdx],"ZCSV")>"
        %assign paramName= isScalableMRSys ? "localZCSV_" : "localZCSV"
        %assert !isCPPEncapMdlRef
        %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, paramName)>
      %else
        %assign dataType = isScalableMRSys ? "real_T " : "%<FcnSysVarGroupType(System[sysIdx],"ZCSV")> "
        %assign paramName= isScalableMRSys ? "*localZCSV_" : "*localZCSV"
        %assert !isCPPEncapMdlRef
        %<FcnAddParameter(dataType, paramName)>
      %endif
        %if isScalableMRSys
        %openfile localCStateVar
        %assign varGroupType = FcnSysVarGroupType(System[sysIdx],"ZCSV")
        %<varGroupType> *localZCSV = (%<varGroupType> *) localZCSV_;
        %closefile localCStateVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localCStateVar)>
      %endif
    %endif
    %%
    %% ZCEvent H-Struct argument
    %if SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG) && !isCPPEncapMdlRef
      %if !isScalableMRSys 
        %if SLibAutosarCompilerAbstractionRequired()
          %assign dataType = FcnSysVarGroupType(System[sysIdx],"ZCEvent")
          %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, TLC_TRUE, "localZCE")>
        %else
          %assign dataType = FcnSysVarGroupType(System[sysIdx],"ZCEvent") + " "
          %<FcnAddParameter(dataType, "*localZCE")>
        %endif
      %else
        %openfile localZCEventVar
        %<FcnSysVarGroupType(System[sysIdx],"ZCEvent")> *localZCE = &(%<FcnGetSFcnDWorkIdentifier(System[sysIdx])>.rtzce);
        %closefile localZCEventVar
        %<FcnCacheModelRefLocalVars(System[sysIdx], sysFcn, cTID, localZCEventVar)>
      %endif
    %endif %% SysFcnArgNeeded
    %%
    %%
    %% Canonical Parameters
    %%
    %foreach argIdx=NumCanonicalPrmArgDefs
      %assign canPrmDef = CanonicalPrmArgDef[argIdx]
      %if SysFcnArgNeeded(sysFcn, canPrmDef, cTID, isRG)
	%assign   identi = LibGetRecordIdentifier(canPrmDef)
	%assign dataType = SLibGetRecordDataTypeName(canPrmDef, "")
	%assign    width = LibBlockParameterWidth(canPrmDef)
	%assign optWidth = LibOptionalVectorWidth(width)
        %assign declAsPtr = canPrmDef.DeclareAsPointer == "yes"
        %if SLibAutosarCompilerAbstractionRequired()
          %assign optConst = ((width > 1) || declAsPtr)
          %assign optStar  = declAsPtr
          %assign argDef   = "%<identi>%<optWidth>"
          %<FcnAddParameterWithCompilerAbstraction(optConst, dataType, optStar, argDef)>
        %else
          %assign optConst = ((width > 1) || declAsPtr)  ? "const " : ""
          %assign dataType = "%<optConst>%<dataType> "
          %assign optStar  = declAsPtr ? "*" : ""
          %assign argDef   = "%<optStar>%<identi>%<optWidth>"
          %<FcnAddParameter(dataType, argDef)>
        %endif
      %endif %% SysFcnArgNeeded
    %endforeach %% argIdx=NumCanonicalPrmArgDefs
    %%
    %% CanonicalDWork
    %%
    %foreach argIdx = NumCanonicalDWorkArgDefs
      %% Canonical dimsize dwork has already beed added to the
      %% args following the corresponding canonical input/output
      %if !(AllowVarDimsSig && SLibGetCanDWorkIsCanDimSizeDWork(argIdx))
        %assign canDWork = CanonicalDWorkArgDef[argIdx]
        %assign dwIdx    = canDWork.FirstSignalSrc %% global idx
        %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
        %if SysFcnArgNeeded(sysFcn, canDWork, cTID, isRG)
          %assign dwWidth  = SLibDWorkWidth(dwRec)
          %assign dwId     = LibGetRecordIdentifier(canDWork)
          %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
          %%
          %% Example:
          %%   Scalar signal: void foo(real_T *a)
          %%   Wide signal:   void foo(real_T b[7])
          %%
          %if SLibAutosarCompilerAbstractionRequired()
            %if dwWidth == 1
              %assign   argDef = "%<dwId>"
            %else
              %assign   argDef = "%<dwId>[%<dwWidth>]"
            %endif
            %<FcnAddParameterWithCompilerAbstraction(TLC_FALSE, dataType, (dwWidth == 1), argDef)>
          %else
            %if dwWidth == 1
              %assign   argDef = " *%<dwId>"
            %else
              %assign   argDef = " %<dwId>[%<dwWidth>]"
            %endif
            %<FcnAddParameter(dataType,argDef)>
          %endif
        %endif
      %endif %% if !SLibGetCanDWorkIsCanDimSizeDWork
    %endforeach
  %elseif SLibNeedHandleParallelForEachSS(System[sysIdx], sysFcn)
    %% Add argument (int32_T rtSS_iter) for parallel ForEach Subsystem
    %assign dw = DWorks.DWork[IDNUM(System[sysIdx].IndexingSigSrc)[1]]
    %if dw.IsLocalScratchDWork == 1
      %assign argDef  = LibGetRecordIdentifier(dw)
      %assign dataType = SLibGetRecordDataTypeName(dw,"") + " "    
      %<FcnAddParameter(dataType, argDef)>
    %endif
  %endif  
  %endwith
%endfunction

%% Function: FcnGetSfcnFormDefine ==============================================
%% Abstract:
%%   Return the # define that is needed in front of root model methods in 
%%   S-function format
%% 
%function FcnGetSfcnFormDefine(sysFcn) void
  %assign retVal = ""
  %switch sysFcn
    %case "Start"
      %assign retVal = "MDL_START"
      %break
    %case "Initialize"
      %assign retVal = "MDL_INITIALIZE_CONDITIONS"
      %break
    %case "Enable"
      %assign retVal = "RTW_GENERATED_ENABLE"
      %break
    %case "Disable"
      %assign retVal = "RTW_GENERATED_DISABLE"
      %break
    %case "Update"
      %assign retVal = "MDL_UPDATE"
      %break
    %case "Derivative"
      %assign retVal = "MDL_DERIVATIVES"
      %break
    %case "ForcingFunction"
      %assign retVal = "MDL_FORCINGFUNCTION"
      %break  
    %case "MassMatrix"
      %assign retVal = "MDL_MASSMATRIX"
      %break        
    %case "Projection"
      %assign retVal = "MDL_PROJECTION"
      %break
    %case "ZeroCrossing"
      %assign retVal = "MDL_ZERO_CROSSINGS"
      %break
    %default
      %assign retVal = ""
      %break
  %endswitch
  
  %return retVal
%endfunction %% FcnGetSfcnFormDefine

%<LibAddToCompiledModel("SubsystemPrototypesCache", "")>
%% Function: LibCacheSubsystemPrototype ========================================
%% Abstract:
%%   Cache a function prototype (in case the file splits) 
%%
%%   Arguments:
%%     system: Refers to the system whose prototype we are caching   
%% 	  fcn: Reference to a FcnRec (see top of file for definition of Record)
%%
%%
%%   Example:
%% 	   fcn.Returns = "real_T *"
%% 	   fcn.Name    = "foo"
%% 	   fcn.Params  = "int_T i"
%%   
%% 	   caches: (in 'system.SystemFcnPrototype')
%% 		  C -
%% 		   "extern real_T * foo(int_T i);" 
%% 		   
%% 		  Ada -
%% 		    package system is
%% 		      procedure system_output
%% 		    end system
%% 
%function LibCacheSubsystemPrototype(system,fcn) void
  %% Cache extern only if the storage class is non-static
  %assign extern = LibPreserveExternInFcnDecls() && ...
    (UsingMalloc == 0) && ...
    !SLibGenNonReusableSubsysFcnAsClassMemFcn(system) ? "extern " : ""  
  %assign sysFcnType = fcn.SysFcn
  %if (sysFcnType == "Initialize" || sysFcnType == "Start" || sysFcnType == "Terminate")
    %assign msFcnType = "MemSecFuncInitTerm"
  %else
    %assign msFcnType = "MemSecFuncExecute"
  %endif
  %openfile ssp
  %<SLibIfNetPreprocessorCondition(system)>
  %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Pre", system)>\
  %<extern>%<fcn.FcnPrototype>;
  %<SLibGetFcnMemSecPragmaForSystemOnDecl(fcn.Name, msFcnType, "Post", system)>\
  %<SLibEndIfNetPreprocessorCondition(system)>
  %closefile ssp
  %% To avoid warnings, use a different name for the
  %% rtModel in the function declaration than in the
  %% function body.
  %if GenRTModel
    %assign rtm = " *%<tSimStruct>"
    %assign lowerrtm = " *rtm"
    %assign ssp = FEVAL("strrep",ssp, rtm, lowerrtm)
  %endif
  %assign fileOwnerSystem = ::CompiledModel.System[system.FileNameOwnerIdx]
  %if IsModelRefScalableBuild() && IsModelReferenceBaseSys(system)
    %assert (system.FileNameOwnerIdx == system.SystemIdx)
    %if !GenerateClassInterface
      %if !LibIsSystemField(system, "MRSystemFcnPrototype")
        %<LibAddToSystem(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
      %else
        %<LibAddToSystemField(fileOwnerSystem, "MRSystemFcnPrototype", ssp)>
      %endif
    %endif
  %else
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
      %<LibAddToSystemField(fileOwnerSystem, "SystemFcnPrototype", ssp)>
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %<LibAddToSystemField(system, "EncapSystemFcnPrototype", ssp)>
    %endif
  %endif

%endfunction %% LibCacheSubsystemPrototype

%% Function: LibDumpSystemPrototype ============================================
%% Abstract:
%%   Place the system function prototypes in the output stream.
%%
%function LibDumpSystemPrototype(system) Output
  %assign systemFcnPrototype = LibGetSystemField(system,"SystemFcnPrototype")
  %if !WHITE_SPACE(systemFcnPrototype)
    %<systemFcnPrototype>\
  %endif
%endfunction %% LibDumpSystemPrototype

%% Function: SLibSetNeedLocalTIDInSystem =======================================
%% Abstract:
%%
%function SLibSetNeedLocalTIDInSystem(system, fcnType) void
  %assign fcnTypeName = (fcnType == "Outputs") ? "Output" : fcnType 
  %assign fieldName = "NeedLocalTIDIn%<fcnTypeName>"
  %if ISFIELD(system, fieldName)
    %assign system.%<fieldName> = TLC_TRUE
  %else
    %addtorecord system %<fieldName> TLC_TRUE
  %endif
%endfunction

%% Function: SLibGetNeedLocalTIDInSystem =======================================
%% Abstract:
%%
%function SLibGetNeedLocalTIDInSystem(system, fcnType)
  %assign fieldName = "NeedLocalTIDIn%<fcnType>"
  %if ISFIELD(system, fieldName)
    %return system.%<fieldName>
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibTIDInSystem =========================
%% Abstract:
%%    This function returns a tid if it is in the scope of a subsystem function
%%    and can be called before or during TLC generating code. 
%%    It returns the tid argument name, if a tid is passed as argument in the 
%%    system function scope.
%%
%%    If tid is not passed as argument in the scope, this function returns: 
%%       1. '0' if model is single tasking,
%%       2. the tid value of the subsystem if the subsystem is single rate,
%%       3. returns a local tid variable name, if the subsystem is multirate. 
%%          A local tid variable will be added to the subsystem code.
%%   
%% Note:
%%    This function issue an error message, if it is called for a reusable
%%    subsystem whose instance run at different rate.  
%%
%% Example:
%%    LibTIDInSystem(system, fcnType)
%%     
%%    system  - is a record within the global CompiledModel record. 
%%    fcnType - can be any of the following: 'Output','Update','Outputupdate'
%%
%function LibTIDInSystem(system, fcnType) void
  %assert (fcnType == "Output" || ...
    fcnType == "Update" || fcnType == "OutputUpdate")
  %if ::CompiledModel.NumSampleTimes == 1 || ...
    SLibSingleTasking()
    %return "0"
  %elseif LibIsSingleRateSystem(system)
    %assign tmpTid = FcnGetSubsystemTID(system, TLC_TRUE)
    %if tmpTid == -1
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:ReuseOfDifferentRate", "%<system.Name>")>
    %else 
      %return FcnGetSubsystemTID(system, TLC_TRUE)
    %endif
  %else
    %if IsModelReferenceBaseSys(system)
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibTIDCall", "%<system.Name>")>
    %else
      %<SLibSetNeedLocalTIDInSystem(system, fcnType)>
      %return tTID
    %endif
  %endif
%endfunction %% LibTIDInSystem

%% Function: SLibDumpLocalTidInSystem ==========================================
%% Abstract:
%%
%function SLibDumpLocalTidInSystem(system, fcn) 
  %assign needLocalTid = SLibGetNeedLocalTIDInSystem(system,fcn)
  %if fcn == "OutputUpdate"
    %assign needLocalTid = needLocalTid || ...
      SLibGetNeedLocalTIDInSystem(system,"Output") || ...
      SLibGetNeedLocalTIDInSystem(system,"Update")
  %endif
  %openfile tmpBuf
  %if needLocalTid && !LibSystemFcnNeedsTID(system, fcn)     
    %% System need local tid value, but does not pass in tid arg
    %assign tidValue = LibIsSingleRateSystem(system) ? ...
      FcnGetSubsystemTID(system,TLC_FALSE) : system.CurrentTID
    int_T %<tTID> = %<tidValue>; 
  %endif
  %closefile tmpBuf
  
  %return tmpBuf
%endfunction

%% Function: LibDumpFcnOpen ====================================================
%% Abstract:
%%   Dump the opening (start) of the specified function (e.g. Output).
%%
%function LibDumpFcnOpen(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %if fcnInfo.SfcnFormDefine != ""
    #define %<fcnInfo.SfcnFormDefine>
  %endif
  %<fcnInfo.Open>\
  %<SLibDumpLocalTidInSystem(system, function)>
%endfunction %% LibDumpFcnOpen

%% Function: LibDumpFcnBegin ===================================================
%% Abstract:
%%   Dump the beginning of the function (e.g. Output) code.
%%
%function LibDumpFcnBegin(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %<fcnInfo.Begin>\
%endfunction %%LibDumpFcnBegin

%% Function: LibDumpFcnClose ===================================================
%% Abstract:
%%   Dump the closing of the specified function (e.g. Output).
%%
%function LibDumpFcnClose(system,function) Output
  %assign fcnInfo = LibGetFcnInfo(system, function, system.CurrentTID)
  %<fcnInfo.Close>\
%endfunction %% LibDumpFcnClose

%% Function: FcnSysFcnHasRTM ===================================================
%% Abstract:
%%   Returns whether a system fcn needs the real time model as an arg
%%
%function FcnSysFcnHasRTM(system, sysFcn) void
  %assign cTID = system.CurrentTID
  %assign isRG = SLibSystemFcnRateGrouping(system, sysFcn)
  %with system.Interface
    %assign hasRTM = SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && ...
      LibSystemIsReusedFcn(system) && !LibSystemIsRoot(system)
  %endwith
  %return hasRTM
%endfunction

%% Function: FcnSysNeedAddRTMArg ===========================
%% Abstract: 
%%     This function return true when the subsystem
%%     doesn't have rtm arg, but it must be added to arg list due to: 
%%     1. S-Function target
%%     2. Malloc target (grt malloc) or ERT Multi-Instance,
%%        and system cross flag is true 
%%        (Noreusable system in reusable system). 
%%
%function FcnSysNeedAddRTMArg(system, sysFcn) void
  %if FcnSysFcnHasRTM(system, sysFcn) 
    %return TLC_FALSE
  %else
    %return (CodeFormat == "S-Function") || ...
     (system.CrossNoArgFcnBound && (UsingMalloc || (MultiInstanceERTCode && !GenerateClassInterface)))
  %endif
%endfunction


%% Function: SLibSystemFcnInfoRecord ===========================================
%% Abstract:
%%   Returns the function info record for LibDefineSystemFcn. 
%%   See LibDefineSystemFcn
%%
%function SLibSystemFcnInfoRecord(system, sysFcn) void
  %<FcnResetFunctionRecord()>
  %assign fcnname = sysFcn + "Fcn"
  %assign sysIdx  = system.SystemIdx
  %assign isRoot  = (system.Type == "root")

  %% In the exporting functions model 1 (exporting functions), we want to
  %% use the user specified function name to the wrapper.  Thus the real
  %% function is rename to fcnname_core
  %assign functionExported = TLC_FALSE
  %if ExportFunctionsMode == 1 && system.Type == "function-call" && ...
    sysFcn == "OutputUpdate"
    %%
    %assign rootSystem = System[NumSystems-1]
    %foreach id = rootSystem.NumChildSystems
      %assign systemId = rootSystem.ChildSystems[id][0]
      %if systemId == sysIdx
        %assign functionExported = TLC_TRUE
        %break
      %endif
    %endforeach
  %endif

  %assign getFcnNameFromFPC = TLC_FALSE
  %% Try to get function name from FPC
  %if  IsModelReferenceBaseSys(system)
    %if (sysFcn == "OutputUpdate") && ...
      SLibFcnProtoCtrlActive()
      %assign FPC = FcnGetFunctionPrototypeRecord()
      %assign ::FcnRec.Name = FPC.FunctionName
      %assign getFcnNameFromFPC = TLC_TRUE
    %elseif (sysFcn == "Initialize") && ...
      SLibFcnProtoCtrlActive() 
      %assign FPC = FcnGetFunctionPrototypeRecord()
      %assign ::FcnRec.Name = FPC.InitFunctionName
      %assign getFcnNameFromFPC = TLC_TRUE
    %elseif GenerateClassInterface 
      %assign getFcnNameFromFPC = TLC_TRUE
      %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
      %if sysFcn == "OutputUpdate"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + FPC.FunctionName
      %elseif sysFcn == "Initialize"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "init"
      %elseif sysFcn == "Start"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "start"
      %elseif sysFcn == "Terminate"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "terminate"
      %elseif sysFcn == "Enable"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "enable"
      %elseif sysFcn == "Disable"
        %assign ::FcnRec.Name = FPC.ModelClassName + "::" + "disable"
      %endif
    %endif
  %endif
  
  %if !getFcnNameFromFPC
    %% get fcn name from system record.
    %assert(ISFIELD(system,fcnname))
    %assign fcnName = GETFIELD(system, fcnname)
    %if LibAsynchronousTriggeredTID(system.CurrentTID) 
      %% Async fcn-call system is signle rate, 
      %% Never append tid to fcn name
      %assign appendTIDToFcnName = TLC_FALSE
    %elseif SLibIsRateGrouping()
      %% Append tid to fcn name if rate grouping
      %assign appendTIDToFcnName = SLibSystemFcnRateGrouping(system, sysFcn)
      
      %if appendTIDToFcnName && SLibCGGenSystemFcn(system) && ...
        ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ
        %assign ssTid = LibGetSubsystemTID(system, TLC_FALSE)
        %if TYPE(ssTid) == "Vector" && SIZE(ssTid,1) == 2 && ...
          ssTid[0] == 0 && ssTid[1] == 1 
          %assign appendTIDToFcnName = TLC_FALSE
        %endif
      %endif
    %else
      %assign appendTIDToFcnName = TLC_FALSE
    %endif
    %if appendTIDToFcnName
      %assert !WHITE_SPACE(system.CurrentTID)
      %assign fcnName = fcnName + "TID%<system.CurrentTID>"
    %endif
    %assign ::FcnRec.Name = fcnName
  %endif

  %% If the system is reusable and it already has rtModel as an
  %% argument, don't add it again.
  %if FcnSysNeedAddRTMArg(system, sysFcn)
    %assign locSS = RTMGetModelSS()
    %if !FcnSysFcnHasRTM(system, sysFcn)
      %if LibSystemIsRoot(system) && (CodeFormat == "S-Function")
        %<FcnAddArgument(tSimStructType + " *", locSS, locSS)>
      %else
        %<FcnAddArgument(tSimStructType + " *const ", locSS, locSS)>
      %endif
    %endif
  %endif

  %if LibSystemFcnNeedsCPI(system,sysFcn)
    %if SLibAutosarCompilerAbstractionRequired()
      %<FcnAddArgumentWithCompilerAbstraction(TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, tControlPortIdx, ...
        tControlPortIdx)>
    %else
      %<FcnAddArgument("int_T ", tControlPortIdx, ...
        tControlPortIdx)>
    %endif
  %endif

  %if LibSystemFcnNeedsTID(system,sysFcn)
    %if SLibAutosarCompilerAbstractionRequired()
      %<FcnAddArgumentWithCompilerAbstraction(TLC_FALSE, "int_T", TLC_FALSE, TLC_FALSE, tTID, tTID)>
    %else
      %<FcnAddArgument("int_T ",tTID, tTID)>
    %endif
  %endif

  %assign ::FcnRec.CommonPrms = FcnRec.Params

  %if !LibSystemIsInlined(system) && !isRoot
    %<FcnAddParametersAndReturn(sysFcn, sysIdx)>
  %endif
  %if ISEMPTY(::FcnRec.Returns)
    %assign ::FcnRec.Returns = "void"
  %endif
  
  %% non-reusable non-inlined subsystem functions can also be part of the
  %% model class; its prototype may or may not have a classname:: prefix
  %% depending on it is in the declaration position (in class) or definition
  %% position (in .cpp).
  %assign nonReuseFcnAsMemFcn = SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
  %assign optClassNamePrefix = ""
  %if nonReuseFcnAsMemFcn
    %assign FPC = FcnGetRTWCPPStepPrototypeRecord()
    %assign optClassNamePrefix = FPC.ModelClassName + "::"
  %endif
 
  %assign fcnPrototype = ""
  %if ISEMPTY(FcnRec.Params)
    %if !nonReuseFcnAsMemFcn
      %assign fcnPrototype = fcnPrototype + FcnRec.Name + "(void)"
    %else
      %% C++ conventions is not to use 'void' for empty param function prototype
      %assign fcnPrototype = fcnPrototype + FcnRec.Name + "()"
    %endif %% !nonReuseFcnAsMemFcn
  %else
    %assign fcnPrototype = fcnPrototype + FcnRec.Name + "(" + FcnRec.Params + ")"
  %endif %% ISEMPTY(FcnRec.Params)
  
  %assign statQual = ""
  %if isRoot && RootBodyMthsStatic && !nonReuseFcnAsMemFcn
      %assign statQual = "static "
  %endif
  %% If generating C++ and the function isn't static (thus limiting visibility
  %% to a single file) then extern "C" it because it will be called from the
  %% static <target>_main.c file.
  %assign cppStorageClass = ""
  %if GenCPP && isRoot && (statQual == "") && !nonReuseFcnAsMemFcn
      %assign cppStorageClass = ExternCPrefix + " "
  %endif

  %if (sysFcn == "Initialize" || sysFcn == "Start" || sysFcn == "Terminate")
    %assign msFcnType = "MemSecFuncInitTerm"
  %else
    %assign msFcnType = "MemSecFuncExecute"
  %endif
  
  %% Create function opening:
  %% pre-pragma + qualifiers + function prototype
  %openfile open
  %<SLibIfNetPreprocessorCondition(system)>
  %<SLibGetFcnMemSecPragmaForSystem(FcnRec.Name, msFcnType, "Pre", system)>\
  %if SLibAutosarCompilerAbstractionRequired()
    %if SLibAutosarIsMultiRunnableFcn(FcnRec.Name)
      %assign memclass = "FuncCalledByRTE"
    %else
      %assign memclass = "FuncInternal"
    %endif

    %<cppStorageClass> %<statQual> %<SLibAutosarCompilerAbstractionForFcnDeclRtnType(FcnRec.Returns, memclass)> %<optClassNamePrefix>%<fcnPrototype>
  %else
    %<cppStorageClass> %<statQual> %<FcnRec.Returns> %<optClassNamePrefix>%<fcnPrototype>
  %endif
  {
  %closefile open

  %% Create function closing
  %openfile close
  }
  %<SLibGetFcnMemSecPragmaForSystem(FcnRec.Name, msFcnType, "Post", system)>\
  %<SLibEndIfNetPreprocessorCondition(system)>
  %closefile close
  
  %assign begin = ""
  
  %%
  %% For root methods in S-function format, we may need a 
  %% # define before the method. We cache that here
  %%
  %assign sfcnFormDefine = ""
  %if isRoot && (CodeFormat == "S-Function")
    %assign sfcnFormDefine = FcnGetSfcnFormDefine(sysFcn)
  %endif
  
  %assign name = sysFcn + "FcnInfo"
  %if SLibAutosarCompilerAbstractionRequired()
    %if SLibAutosarIsMultiRunnableFcn(FcnRec.Name)
      %assign memclass = "FuncCalledByRTE"
    %else
      %assign memclass = "FuncInternal"
    %endif
    
    %assign fcnPrototype = SLibAutosarCompilerAbstractionForFcnDeclRtnType(FcnRec.Returns, memclass) + " " + fcnPrototype
  %else
    %assign fcnPrototype = FcnRec.Returns + " " + fcnPrototype
  %endif
    
  %createrecord %<name> \
  { \
    SysFcn         sysFcn; \
    Name           FcnRec.Name; \
    Returns        FcnRec.Returns;\
    Params         FcnRec.Params; \
    CommonPrms     FcnRec.CommonPrms; \
    CommonArgs     FcnRec.CommonArgs; \
    FcnPrototype   fcnPrototype; \
    SfcnFormDefine sfcnFormDefine; \
    Open           open; \
    Begin          begin; \
    Close          close \
  }
  %return %<name>
%endfunction 

%function SLibSystemFcnIsExtern(system, tid, fcn) void
  %return SLibSystemIsModelEntryPoint(system, tid) && ...
    (fcn == "Output" || fcn == "OutputUpdate" || fcn == "UpdateContStates" || ...
    fcn == "Enable" || fcn == "Disable")
%endfunction

%% Function: SLibSystemFcnIsModelEntryPoint
%%  
%function SLibSystemIsModelEntryPoint(system, tid) void
  %assign retVal = TLC_FALSE
  %if  ExportFunctionsMode == 1
    %assign retVal = (system.Type == "function-call" && system.Exported == "yes" )
  %else
    %if ExportFunctionsMode == 2 && system.Type == "function-call" && ...
      system.DescSysNonTrigTID[0] >= NumSynchronousSampleTimes 
      %assign retVal = TLC_TRUE
    %endif
    %if LibSystemIsRoot(system) %%|| IsModelReferenceBaseSys(system)
      %if  SLibFcnProtoCtrlActive() || SLibAutosarActive() || ...
        LibIsDeploymentDiagram() || SLibIsAsyncTaskOnlyModel()
         %assign retVal = TLC_FALSE
      %else
        %if SLibIsRateGrouping() && SlibNeedExternRootSysRateGroupingFcn()
          %if TYPE(tid) == "Number" && !((tid == 1)&&Tid01Eq) && ...
            !LibAsynchronousTriggeredTID(tid)
            %assign retVal = TLC_TRUE
          %endif
        %else
          %% solver always call rate grouped function if rate grouping is on
          %assign retVal = ISEQUAL(tid,"") || ...
            (SLibIsRateGrouping() && ISEQUAL(tid,0) && NumContStates > 0)
        %endif
      %endif
    %endif
  %endif
  %return retVal
%endfunction


%% Function: LibDefineSystemFcnForTID ==========================================
%% Abstract:
%%   Cache a record in the system scope so that the subsystem block
%%   (who calls the function) knows the prototyped.          
%%
%%   Arguments:
%%      system: Simulink system
%%      sysFcn: The system function to define
%%                  o Initialize
%%                  o Output
%%                  o Update
%%                  o OutputUpdate
%%                  o Derivative
%%                  o Enable
%%                  o Disable
%%      fcnRec: Reference to fcnRec (see top of file for definition of record)
%%
%%
%%   Example:
%%      %assign fcnRec.Name    = "foo"
%%      %assign fcnRec.Returns = "void"
%%      %assign fcnRec.Params  = "int_T tid"
%%      %assign fcnRec.Args    = "tid"
%%
%%      %<LibDefineSystemFcnForTID(system, "OutputUpdate", tid)>
%%
%%      Creates a function information record in the system scope:
%%
%%      System {
%%        :
%%        OutputUpdateFcnInfo {
%%          Name         "foo"
%%          Returns      "void"
%%          Params       "int_T tid"
%%          Args         "tid"
%%          fcnCall      "foo(tid)"
%%          fcnPrototype "void foo(int_T tid)"
%%       }
%%
%function LibDefineSystemFcnForTID(system, sysFcn,tid) void
  %assign system.CurrentTID = tid
  %assign isRateGrouping = SLibSystemFcnRateGrouping(system, sysFcn) || ...
    (LibAsynchronousTriggeredTID(system.CurrentTID) && ...
    (sysFcn == "Output" || sysFcn == "Update" || sysFcn == "OutputUpdate"))
  %assign fcnRecord = SLibSystemFcnInfoRecord(system, sysFcn)
    
  %if isRateGrouping && TYPE(system.CurrentTID) == "Number"
    %% Set up the global vars for this system and function, this
    %% is needed for nonreusable functions that live in reusable functions
    %assign globalVars = LibInitializeGlobalVars(system, sysFcn)
    %<LibSetSystemField(system, ...
      "Cached%<sysFcn>%<system.CurrentTID>GlobalVars",  globalVars)>
    %<LibAddToSystem(system,...
      "%<sysFcn>TID%<system.CurrentTID>FcnInfo", fcnRecord)>
  %else
    %% Set up the global vars for this system and function, this
    %% is needed for nonreusable functions that live in reusable functions
    %assign globalVars = LibInitializeGlobalVars(system, sysFcn)
    %if !ISEMPTY(globalVars) && !WHITE_SPACE(globalVars)
      %<LibSetSystemField(system, "Cached"+sysFcn+"GlobalVars",  globalVars)>
    %endif
    %<LibAddToSystem(system, sysFcn + "FcnInfo", fcnRecord)>
  %endif

  %if LibSystemIsInlined(system)
    %% If inlining reassign Open and FcnCall
    %openfile declarebuf
    %<LibDumpSystemSSVars(system,sysFcn)>\
    %if isRateGrouping
      %<LibGetSystemLocalVars(system, sysFcn, system.CurrentTID)>
      %if sysFcn == "OutputUpdate"
        %<SLibGetFcnLocalVars(system, "Output", system.CurrentTID)>
        %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", system.CurrentTID))
      %else
        %<SLibGetFcnLocalVars(system, sysFcn, system.CurrentTID)>      
      %endif
    %else
      %<LibGetSystemLocalVars(system, sysFcn, "")>
      %if sysFcn == "OutputUpdate"
        %<SLibGetFcnLocalVars(system, "Output", "")>
        %assert ISEMPTY(SLibGetFcnLocalVars(system, "Update", ""))
      %else
        %<SLibGetFcnLocalVars(system, sysFcn, "")>      
      %endif
    %endif
    %closefile declarebuf
    %if LibSystemUserCodeIsEmpty(system,sysFcn,"Header") && ...
      WHITE_SPACE(declarebuf)
      %assign needOutputsBrace = 0
    %else
      %assign needOutputsBrace = 1
    %endif
    %if needOutputsBrace
      %assign fcnRecord.Open = "{\n"
      %assign fcnRecord.Begin = "\n"
      %assign fcnRecord.Close = "}\n"
    %else
      %assign fcnRecord.Open  = ""
      %assign fcnRecord.Begin = ""
      %assign fcnRecord.Close = ""
    %endif    
  %else
    %if (!LibSystemFcnIsEmptyHelper(system,sysFcn,tid)) || ...
      (system.Type == "function-call" && sysFcn == "OutputUpdate" && ...
      ISEQUAL(tid,FcnGetSubsystemTID(system,TLC_TRUE)))
      %% Only dump the prototype if the caller does not live
      %% in the same file or it is a Async sfcn.
      %if (system.Type != "root") && ...
        !(IsModelReferenceBaseSys(system) && LibAsynchronousTriggeredTID(tid)) && ...
        !SLibSystemFcnIsExtern(system, tid, sysFcn)
        %<LibCacheSubsystemPrototype(system,fcnRecord)>\
      %endif
    %endif
  %endif
  %assign system.CurrentTID = -1
%endfunction %% LibDefineSystemFcnForTID

%% Function: LibDefineSystemFcn ================================================
%% Description:
%%   Call LibDefineSystemFcn to Cache record(s) in the system scope 
%%   so that the subsystem block (who calls the function) knows 
%%   the prototyped. When SLibSystemFcnRateGrouping( is true, records are
%%   cached very each tid function call.
%%
%function LibDefineSystemFcn(system, sysFcn) void
  %if sysFcn == "Output" || sysFcn == "Update" || ...
    sysFcn == "OutputUpdate"
    %if system.Type == "root" || IsModelReferenceBaseSys(system) 
      %if SLibSystemFcnRateGrouping(system, sysFcn)
	%foreach tid = NumSynchronousSampleTimes
	  %<LibDefineSystemFcnForTID(system, sysFcn,tid)>
	%endforeach
      %else
	%<LibDefineSystemFcnForTID(system, sysFcn, "")>
      %endif
      %% For now, define the async systems here.
      %if IsModelReferenceBaseSys(system)
        %assert(LibGetNumAsyncTasks() == 0 || ...
          ::CompiledModel.AllowModelRefFcnCallInputs != 0)
        
        %% Async code is always rate grouped        
        %foreach tidIdx = LibGetNumAsyncTasks()
          %assign tid = tidIdx + NumSynchronousSampleTimes
          %<LibDefineSystemFcnForTID(system, sysFcn,tid)>
        %endforeach
      %endif
    %elseif SLibAutosarActive()
      %assign sysTid = FcnGetSubsystemCodeBufTID(system)
      %<LibDefineSystemFcnForTID(system, sysFcn, sysTid)>
    %else
      %assign sysIdx   = system.CallSites[0][2]
      %assign blkIdx   = system.CallSites[0][3]
      %assign subssTID = System[sysIdx].Block[blkIdx].SubsystemTID
    
      %if TYPE(subssTID) == "Vector"
	%if SLibSystemFcnRateGrouping(system, sysFcn)
	  %assign hasDefineSysFcnForTID0 = TLC_FALSE
	  %foreach idx = SIZE(subssTID,1)
	    %assign tid =  subssTID[idx]
	    %% For tid01Eq=1, tid1 code is gouped with tid0 code
	    %assign tid01Eq = ISEQUAL(SolverType, "FixedStep") && ...
	      FixedStepOpts.TID01EQ
	    %assign tid = tid01Eq && (tid == 1) ? 0 : tid
	    
	    %% Don't need define system fcn for asynchronous
	    %% task. Async task fcn is defined by its sfunction 
	    %% caller
	    %%
	    %% Also avoid define sys fcn for tid0 twice 
	    %%
	    %if LibAsynchronousTriggeredTID(tid) || ...
	      hasDefineSysFcnForTID0 && tid == 0 
	      %continue
	    %endif
	    %if tid == 0
	      %assign hasDefineSysFcnForTID0 = TLC_TRUE
	    %endif
	    %<LibDefineSystemFcnForTID(system, sysFcn,tid)>
	  %endforeach
	%else
	  %<LibDefineSystemFcnForTID(system, sysFcn,"")>
	%endif
      %else
	%<LibDefineSystemFcnForTID(system, sysFcn, "")>
      %endif
      %% Async code is always rate grouped
      %foreach tidIdx = LibGetNumAsyncTasks()
	%assign tid = tidIdx + NumSynchronousSampleTimes
	%<LibDefineSystemFcnForTID(system, sysFcn,tid)>
      %endforeach
    %endif
  %else
    %<LibDefineSystemFcnForTID(system, sysFcn, "" )>
  %endif
%endfunction %% LibDefineSystemFcn

%% Function: LibGenSubsystemFcnCall ============================================
%% Abstract:
%%   Generates a function call to a system.
%%
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments of output idx
%%                  and rule idx. use [] if the fcn is not SetDims fcn.
%%          canIO - a vector of strings for actual arguments of canonical I/O,
%%                  use [] normally works.
%%        fcnInfo - contains the function name and the type of the call
%%                  (e.g. "Start, Output, Update, ...")
%%   parentSysIdx - location of the system call
%%                  (Where the function is called)
%%         sysIdx - system to be called
%%    callSiteIdx - system instance to be used   
%%
%function LibGenSubsystemFcnCall(outAndRuleIdx, canIO, fcnInfo, parentSysIdx, sysIdx, callSiteIdx) void
  %assign accessSysIdx = System[parentSysIdx].HStructDeclSystemIdx
  %assign addArgs = FcnGetAdditionalArgs(outAndRuleIdx, canIO, ...
    fcnInfo.SysFcn, sysIdx, accessSysIdx, callSiteIdx)
  %assign comArgs = fcnInfo.CommonArgs
  %assign cs = System[sysIdx].CallSites[callSiteIdx]
  %assign ssBlk = System[cs[2]].Block[cs[3]]
  %%
  %assign comma = (WHITE_SPACE(addArgs) || WHITE_SPACE(comArgs)) ? "" : ", "
  %%
  %% If one or more of arguments of a function that is passed by address
  %% is a expression, than the result of this expression has to be stored
  %% in a temporrary variable. The address of the temporary variable will
  %% than be passed as the argument of the function call.
  %%
  %if (fcnInfo.SysFcn == "OutputUpdate") && ...
    IsModelReferenceBaseSys(System[sysIdx]) && ...
    SLibFcnProtoCtrlActive() 
    %assign FPC = FcnGetFunctionPrototypeRecord()
    %assign fcnName = FPC.FunctionName
  %else
    %assign fcnName = fcnInfo.Name 
  %endif
  %if ISFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
    %assign fcnCallCode = GETFIELD(ssBlk, "%<fcnInfo.SysFcn>FcnCallCode")
    %assign fcnCall = ""
    %openfile fcnCall
    {
      %<fcnCallCode.localPrmDecl>
      %<fcnCallCode.localExpr>
      %<fcnName>(%<comArgs>%<comma>%<addArgs>);
    }
    %closefile fcnCall
    %return fcnCall
  %else
    %return "%<fcnName>(%<comArgs>%<comma>%<addArgs>);"
  %endif
%endfunction

%% Function: FcnGetCanDWorkArg ==================================================
%% Abstract:
%%   Returns a canonical dwork argument for a give argument index, callsite,
%%   access system index and callsite index.
%%
%function FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx) void
  %%
  %assign parent = System[sysIdx]
  %%
  %% Get the reused function or root
  %%
  %assign callerHStSystem = SLibCallerHStuctDeclSystem(parent, callSiteIdx)
  %assign dwArg = ""
  %assign ssBlk = System[cs[2]].Block[cs[3]]
  
  %with parent 
    %assign cTID = FcnGetCurrentAccessTid()
  %endwith  
  
  %assign alignment = -1
  %if ISFIELD(parent.Interface.CanonicalDWorkArgDef[argIdx], "Alignment")
    %assign alignment = parent.Interface.CanonicalDWorkArgDef[argIdx].Alignment
  %endif

  %if IsModelReferenceTarget() && accessSysIdx == NumSystems-1 && ...
    ISFIELD(parent.Interface.CanonicalDWorkArgDef[argIdx], "DWorkForNumIters")
    %assign dwArg = "&NumIter_%<argIdx>"
  %elseif sysIdx == accessSysIdx
    %% For code reuse of multi-mode enable/trigger subsystems,
    %% function FinalizeDims is not called by its parent
    %% subsystem. It is called by its output function.
    %% In the output function, local reference of the canonical
    %% dwork for current dimensions should be used to call the
    %% function FinalizeDims
    %%
    %% Also, output function may also call its enable function 
    %% for the same type subsystems
    %%
    %% IIS enable function could call its initialization function,
    %% NumIter is passed around as Canonical DWork.
    %%
    %assert (sysFcn == "FinalizeDims" || sysFcn == "Enable" || ...
      SLibGetSubsystemIsImplicitIterSS(parent))
    %assert (parent.HStructDeclSystemIdx == sysIdx)
    %assert (callSiteIdx == 0)
    %%
    %% idNum[0] == "dp"
    %%
    %% we want to access a formal argument at the callsite
    %% of sysIdx being called by itself, dp0 tells that it
    %% is the 1st dwork argument of the parent reusable
    %% subsystem, and it is passed in as the argIdx'th
    %% argument of sysIdx.
    %%
    %% the same is true for "D" and "d".
    %%
    %assign canDWorkArgDef = ...
      parent.Interface.CanonicalDWorkArgDef[argIdx]
    %assign dwArg = LibGetRecordIdentifier(canDWorkArgDef)
    %<SLibAccessArgHelper(canDWorkArgDef, "",cTID)>
    %if parent.CrossNoArgFcnBound
      %<SLibAccessArgHelper(canDWorkArgDef, "Global",cTID)>
      %assign dwArg = canDWorkArgDef.GlobalIdentifier
    %endif
  %else
    %assign arg    = ssBlk.CallSiteInfo.CanonicalDWorkArg[argIdx]
    %assign argSrc = arg.SignalSrc %% Di, di or dpi
    %assign idNum  = IDNUM(argSrc)
    %%
    %assert (idNum[0] == "D" || idNum[0] == "d" || idNum[0] == "dp" || idNum[0] == "db")
    %%
    %%
    %assign callerSysIdx = cs[0]
    %assign cross        = System[callerSysIdx].CrossNoArgFcnBound
    %if idNum[0] == "dp" %% uses relative idx
      %assert (callerHStSystem.Type != "Root")
      %%
      %if callerHStSystem.SystemIdx < accessSysIdx
        %assign parentNonReuseSysIdx = System[parent.CallSites[callSiteIdx][0]].ReusedParentSystemIdx
        %assign nonreuseCallerSysIdx = System[parentNonReuseSysIdx].CallSites[cs[1]]
        %assign dwArg = FcnGetCanDWorkArg(sysFcn, nonreuseCallerSysIdx,  idNum[1], ...
          parentNonReuseSysIdx, accessSysIdx, cs[1])
      %else
        %%
        %% If the callerHStSystem is a hidden system for 
        %% Implicit Iterator Subsystem, it might not have 
        %% Interface.CanonicalDWorkArgDef field because it might be
        %% inlined.
        %%
        %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
        %assign callerDWork = ...
          localSystem.Interface.CanonicalDWorkArgDef[idNum[1]]
        %assign dwArg   = LibGetRecordIdentifier(callerDWork)
        %<SLibAccessArgHelper(callerDWork, "",cTID)>
        %if cross
          %<SLibAccessArgHelper(callerDWork, "Global",cTID)>
          %assign dwArg = callerDWork.GlobalIdentifier
        %endif
      %endif
    %elseif idNum[0] == "db" %% access buried DWork
      %if callerHStSystem.SystemIdx != accessSysIdx
        %% For dwork in hidden system for Implicit Iterator Subsystem,
        %% callerHStSystem is not accessSys. 
        %assign localSystem = SLibCallerReusedParentSystem(parent, callSiteIdx)
        %assert(localSystem.SystemIdx == accessSysIdx)
      %endif
      %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
      %assign dwRec = dworkAndRec.DWorkRec
      %assign dwArg = ...
        "&" + ...
        FcnCGIRCGVarHelper(dwRec.VarGroupIdx[0], dwRec.VarGroupIdx[1], ...
        cross, accessSysIdx, SLibDWorkWidth(dwRec), "", -1, ...
        "", 0, TLC_FALSE)
    %elseif idNum[0] == "D" || idNum[0] == "d" %% global or local access
      %assign dworkAndRec = FcnGetDworkAndRec(argSrc)
      %assign dwRec       = dworkAndRec.DWorkRec
      %% temporary work around for g494342

      %if idNum[0] == "D" || dwRec.StorageClass != "Auto"
        %% Example,
        %%   Scalar: foo(&DWork.a)
        %%   Wide:   foo(&DWork.b[0])
        %%
        %% if dwork belongs to ExternalInputSize
        %% vargroup, it is actually not a DWork.
        %% this only happens for "D" case, not for
        %% "d", "dp" and "db".       
        %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]
        %assign varGroup = ...
              ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]]
            
        %if alignment > 0
          %if dwRec.Alignment > alignment
            %assign alignment = dwRec.Alignment
          %endif
          %if varGroup.Alignment > alignment
            %assign alignment = varGroup.Alignment
          %endif          
          %assign ::CompiledModel.DWorks.DWork[idNum[1]].Alignment = alignment
          %assign ::CompiledModel.VarGroups.VarGroup[dwRec.VarGroupIdx[0]].Alignment = alignment
        %endif
            
        %if varGroup.Category == "ExternalInputSize"
          %if CodeFormat == "S-Function" && !Accelerator
            %assign memberIdx = dwRec.VarGroupIdx[1]
            %assign cgTypeIdx = SLibCGVarGroupMemberCGTypeIdx(...
              dwRec.VarGroupIdx[0], ...
              memberIdx)
            %assign dwArg = "&" + FcnCGIRSFcnSizeVarHelper("ssGetCurrentInputPortDimensions", ...
              TLC_FALSE, "const", ...
              cgTypeIdx, memberIdx, %<LibGetRecordWidth(dwRec)>, "", "", 0)
          %else
            %assign memberIdx = dwRec.VarGroupIdx[1]
            %assign portVar = FcnSLibCGIRGetVarGroupMember(varGroup, memberIdx)
            %assign identifier = varGroup.Name + "." + portVar.Name
            %assign dwArg = FcnCGIRSimpleCGVarHelper(identifier, ...
              TLC_FALSE, %<LibGetRecordWidth(dwRec)>, "", -1, "", 0, TLC_TRUE)
          %endif
        %else
          %assign dwArg = SLibGetGlobalDWorkAddr(idNum[1], cross)
        %endif
      %else %% "d", Auto storage class
        %assert idNum[0] == "d"
        %% Example,
        %%   Scalar: foo(&localDW->a)
        %%   Wide:   foo(localDW->b)
        %%
        %%  If the caller is crossing a function boundary, use
        %%  the global variable instead of localDW.
        %assign dwRec = ::CompiledModel.DWorks.DWork[idNum[1]]
        %assign dwId  = LibGetRecordIdentifier(dwRec)
        %assign dwWidth = SLibDWorkWidth(dwRec)
        %%
        %if cross || callerHStSystem.StandaloneSubsystem
          %if cross
            %assert !callerHStSystem.StandaloneSubsystem
            %<SLibAccessArgHelper(System[accessSysIdx].Interface.DWorkArgDef, "Global",...
              cTID)>
            %assign acc = "->"
          %else
            %assign acc = "."
          %endif
          %assign dWIdent = FcnSysVarGroupNonreusedName(System[accessSysIdx],"DWork")
          %if dwWidth == 1
            %assign dwArg = "&" + dWIdent + acc + dwId
          %else
            %assign dwArg = dWIdent + acc + dwId
          %endif
        %else
          %if !(GenerateClassInterface && IsModelReferenceBaseSys(callerHStSystem))
            %if dwWidth == 1
              %assign dwArg  = "&localDW->" + dwId
            %else
              %assign dwArg  = "localDW->" + dwId
            %endif
          %else
            %%%% must be C++ encap. MdlRef and calling the subsys fcn
            %%%% from the model reference hidden base subsystem
            %assert IsModelReferenceRTWTarget()
            %if dwWidth == 1
              %assign dwArg  = "&(%<tDWork>." + dwId + ")"
            %else
              %assign dwArg  = "%<tDWork>." + dwId
            %endif
          %endif %% !(GenerateClassInterface && IsModelReferenceBaseSys(parent))
        %endif
        %<SLibAccessArgHelper(callerHStSystem.Interface.DWorkArgDef,"",...
          cTID)>
      %endif
    %endif
  %endif
  %return dwArg
%endfunction

%% Function: FcnGetCanDWorkArgs ================================================
%% Abstract: 
%%   
%% Arguments:
%%         sysIdx   - system function to call
%%    callSiteIdx   - system instance to call
%%     accessSysIdx - location of the system call. This can be a function
%%                    or reusable function.
%% Note: If the subsystem is using one of its CanonicalDWork,
%%       and the subsystem is in a reusable function, it must mark 
%%       the corresponding reusable function arg as Accessed. 
%%
%function FcnGetCanDWorkArgs(sysFcn, sysIdx, accessSysIdx, callSiteIdx, ...
  currentTID, isRateGrouping) void
  %assign cs    = System[sysIdx].CallSites[callSiteIdx]
  %assign args  = ""
  %assign comma = ""
  %assign errTxt = "Invalid SignalSrc for CanonicalDWork."
  %assign parent = System[sysIdx]
  
  %with parent.Interface
    %foreach argIdx = NumCanonicalDWorkArgDefs
      %% Canonical dimsize dwork has already been added to args when 
      %% canonical input(s) and output(s) are processed
      %if AllowVarDimsSig && SLibGetCanDWorkIsCanDimSizeDWork(argIdx)
        %continue
      %endif
      
      %assign canDWork = CanonicalDWorkArgDef[argIdx]
      %if SysFcnArgNeeded(sysFcn, canDWork, currentTID, isRateGrouping)
	%if ConfigSet.GenerateTestInterfaces && ...
          ISFIELD(parent, "GenerateReusableWrapper") && ...
          GETFIELD(parent, "GenerateReusableWrapper") && ...
          ISFIELD(canDWork, "SSGraphicalAPIReference")
            %assign grDS = canDWork.SSGraphicalAPIReference
            %assign args = args + comma + grDS.Name
            %assign comma = ", "
	%else
          %assign args = args + comma + ...
            FcnGetCanDWorkArg(sysFcn, cs, argIdx, sysIdx, accessSysIdx, callSiteIdx)
          %assign comma = ", "
        %endif %% if ConfigSet.GenerateTestInterfaces
      %endif %% if SysFcnArgNeeded
    %endforeach %% argIdx
    %%
  %endwith %% parent.Interface
  %return args
%endfunction %% FcnGetCanDWorkArgs

%% Function: SLibGetCallSitePrmArg =============================================
%% Abstract:
%%   Returns the parameter argument for a given callsite and parmeter index.
%%
%function SLibGetCallSitePrmArg(cs, childPrmIdx) void
  %if System[cs[0]].NumChildPrmArgs == 0
    %return SLibGetCallSitePrmArg(System[cs[0]].CallSites[cs[1]], childPrmIdx)
  %else
    %return System[cs[0]].ChildPrmArg[childPrmIdx]
  %endif
%endfunction %% SLibGetCallSitePrmArg

%% FunctionGetChildPrmArgFromParent  ===========================================
%% Abstract:
%%   This function, for a system's canonical parameter, returns the 
%%   corresponding ChildPrmArg of the parent system. If the parent system 
%%   itself is a reusable function and has the parameter as a canonical param
%%   then the function seeks the true parent of the system. The true parent 
%%   system defines the actual address or value (in case of inlined) of a 
%%   canonical parameter. The true parent's ChildPrmArg contains the actual
%%   address/value of the parameter
%%   For generating test interfaces, we need the actual value/address of a 
%%   canonical parameter instead of its canonical argument string. 
%%
%%  cs: CallSite of the system
%%  childPrmIdx: Index of the ChildPrmArg in the system
%%
%function FunctionGetChildPrmArgFromParent(cs, childPrmIdx) void
  %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
  %if prm.ASTNode.Op == "M_CANPRM_ID"
    %% Canonical param - Top-level Parent defines the memory/value
    %assign sysCS  = System[cs[0]].CallSites[cs[1]]
    %assign ssBlk  = System[sysCS[2]].Block[sysCS[3]]
    %assign argIdx = prm.ASTNode.CanonicalPrmArgDefIdx
    %assign childPrmIdx = ...
	  ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
    %% Recurse to get to the top level parent (true parent)
    %assign prm   = FunctionGetChildPrmArgFromParent(sysCS, childPrmIdx)
  %endif
  %return prm
%endfunction

%% Function: SLibGetHStructWithLocalScopeSystemIdx =============================
%% Abstract:
%%   Return the reusable parent system index for a given system index.
%%
%function SLibGetHStructWithLocalScopeSystemIdx(sysIdx)
  %return ::CompiledModel.System[sysIdx].ReusedParentSystemIdx
%endfunction

%% Function: FcnGetCanonicalOutput =============================================
%% Abstract:
%%   Returns the canonical output argument (string) for a given canonical
%%   output index.
%%
%function FcnGetCanonicalOutput(accessSysIdx, aCallSite, coIdx) void
  %assign   systemIdx = aCallSite[0]
  %assign callsiteIdx = aCallSite[1]
  %assign returnVal = ""
  %with ::CompiledModel
    %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
    %assign system = System[systemIdx]
    %assign sysCurrentTid = system.CurrentTID
    %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
    %with system
      %assign     cross = CrossNoArgFcnBound
      %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
      %with ssBlk %% subsystem block
        %assign co = CallSiteInfo.CanonicalOutputArg[coIdx]
        %assign idnum = IDNUM(co.SignalSrc[0])
        %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
        %assign ssBlk.BlockIdx[1] = accessSysIdx
        %if hStrucIdx < accessSysIdx && idnum[0] == "y"
          %assign cs = System[systemIdx].CallSites[callsiteIdx]
          %assign returnVal = FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
        %else
          %% canonical output, if is scalar, must pass by addr.
          %assign returnVal = FcnGetCanonicalArg(co, 0, cross, TLC_TRUE)
        %endif
        %assign ssBlk.BlockIdx[1] = oldBlockIdx1          
      %endwith
    %endwith %% System[sysIdx]
    %assign system.CurrentTID = sysCurrentTid
  %endwith
  %return returnVal
%endfunction

%% Function: FcnGetCanonicalInput ============================================
%% Abstract:
%%   Returns the canonical input argument (string) for a given canonical
%%   input index.
%%
%function FcnGetCanonicalInput(accessSysIdx, aCallSite, ciIdx) void
  %assign   systemIdx = aCallSite[0]
  %assign callsiteIdx = aCallSite[1]
  %assign returnVal = ""
  %with ::CompiledModel
    %assign ssBlk = System[aCallSite[2]].Block[aCallSite[3]]
    %assign system = System[systemIdx]
    %assign sysCurrentTid = system.CurrentTID
    %assign system.CurrentTID = CurrentTID %% set system current tid to context current tid
    %with system
      %assign     cross = CrossNoArgFcnBound
      %assign hStrucIdx = SLibGetHStructWithLocalScopeSystemIdx(systemIdx)
      %with ssBlk %% subsystem block
        %assign ci = CallSiteInfo.CanonicalInputArg[ciIdx]
        %assign idnum = IDNUM(ci.SignalSrc[0])
        %assert idnum[0] != "F"
        %assign oldBlockIdx1 = ssBlk.BlockIdx[1]
        %assign ssBlk.BlockIdx[1] = accessSysIdx
        %if hStrucIdx < accessSysIdx && (idnum[0] == "u" || idnum[0] == "y")
          %assign cs = System[systemIdx].CallSites[callsiteIdx]
          %if idnum[0] == "u"
            %assign returnVal = ...
              FcnGetCanonicalInput(accessSysIdx, cs, idnum[1])
          %else
            %assign returnVal = ...
              FcnGetCanonicalOutput(accessSysIdx, cs, idnum[1])
          %endif          
        %else
          %assign ssBlkSysIdx = LibBlockParamSetting("Subsystem", "SystemIdx")
          %if LibGetRecordWidth(ci) == 1 && SLibGetISSCanInputIter(ssBlkSysIdx, ciIdx)
            %% If the canonical input is for an Implicit Iterator subsystem and it is 
            %% a scalar, the scalar signal needs to be returned as reference.
            %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, TLC_TRUE)
          %else
            %assign useAddr =  (ci.DeclareAsPointer == "yes")                        
            %assign returnVal = FcnGetCanonicalArg(ci, 0, cross, useAddr)             
          %endif
        %endif
        %assign ssBlk.BlockIdx[1] = oldBlockIdx1
      %endwith
      %assign system.CurrentTID = sysCurrentTid
    %endwith %% System[sysIdx]
  %endwith
  %return returnVal
%endfunction


%% Function: FcnGetAdditionalArgs ============================================
%% Abstract: 
%%   This function generates the arguments needed in for a system function 
%%   call. Refer to GetFunctionStr for the order of parameters.
%%   
%% Arguments:
%%  outAndRuleIdx - a two-elements vector of string for actual arguments of output idx
%%                  and rule idx. use [] if the fcn is not SetDims fcn.
%%          canIO - a vector of strings for actual arguments of canonical I/O,
%%                  use [] normally works.
%%         sysIdx - system function to call
%%    callSiteIdx - system instance to call
%%     accessSysIdx - location of the system call
%%
%function FcnGetAdditionalArgs(outAndRuleIdx, canIO, sysFcn, sysIdx, accessSysIdx, callSiteIdx) void
  %%
  %% CallSite is misleading in this context. The callsite vector is
  %% defines the memory instances of the function and is
  %% equal to the number of reused instances of a system.
  %%
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign cs = thisSystem.CallSites[callSiteIdx]
  %assign args = ""
  
  %with thisSystem
    %assign cTID = FcnGetCurrentAccessTid()
  %endwith
  
  %assign isRG = SLibSystemFcnRateGrouping(thisSystem, sysFcn)
  %assign genModelRef = IsModelReferenceTarget() && accessSysIdx == NumSystems-1

  %with thisSystem.Interface
    %assign comma = ""
    %assign ssBlk = System[cs[2]].Block[cs[3]]
    %%
    %% Only reused systems get arguments (except for elapased time)
    %if LibSystemIsReusedFcn(thisSystem)
 
    %% We need to reset this so we will use the correct
    %% Interface when accessing canonical inputs and outputs.
    %% See the function SLibGetSourceRecordAndMapInfo in blkiolib.tlc
    %% NOTE: we reset this back after canonical inputs/outputs below.
    %assign saveMe = ssBlk.BlockIdx[1]
    %assign ssBlk.BlockIdx[1] = accessSysIdx

    %assert (sysFcn == "SetDims") == !ISEMPTY(outAndRuleIdx)
  
    %if !ISEMPTY(outAndRuleIdx)
      %assign args = args + comma + outAndRuleIdx[0]
      %assign comma = ","
      %assign args = args + comma + outAndRuleIdx[1]
    %endif  

    %%
    %% Canonical input argument
    %%
    %foreach argIdx=NumCanonicalInputArgDefs
      %if SysFcnArgNeeded(sysFcn, CanonicalInputArgDef[argIdx], cTID, isRG)
	%%
        %if (ConfigSet.GenerateTestInterfaces) && ...
          ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
          GETFIELD(thisSystem, "GenerateReusableWrapper") && ...
          ISFIELD(CanonicalInputArgDef[argIdx], "SSGraphicalAPIReference")
          %assign grIn = CanonicalInputArgDef[argIdx].SSGraphicalAPIReference
          %assign args = "%<args>%<comma>%<grIn.SLName>"
	  %assign comma = ", "
        %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
	  %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(CanonicalInputArgDef[argIdx])>"
	  %assign comma = ", "
          %<SLibAccessArgHelper(CanonicalInputArgDef[argIdx],"",cTID)>
	%elseif !ISEMPTY(canIO) && !ISEMPTY(canIO[argIdx])
          %assign args = args + comma + canIO[argIdx]
          %assign comma = ", "
        %else
          %with System[cs[0]]
            %assign cross = CrossNoArgFcnBound
	    %with ssBlk %% subsystem block
              %assign ci = thisSystem.Interface.CanonicalInputArgDef[argIdx]
              %assign skipThisArg = 0
	      %if IDNUM(ci.SignalSrc[0])[0] == "F"
		%assign skipThisArg = 1
	      %endif	
              %if skipThisArg == 0
		%if genModelRef
		  %assign passByRef = ...
                    (LibGetRecordWidth(ci) > 1 || ci.DeclareAsPointer == "yes")
		  %assign ptr = passByRef ? "" : "*"
		  %assign args = "%<args>%<comma>%<ptr>InPort_%<argIdx>"
		%else
                  %assign args = args + comma + ...
                    FcnGetCanonicalInput(accessSysIdx, cs, argIdx)
		%endif
		%assign comma = ", "
	      %endif
	    %endwith %% subsystem block
	  %endwith %% thisSystem
	%endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
      %endif %% SysFcnArgNeeded

      %% Add vardims argument for the canonical input 
      %assign res = FcnGetAdditionalCanDimSizeDWForCanInp(sysFcn, sysIdx, accessSysIdx, ...
                                                           callSiteIdx, argIdx, comma, args)
      %assign comma = res[0]
      %assign args  = res[1]

    %endforeach %% argIdx=NumCanonicalInputArgDefs
    %%
    %% Canonical output argument
    %%
    %foreach argIdx=NumCanonicalOutputArgDefs
      %if SysFcnArgNeeded(sysFcn, CanonicalOutputArgDef[argIdx], cTID, isRG)
	%%
        %if (ConfigSet.GenerateTestInterfaces) && ...
          ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
          GETFIELD(thisSystem, "GenerateReusableWrapper") && ...
          ISFIELD(CanonicalOutputArgDef[argIdx], "SSGraphicalAPIReference")
          %assign grOut = CanonicalOutputArgDef[argIdx].SSGraphicalAPIReference
          %assign args = "%<args>%<comma>%<grOut.SLName>"
        %else
          %if LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
            %assign args = "%<args>%<comma>%<LibGetRecordIdentifier(CanonicalOutputArgDef[argIdx])>"
            %<SLibAccessArgHelper(CanonicalOutputArgDef[argIdx],"",cTID)>
          %elseif !ISEMPTY(canIO) && !ISEMPTY(canIO[argIdx + NumCanonicalInputArgDefs])
            %assign args = args + comma + canIO[argIdx + NumCanonicalInputArgDefs]
            %assign comma = ", "
          %elseif genModelRef
            %assign args = "%<args>%<comma>OutPort_%<argIdx>"
          %else
            %assign args = ...
              args + comma + FcnGetCanonicalOutput(accessSysIdx, cs, argIdx)
          %endif %%LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %endif %% ConfigSet.GenerateTestInterfaces
        %assign   comma = ", "
      %endif %% SysFcnArgNeeded
      %%
      %% Add vardims argument for the canonical output 
      %assign res = FcnGetAdditionalCanDimSizeDWForCanOut(sysFcn, sysIdx, accessSysIdx, ...
                                                           callSiteIdx, argIdx, comma, args)
      %assign comma = res[0]
      %assign args  = res[1]
      %%
    %endforeach %% argIdx=NumCanonicalOutputArgDefs
    %%
    %% Reset the BlockIdx, see comment above.
    %assign ssBlk.BlockIdx[1] = saveMe
    %assign isScalableMRSys = IsModelReferenceBaseSys(thisSystem) && IsModelRefScalableBuild()
    %%
    %% rtModel argument
    %%
    %if SysFcnArgNeeded(sysFcn, RTMArgDef, cTID, isRG) && !isScalableMRSys
       %if genModelRef
        %assign args = "%<args>%<comma>&(dw->rtm)"
      %else
        %assign rtmArg = FcnUpdateRTModelInterfaceArg(System[accessSysIdx], tSimStruct)
        %assign args = "%<args>%<comma>%<rtmArg>"
      %endif
      %assign comma = ", "
      %assign callerHStSystem = ...
        SLibCallerHStuctDeclSystem(thisSystem, callSiteIdx)
      %<SLibAccessArgHelper(callerHStSystem.Interface.RTMArgDef,"",cTID)>
    %endif
    %%
    %% Block IO argument
    %%
    %if SysFcnArgNeeded(sysFcn, BlockIOArgDef, cTID, isRG) && !isScalableMRSys
      %%
      %% If a system function (e.g. "Start") calls a function of the 
      %% same system (e.g. "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>&(dw->rtb)"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localB"
        %<SLibAccessArgHelper(BlockIOArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = ...
          FcnSysVarGroupIndex(thisSystem, "BlockIO", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
            SLibGetImplicitIterSSMaintainingSeparateGlobalNonReusableIOs(System[cs[0]])
          %% Implicit Iterator Subsystem
          %assign iisarg = SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
          %assign args = "%<args>%<comma>%<iisarg>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "BlockIO")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% Constant block IO argument
    %%
    %if SysFcnArgNeeded(sysFcn, ConstBlockIOArgDef, cTID, isRG)
      %%
      %% If a system function (e.g. "Start") calls a function of the 
      %% same system (e.g. "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %assert !isScalableMRSys
      %if genModelRef
        %assign args = "%<args>%<comma>&rtc_%<::CompiledModel.Name>"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localC"
        %<SLibAccessArgHelper(ConstBlockIOArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = ...
          FcnSysVarGroupIndex(thisSystem, "ConstBlockIO", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %assign dataType = FcnSysVarGroupType(thisSystem,"ConstBlockIO")
        %assign cast = "(" + dataType + "*)"
        %assign args = "%<args>%<comma>%<cast>&%<identiPath>%<indenti>"
      %endif
      %assign comma = ", "
    %endif
    %%
    %% DWork IO argument
    %%
    %if SysFcnArgNeeded(sysFcn, DWorkArgDef, cTID, isRG) && !isScalableMRSys
      %%
      %% If a system function (e.g. "Start") calls a function of the 
      %% same system (e.g. "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>&(dw->rtdw)"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localDW"
        %<SLibAccessArgHelper(DWorkArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = ...
          FcnSysVarGroupIndex(thisSystem, "DWork", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
          SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign iisarg = SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
          %assign args = "%<args>%<comma>%<iisarg>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "DWork")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not use prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% Parameter H-Struct argument
    %%
    %if SysFcnArgNeeded(sysFcn, ParameterArgDef, cTID, isRG)
      %assert !isScalableMRSys
      %if genModelRef
        %assign args = "%<args>%<comma>&rtp_%<::CompiledModel.Name>"
      %else
        %%
        %% Does a passthrough parameter structure argument exists ?
        %%
        %if InlineParameters && ParameterArgDef.PassthroughSystemIdx > -1
          %%
          %% Get the parent callsite vector (pcs)
          %%
          %assign pcs = thisSystem.CallSites[0]
          %%
          %% Mark the parents parameter structure argument as accessed
          %%
          %assign csPrmArgDef = System[pcs[0]].Interface.ParameterArgDef
          %assign prmAccessSysIdx = ParameterArgDef.PassthroughSystemIdx
          %<SLibAccessArgHelper(System[pcs[0]].Interface.ParameterArgDef,"",cTID)>
          %<SLibAccessArgHelper(System[prmAccessSysIdx].Interface.ParameterArgDef,"",cTID)>
          %%
          %if prmAccessSysIdx == NumSystems-1
            %if !GenerateClassInterface
              %assign args = "%<args>%<comma>%<LibGetParametersStruct()>"
            %else
              %if accessSysIdx == NumSystems-1
                %assign args = "%<args>%<comma>&%<LibGetParametersStruct()>"
              %else
                %assign args = "%<args>%<comma> %<LibGetParametersStruct()>"
              %endif
            %endif
          %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx) || ...
            csPrmArgDef.PassthroughSystemIdx == prmAccessSysIdx
            %%
            %% - not called by a parent system (e.g. enable in start)
            %% - parent has the same pass through system index
            %%
            %assign args = "%<args>%<comma>localP"
            %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
          %else
            %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
            %assign varGroupIdx = ...
              FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
            %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
            %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
              csPrmArgDef.PassthroughSystemIdx, cross)
            %assign indenti = SLibVarGroupName(varGroupIdx)
            %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
          %endif
        %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
          %assign args = "%<args>%<comma>localP"
          %<SLibAccessArgHelper(ParameterArgDef,"",cTID)>
        %else %% normal parameter structure argument
          %assign cast = "(" + FcnSysVarGroupType(thisSystem,"Parameter") + " *)"
          %assign varGroupIdx = ...
            FcnSysVarGroupIndex(thisSystem, "Parameter", callSiteIdx)
          %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
          %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
            accessSysIdx,CrossNoArgFcnBound)
          %assign indenti = SLibVarGroupName(varGroupIdx)
          %assign args = "%<args>%<comma>%<cast> &%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% CState argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesArgDef, cTID, isRG)
      %%
      %% If a system function (eg "Start") calls a function of the 
      %% same system (eg "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args = "%<args>%<comma>rtx"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localX"
        %<SLibAccessArgHelper(ContStatesArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = ...
          FcnSysVarGroupIndex(thisSystem, "ContStates", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
          SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign iisarg = SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
          %assign args = "%<args>%<comma>%<iisarg>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "ContStates")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not use prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% CState Derivative argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesDerivativeArgDef, cTID, isRG)
      %%
      %% If a system function (eg "Start") calls a function of the 
      %% same system (eg "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>rtxdot"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localXdot"
        %<SLibAccessArgHelper(ContStatesDerivativeArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, ...
          "ContStatesDerivative", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
          SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign iisarg = SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
          %assign args = "%<args>%<comma>%<iisarg>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "ContStatesDerivative")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not use prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% CState Disabled argument
    %%
    %if SysFcnArgNeeded(sysFcn, ContStatesDisabledArgDef, cTID, isRG)
      %%
      %% If a system function (eg "Start") calls a function of the 
      %% same system (eg "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>rtxdis"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localXdis"
        %<SLibAccessArgHelper(ContStatesDisabledArgDef,"",cTID)>
      %else
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, ...
          "ContStatesDisabled", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
          SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign iisarg = SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)
          %assign args = "%<args>%<comma>%<iisarg>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "ContStatesDisabled")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not use prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% Non Sampled Zero Crossing argument
    %%
    %if SysFcnArgNeeded(sysFcn, ZCSVArgDef, cTID, isRG)
      %%
      %% If a system function (eg "Start") calls a function of the 
      %% same system (eg "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>rtzcsv"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localZCSV"
        %<SLibAccessArgHelper(ZCSVArgDef,"",cTID)>
      %else
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, ...
          "ZCSV", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
            SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign args = "%<args>%<comma>%<SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "ZCSV")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif 
    %%
    %% ZCEvent argument
    %%
    %if SysFcnArgNeeded(sysFcn, ZCEventArgDef, cTID, isRG) && !isScalableMRSys
      %%
      %% If a system function (eg "Start") calls a function of the 
      %% same system (eg "Enable"), it has to pass the structured arguments
      %% without adding a substructure element
      %%
      %if genModelRef
        %assign args =  "%<args>%<comma>&(dw->rtzce)"
      %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
        %assign args = "%<args>%<comma>localZCE"
        %<SLibAccessArgHelper(ZCEventArgDef,"",cTID)>
      %else
        %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, ...
          "ZCEvent", callSiteIdx)
        %assign parentVarGroupIdx = SLibVarGroupParentIndex(varGroupIdx)
        %assign cross = System[cs[0]].CrossNoArgFcnBound
        %assign identiPath = SLibCGIRVarGroupPath(parentVarGroupIdx, ...
          accessSysIdx, cross)
        %assign indenti = SLibVarGroupName(varGroupIdx)
        %if SLibGetSubsystemIsImplicitIterSS(System[cs[0]]) && ...
            SLibGetImplicitIterSSMaintainingSeparateStates(System[cs[0]])
          %% Implicit Iteration subsystem is set to maintain separate states for
          %% different iteration
          %assign args = "%<args>%<comma>%<SLibGetIndexedDWorkOrBlockIOPathForImplicitIterSS(parentVarGroupIdx, identiPath, indenti, cs, accessSysIdx, sysIdx)>"
        %elseif SLibIsMatrixVarGroupForIIS(sysIdx, "ZCEvent")
          %% If sysIdx is Implicit Iterator subsystem and its varGroup is matrix type, call argument 
          %% should not prepend with &.
          %assign args = "%<args>%<comma>%<identiPath>%<indenti>"
        %else
          %assign args = "%<args>%<comma>&%<identiPath>%<indenti>"
        %endif
      %endif
      %assign comma = ", "
    %endif
    %%
    %% Canonical parameters
    %%
    %foreach argIdx=NumCanonicalPrmArgDefs
      %assign argDef = CanonicalPrmArgDef[argIdx] 
      %if SysFcnArgNeeded(sysFcn, argDef, cTID, isRG)
	%assign prmWidth = LibBlockParameterWidth(argDef)

        %if !genModelRef
	%assign childPrmIdx = ...
	  ssBlk.CallSiteInfo.CanonicalPrmArg[argIdx].ChildPrmArgIdx
        %%
        %assign calledByTestInterface = TLC_FALSE
        %if (ConfigSet.GenerateTestInterfaces) && ...
          ISFIELD(thisSystem, "GenerateReusableWrapper") && ...
          GETFIELD(thisSystem, "GenerateReusableWrapper")
          %% Called by Test interface. Get information about parent Child Prm
          %assign prm = FunctionGetChildPrmArgFromParent(cs, childPrmIdx)
          %assign calledByTestInterface = TLC_TRUE
        %else
          %assign prm = SLibGetCallSitePrmArg(cs, childPrmIdx)
        %endif
        %%
        %endif
        
        %%
	%% If one or more of arguments of a function that is passed by address
	%% is a expression, than the result of this expression has to be stored
	%% in a temporrary variable. The address of the temporary variable will
	%% than be passed as the argument of the function call.
	%%
	%assign ref = ""
	%if genModelRef
	  %% Generating S-Function for model-reference.
	  %% Always generate parameter argument as "ParamArg_#"
	  %assign expr = "ParamArg_%<argIdx>"
          %assign passByValue = (argDef.DeclareAsPointer != "yes")
	  %assign dtId = argDef.OriginalDataTypeIdx
          %assign isStruct = LibIsStructDataType(dtId)
	  %if (prmWidth == 1) && (isStruct==TLC_FALSE)
	    %assign expr = "%<expr>[0]"
	  %endif
        %elseif LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
          %assign expr = LibGetRecordIdentifier(argDef)
          %<SLibAccessArgHelper(argDef,"",cTID)>
	%elseif prmWidth > 1
	  %if LibBlockParameterIsExpression(prm)
	    %assign ref = "&"
	    %if !ISFIELD(ssBlk, "%<sysFcn>FcnCallCode")
	      %addtorecord ssBlk %<sysFcn>FcnCallCode ...
		{ localPrmDecl ""; localExpr ""}
	    %endif
	    %assign dataType = SLibGetRecordDataTypeName(argDef, "")
	    %assign  fcnCode = ssBlk.%<sysFcn>FcnCallCode
            %assign     iden = LibGetRecordIdentifier(argDef)
	    %if !calledByTestInterface
            %% Add parameter declaration if not called by test interface
            %% The canonical parameter identifier is dangerous to reuse so massage it. See g612025.   
              %assign iden_tmp = "%<iden>"
              %assign iden_tmp[2] = "e"
              %assign iden = iden_tmp
              %assign fcnCode.localPrmDecl = fcnCode.localPrmDecl + ...
                "%<dataType> %<iden>[%<prmWidth>];\n"
            %endif  %% ! calledByTestInterface
            %assign expr = "%<iden>[0]"
	    %assign rolledExpr = ""
	    %openfile rolledExpr
	    %roll idx=[0:%<prmWidth-1>],lcv=RollThreshold,ssBlk,"Roller",""
	      %<iden>[%<lcv == "" ? idx : lcv>] = ...
		%<FcnGenParamExprWithCast("", accessSysIdx, cs, prm, lcv, "", idx)>;
	    %endroll
	    
	    %closefile rolledExpr
            %if !calledByTestInterface
              %% Add localExpr if not called by interface
              %assign fcnCode.localExpr = fcnCode.localExpr + rolledExpr
            %endif
	  %elseif prm.ASTNode.IsNonTerminal == 0 && ...
	    prm.ASTNode.Op == "M_CANPRM_ID"
	    %assign ref = "&"
	    %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs, prm, "", "", "")
	  %else
	    %%
	    %% Value is needed by LibBlockParameterAddr as a field
	    %% in the parameter record
	    %%
	    %if !ISFIELD(prm, "Value")
	      %assign prmIdx = prm.ASTNode.ModelParameterIdx
	      %assign value = ModelParameters.Parameter[prmIdx].Value
              %if argDef.Alignment > ModelParameters.Parameter[prmIdx].Alignment
                %assign ModelParameters.Parameter[prmIdx].Alignment = argDef.Alignment
              %endif
	      %addtorecord prm Value value
	    %endif
	    %assign nRows = SIZE(prm.Value, 0)
	    %if nRows == 1
              %assign expr = FcnBlockParameterAddr(prm, "", "", 0, 0, TLC_FALSE)
 	    %else
              %assign expr = ...
                FcnBlockMatrixParameterAddr(prm, "", "", 0, "", "", 0, TLC_FALSE)
	    %endif
	  %endif
	%else
          %assign expr = FcnGenParamExprWithCast("", accessSysIdx, cs, prm, "", "", "")
          %if argDef.DeclareAsPointer == "yes"
            %assign expr = "(%<expr>)"
            %assign ref  = "&"
          %endif
	%endif
	%assign args = "%<args>%<comma>%<ref>%<expr>"
	%assign comma = ", "
      %endif %% SysFcnArgNeeded
    %endforeach %% argIdx=NumCanonicalPrmArgDefs
    %%
    %% Canonical DWork argument
    %% 
    %assign canDWork = FcnGetCanDWorkArgs(sysFcn, sysIdx, ...
      accessSysIdx, callSiteIdx, cTID, isRG)
    %if canDWork != ""
      %assign args = "%<args>%<comma>%<canDWork>"
      %assign comma = ", "
    %endif
    %endif
  %endwith %% thisSystem.Interface
    
  %return args
%endfunction %% FcnGetAdditionalArgs

%% Function: LibIsPassThroughSubsystemCall =====================================
%% Abstract:
%%    The parent has the same pass through system index as the caller.
%%
%function LibIsPassThroughSubsystemCall(sysIdx, accessSysIdx)
  %return ::CompiledModel.System[sysIdx].HStructDeclSystemIdx == accessSysIdx
%endfunction

%% Function: LibGetFcnCallISR ==================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a ISR (interupt service routine) compatible
%%    interface.
%%    This library function should be used to a attach the generated code
%%    of a Simulink function call subsystem to a ISR.
%%
%function LibGetFcnCallISR(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "ISR", "OutputUpdate")
%endfunction

%% Function: LibGetFcnCallFNI ==================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnCallFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "OutputUpdate")
%endfunction

%% Function: LibGetFcnInitializeFNI ============================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnInitializeFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Initialize")
%endfunction

%% Function: LibGetFcnEnableFNI ================================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnEnableFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Enable")
%endfunction

%% Function: LibGetFcnDisableFNI ===============================================
%% Abstract:
%%    For use by inlined S-Functions with function call outputs. Returns a
%%    function call string with a FNI (forced non-inlined) compatible
%%    interface.
%%    
%function LibGetFcnDisableFNI(ssBlock, portEl, tidVal) void
  %return SLibGetFcnEventType(ssBlock, portEl, tidVal, "FNI", "Disable")
%endfunction

%% Function: SLibGenerateISRStubs ==============================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    ISR (interupt service routine) compatible interface.
%%
%function SLibGenerateISRStubs(fcnCallSys) void
  %assign tmpBuffer = ""
  %assign sysFcnPrototype = ""
  
  %if LibIsSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
    %assign NumISRCallSites = ...
      LibGetSystemField(fcnCallSys, "NumISROutputUpdateCallSites")
    %assign     ISRCallSite = ...
      LibGetSystemField(fcnCallSys, "ISROutputUpdateCallSite")
    %openfile tmpBuffer
    %foreach idx=NumISRCallSites  
      %assign  fcnName = ISRCallSite[idx][0]
      %assign   sysIdx = ISRCallSite[idx][1]
      %assign    csIdx = ISRCallSite[idx][2]
      %assign   portEl = ISRCallSite[idx][3]
      %assign   tidVal = ISRCallSite[idx][4]
      %assign callSite = ::CompiledModel.System[sysIdx].CallSites[csIdx]
      %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]
      
      /* 
       * Interrupt service routine (ISR) function call stub 
       * for '%<ssBlock.Name>' 
       */
      void %<fcnName>(void) {
        %if FcnSubsystemIsAsycnTopSS(fcnCallSys)
          %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
        %elseif LibIsSystemField(fcnCallSys,"CallerBlkIdx")
          %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
          %if callerBlkIdx[0] > 0
            %assign sfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
            %<LibBlockExecuteFcnCall(sfcnBlock, portEl)>
          %else
            %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,tSimStruct,portEl,tidVal,0,"OutputUpdate")>
          %endif
        %else
          %<SLibCallFCSS(sysIdx,csIdx,NumSystems-1,tSimStruct,portEl,tidVal,0,"OutputUpdate")>
        %endif
      }
      %assign sysFcnPrototype = sysFcnPrototype + ...
	"%<LibExternInFcnDecls()>void %<fcnName>(void);\n"
    %endforeach
    %closefile tmpBuffer
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
      %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
      %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
      %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
    %endif
  %endif
  
  %return tmpBuffer
%endfunction %% SLibGenerateISRStubs

%% Function: FcnGenerateFNIStubsForFcn =========================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%%
%function FcnGenerateFNIStubsForFcn(fcnCallSys, fcnType) void
  %assign tmpBuffer = ""
  %assign sysFcnPrototype = ""

  %if LibIsSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
    %assign NumFNICallSites = ...
      LibGetSystemField(fcnCallSys, "NumFNI%<fcnType>CallSites")
    %assign     FNICallSite = ...
      LibGetSystemField(fcnCallSys, "FNI%<fcnType>CallSite")
    %openfile tmpBuffer
    %foreach idx=NumFNICallSites
      %assign  fcnName = FNICallSite[idx][0]
      %assign   sysIdx = FNICallSite[idx][1]
      %assign    csIdx = FNICallSite[idx][2]
      %assign   portEl = FNICallSite[idx][3]
      %assign   tidVal = FNICallSite[idx][4]
      %assign  outInfo = ...
        LibGetFcnInfo(fcnCallSys, "OutputUpdate",fcnCallSys.CurrentTID)
      %assign  fcnInfo = ...
        LibGetFcnInfo(fcnCallSys, fcnType, fcnCallSys.CurrentTID)
      %assign  addArgs = ...
        FcnGetAdditionalArgs([], [], fcnType, sysIdx, NumSystems-1, csIdx)
      %assign  addArgs = WHITE_SPACE(addArgs) ? "" : ", %<addArgs>"
      %assign callSite = ::CompiledModel.System[sysIdx].CallSites[csIdx]
      %assign  ssBlock = ::CompiledModel.System[callSite[2]].Block[callSite[3]]
      %assign  argDefs = outInfo.CommonPrms
      %assign   hasRTM = (CodeFormat == "S-Function" || ...
        FcnSysFcnHasRTM(fcnCallSys, fcnType) || FcnSysNeedAddRTMArg(fcnCallSys, fcnType))
      %assign    locSS = RTMGetModelSS()
      %%
      %if !hasRTM
        %if WHITE_SPACE(argDefs)
          %assign argDefs = tSimStructType + " *const " + locSS
        %else
          %assign argDefs = tSimStructType + " *const " + locSS + ", " + argDefs
        %endif
      %endif
      %%
      %% To avoid warnings, use a different name for the
      %% rtModel in the function declaration than in the
      %% function body.
      %%
      %if GenRTModel
        %assign          rtm = " *%<locSS>"
        %assign     lowerrtm = " *rtm"
        %assign lowerArgDefs = FEVAL("strrep", argDefs, rtm, lowerrtm)
      %else
        %assign lowerArgDefs = argDefs
      %endif
      
      /* 
       * Forced non-inlined (FNI) function call stub 
       * for '%<ssBlock.Name>' 
       */
      %% Model Reference must supply boolean return argument to satisfy
      %% fcnCallSys macro
      %assign retArg = "boolean_T"
      %<retArg> %<fcnName>(%<argDefs>) {
	%% Make the smarts for whether or not to call the initialize
	%% function based on state reset here, so the caller (e.g. Stateflow
	%% or rt_EnableSys can be blissfully and generically unaware of it
	%% (at runtime)
	%if fcnType == "OutputUpdate" || ...
	  fcnType == "Output" || fcnType == "Update"
	  %assign systemFcnIsEmpty = ...
	    LibSystemFcnIsEmptyForTID(fcnCallSys, fcnType) 
	%else
	   %assign systemFcnIsEmpty = ...
	    LibSystemFcnIsEmpty(fcnCallSys, fcnType) 
	%endif
	%%
	%assign fcnCode = ""
	%openfile fcnCode
        %assign callerSfcnBlk = ""
        %if LibIsSystemField(fcnCallSys,"CallerBlkIdx")
          %assign callerBlkIdx = LibGetSystemField(fcnCallSys,"CallerBlkIdx")
          %if callerBlkIdx[0] > 0
            %assign callerSfcnBlk = System[callerBlkIdx[0]].Block[callerBlkIdx[2]]
            %assign callerSfcnBlkEl = LibGetSystemField(fcnCallSys,"CallerBlkPortEl")
          %endif
        %endif
        %if IsModelReferenceSimTarget() && (fcnType == "Enable")
          %% The Enable Function must call the Initialize function because
          %% simulation doesn't cache away the Initialize function pointer
          %if !LibSystemFcnIsEmpty(fcnCallSys, "Initialize")
            %if !ISEMPTY(callerSfcnBlk)
              %foreach fcIdx = callerSfcnBlock.NumSFcnSysOutputCallDsts
                %assign blockToCall      = sfcnBlock.SFcnSystemOutputCall[fcIdx].BlockToCall
                %assign sysIdx           = blockToCall[0]
                %assign blkIdx           = blockToCall[1]
                %assign calledBlock      = ::CompiledModel.System[sysIdx].Block[blkIdx]
                %assign initFNI = LibGetFcnInitializeFNI(calledBlock,0,tidVal)
                %if LibSystemCalledByNonInlineSfcn(calledBlock)
                  %<initFNI>(%<locSS>, %<portEl>, %<tidVal>);
                %else
                  %<initFNI>(%<portEl>, %<tidVal>);
                %endif
              %endforeach
            %else
              %assign initFNI = LibGetFcnInitializeFNI(ssBlock,portEl,tidVal)
              %if LibSystemCalledByNonInlineSfcn(fcnCallSys)
                %<initFNI>(%<locSS>, %<portEl>, %<tidVal>);
              %else
                %<initFNI>(%<portEl>, %<tidVal>);
              %endif
            %endif
          %endif
        %endif
	%if !systemFcnIsEmpty && ...
	  (fcnType != "Initialize" || fcnCallSys.TriggerBlkReset)
          %if FcnSubsystemIsAsycnTopSS(fcnCallSys) && fcnType == "OutputUpdate"
            %<SLibDumpOutputUpdateCodeForAsyncTid(fcnCallSys.CurrentTID)>
          %elseif !ISEMPTY(callerSfcnBlk)
            %<SLibBlockExecuteSysFcn(callerSfcnBlk, callerSfcnBlkEl, fcnType)>
          %else
            %<fcnInfo.Name>(%<fcnInfo.CommonArgs>%<addArgs>);
          %endif
	%endif
        %if !hasRTM
          %<SLibUnusedParameter(locSS)>
        %endif
        %<FcnHandlesUnusedTIDArg(fcnCallSys, "Output")>
	%closefile fcnCode
	%<fcnCode>
        return (1);
      }
      %if ISEMPTY(argDefs) 
	%assign argDefs = ""
      %endif
      %assign sysFcnPrototype = sysFcnPrototype + ...
        "%<LibExternInFcnDecls()>%<retArg> %<fcnName>(%<lowerArgDefs>);\n"
    %endforeach
    %closefile tmpBuffer
    %if !SLibGenNonReusableSubsysFcnAsClassMemFcn(::CompiledModel.System[sysIdx])
      %assign fileSysIdx = ::CompiledModel.System[sysIdx].FileNameOwnerIdx
      %assign fileOwner  = ::CompiledModel.System[fileSysIdx]
      %<LibAddToSystemField(fileOwner, "SystemFcnPrototype", sysFcnPrototype)>
    %else
      %% When in generating non-reusable subsystem funcitons as C++ member function mode,
      %% system function prototoype cannot be put in the file owner subsystem, as they will
      %% need to be put into root_model.h
      %<LibAddToSystemField(::CompiledModel.System[sysIdx], "EncapSystemFcnPrototype", sysFcnPrototype)>
    %endif
  %endif
  
  %return tmpBuffer
%endfunction %% end: FcnGenerateFNIStubsForFcn

%% Function: SLibGenerateFNIStubs ==============================================
%% Abstract:
%%    This function is called by SLibGetBodyOutputUpdateFcnCache in
%%    commonbodlib.tlc in order to generate the function call stubs with a
%%    FNI (forced non-inlined) compatible interface.
%%
%function SLibGenerateFNIStubs(fcnCallSys) void
  %openfile tmpBuf
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "OutputUpdate")>\
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Initialize")>\
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Enable")>\
  %<FcnGenerateFNIStubsForFcn(fcnCallSys, "Disable")>\
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% Function: SLibGetFcnEventType ===============================================
%% Abstract:
%%      This function is called by LibGetFcnCallISR and LibGetFcnCallFNI. It
%%      attaches additional information to the system instance recode that is
%%      used to generate to generate the function call stubs.
%%
%function SLibGetFcnEventType(fcnCallDst, portEl, tidVal, fcnCallType, fcnType) void
  %if fcnCallDst.Type == "SubSystem"
    %with fcnCallDst
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %assign        csIdx = fcnCallDst.CallSiteIdx
    %assign   fcnCallSys = ::CompiledModel.System[sysIdx]
    %if ISFIELD(fcnCallSys, "%<fcnType>Fcn")
      %assign      fcnName = fcnCallSys.%<fcnType>Fcn + fcnCallType
      %assign    fieldName = fcnCallType + fcnType + "CallSite"
      %assign numFieldName = "Num" + fcnCallType + fcnType + "CallSites"
      
      %if csIdx > 0 || portEl > 0
        %assign  fcnName = fcnName + "_%<csIdx>_%<portEl>"
      %endif
      
      %assign callSite = [%<fcnName>, %<sysIdx>, %<csIdx>, %<portEl>, %<tidVal>]
      %if !LibIsSystemField(fcnCallSys, numFieldName)
        %assign callSite = Matrix (1,5) [[%<callSite>];]
        %<LibAddToSystem(fcnCallSys, numFieldName, 1)>
        %<LibAddToSystem(fcnCallSys, fieldName, callSite)>
      %else
        %assign  fcnExists = 0
        %assign  numFields = LibGetSystemField(fcnCallSys, numFieldName)
        %assign fieldValue = LibGetSystemField(fcnCallSys, fieldName)
        %foreach idx=numFields
          %if fieldValue[idx][0] == fcnName
            %assign  fcnExists = 1
            %break
          %endif
        %endforeach
        %if !fcnExists
          %<LibAddToSystemField(fcnCallSys, numFieldName, 1)>
          %<LibAddToSystemField(fcnCallSys, fieldName, callSite)>
        %endif
      %endif
      %return fcnName
    %else
      %return ""
    %endif
  %else
    %assert fcnCallDst.Type == "ModelReference"
    
    %% Check that this is being called from the right scope so we can
    %% correctly get the right fcn-call input on the Model block.
    %if !EXISTS(FcnPortIdx)
      %if fcnType == "OutputUpdate"
        %assign tlcFcnName = "LibGetFcnCall%<fcnCallType>"
      %else
        %assign tlcFcnName = "LibGetFcn%<fcnType>%<fcnCallType>"
      %endif
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:SFcnSystemOutputCallOutOfScope", tlcFcnName)>
    %endif
    
    %assign fcnCallInfo = SLibGetModelBlockFcnCallInputInfo(fcnCallDst, FcnPortIdx, fcnType)
    %assign fcnName = ""
    %if !ISEMPTY(fcnCallInfo)
      %assign fcnName = "%<fcnCallInfo.TaskName>_w"
      %assign asyncTID = fcnCallDst.InputPortTIDs[FcnPortIdx]
      %assign groupIndex = fcnCallInfo.FcnCallPortGroupIndex
      %if !ISFIELD(fcnCallDst, "WrapperFcns")
        %addtorecord fcnCallDst WrapperFcns {}
      %endif
      %addtorecord fcnCallDst.WrapperFcns %<fcnType> ...
        {FcnName fcnName; FcnPortIdx FcnPortIdx; AsyncTID asyncTID; ...
        FcnCallPortGroupIndex groupIndex}
    %endif
    %return fcnName
  %endif
%endfunction 

%function SLibGetFcnCallDstTID(dstBlock, dstPort)
  %if dstBlock.Type == "SubSystem"
    %return LibGetSubsystemBlkTID(dstBlock, TLC_TRUE)
  %else
    %assert dstBlock.Type == "ModelReference"
    %with dstBlock
      %if EXISTS("InputPortTIDs")
        %assign tid = InputPortTIDs[dstPort]
      %else
        %assign tid = TID
      %endif
    %endwith
    
    %return tid
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnCall =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system output function. 
%%   Returns a string to either call function-call subsystem output function 
%%   with the appropriate number of arguments or the generate the subsystem output 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnCall(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnCall and LibCallFCSS. 
%%  These two function are also used by inline S-Function with function call output
%%  function. However, LibExecuteFcnCall and LibCallFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnCall works for 
%%  both cases
%% 
%function LibBlockExecuteFcnCall(sfcnBlock, callIdx) void
  %% Get the starting index of corresponding SFcnSystemOutputCall record first
  %% e.g.
  %%   'sfcnBlock' outputs 3 elements
  %%   The 1st element calls 2 function-call destinations: {'AAA', 'BBB'}
  %%   The 2nd element is unconnected: {'unconnected'}
  %%   The 3rd element calls 3 function-call destinations: {'CCC', 'DDD', 'EEE'}
  %%
  %%   Then it has a flat list of 'SFcnSystemOutputCall' records:
  %%   SFcnSystemOutputCall[0] --> 'AAA'
  %%   SFcnSystemOutputCall[1] --> 'BBB'
  %%   SFcnSystemOutputCall[2] --> 'unconnected'
  %%   SFcnSystemOutputCall[3] --> 'CCC'
  %%   SFcnSystemOutputCall[4] --> 'DDD'
  %%   SFcnSystemOutputCall[5] --> 'EEE'
  %%
  %%   The 'SFcnSystemOutputCallMappingInfo' has 3 records, each mapped to one 
  %%   output element of 'sfcnBlock':
  %%   SFcnSystemOutputCallMappingInfo[0].StartingIdx   = 0
  %%   SFcnSystemOutputCallMappingInfo[0].NumOfCalledFC = 2
  %%   SFcnSystemOutputCallMappingInfo[1].StartingIdx   = 2
  %%   SFcnSystemOutputCallMappingInfo[1].NumOfCalledFC = 1
  %%   SFcnSystemOutputCallMappingInfo[2].StartingIdx   = 3
  %%   SFcnSystemOutputCallMappingInfo[2].NumOfCalledFC = 3
  %%
  %%   When passing a 'callIdx' of 2, we should be able to get the starting
  %%   index in the list of 'SFcnSystemOutputCall' records, which is 3.
  %assign recIdx = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx

  %% Using the example shown above, given the starting index of 3, we should
  %% be able to get the first function-call destination block, which is 'CCC'.
  %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
  
  %if LibIsEqual(dstSSBlk, "")
    %return "" %% Do nothing if the function-call signal is not connected
  %endif
  %with sfcnBlock
    %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
    %% Get called block's function-call input port element index
    %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
    %% Get number of called blocks
    %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
    %assign dstBlkTid = SLibGetFcnCallDstTID(dstSSBlk, ...
      SFcnSystemOutputCall[recIdx].FcnPortIdx)
  %endwith
  
  %if FcnBlkIsAsyncTopSfcn(sfcnBlock)
    %% Output element of the S-function block
    %assign sfcnOutputEl   = sfcnBlock.SFcnSystemOutputCall[recIdx].OutputElement
    %assign tidFromSfcnBlk = FcnGetAsyncTidFromSfcnBlk(sfcnBlock, sfcnOutputEl)
          
    %assert LibAsynchronousTriggeredTID(tidFromSfcnBlk)
    %assert LibAsynchronousTriggeredTID(dstBlkTid)

    %openfile codeForAsyncTid
    %if !ISFIELD(sfcnBlock, "GenCodeForTopAsyncSS")
      %addtorecord sfcnBlock GenCodeForTopAsyncSS TLC_FALSE
    %endif
    %if sfcnBlock.GenCodeForTopAsyncSS
      %% Second time parse the async sfcn TLC file.
      %if tidFromSfcnBlk == dstBlkTid
         %% If the sfcn block is the top sfcn of the rate, the sfcn 
         %% will be reponsible to generate task entry fcn. Get the 
         %% code that is rate grouped with the async rate at root level
         %% so that code can be dumped in task entry fcn. 
         {
           %if LibIsDeploymentDiagram()
             %assign ssIdx = sfcnBlock.BlkSysIdx
             %<SLibDumpOutputUpdateCodeForAsyncTidInSS(ssIdx, dstBlkTid)>
           %else
             %<SLibDumpOutputUpdateCodeForAsyncTid(dstBlkTid)>
           %endif
         }
      %else
        %% If the sfcn block is not the tops sfcn of the rate, 
        %% call task entry fcn for the rate. This sfcn block is 
        %% no repsonsible to generate the function body. 
        %% 
        %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
      %endif
    %else     
      %% First time parse the async sfcn TLC file.
      %% Generate code body. The code will be rate grouped
      %% in parent system. 
      %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
    %endif
    %closefile codeForAsyncTid
    %return codeForAsyncTid
  %else
    %openfile retBuf
    %if !ISEQUAL(sfcnBlock.TID, dstBlkTid) && LibAsynchronousTriggeredTID(dstBlkTid)
      %% Destination block has different sample time and it is a union sample time. 
      %% Call the task entry fcn of the union sample time. 
      %%  %assert Sampletime[dstBlkTid].IsUnionTs == "yes"
      %<RTWCGBlockExecuteAsyncEntryFcn(fcInpPortEl, dstBlkTid)>
    %else
      %<SLibExecuteFcnCallGeneralHelper(sfcnBlock, recIdx, nCalledFC, tidVal)>
    %endif
    %closefile retBuf
    %return retBuf
  %endif
%endfunction %% end: LibBlockExecuteFcnCall

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnEnable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system enable function. 
%%   Returns a string to either call function-call subsystem enable function 
%%   with the appropriate number of arguments or the generate the subsystem enable 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnEnable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnEnable and LibEnableFCSS. 
%%  These two function are also used by inline S-Function with function call enable
%%  function. However, LibExecuteFcnEnable and LibEnableFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnEnable works for 
%%  both cases
%% 
%function LibBlockExecuteFcnEnable(sfcnBlock, callIdx)
  %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_TRUE)
%endfunction

%% DocFunction{Other Useful Functions}: LibBlockExecuteFcnDisable =================
%% Abstract:
%%   For use by inlined S-Functions to call fcn-call system disable function. 
%%   Returns a string to either call function-call subsystem disable function 
%%   with the appropriate number of arguments or the generate the subsystem disable 
%%   code right there (inlined).
%%
%% Example:
%%   %foreach callIdx = NumSFcnSysOutputCallDsts
%%       %if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%%          %continue
%%       %endif
%% 	 %% call the downstream system
%%       %<LibBlockExecuteFcnDisable(block, callIdx)>\
%%    %endforeach
%%
%%  Consider using this function to replace LibBlockExecuteFcnDisable and LibDisableFCSS. 
%%  These two function are also used by inline S-Function with function call disable
%%  function. However, LibExecuteFcnDisable and LibDisableFCSS works only if fcn-call 
%%  doesn't branch, can't handle fcn-call branches. LibBlockExecuteFcnDisable works for 
%%  both cases
%% 
%function LibBlockExecuteFcnDisable(sfcnBlock, callIdx)
  %return SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, TLC_FALSE)
%endfunction

%% SLibBlockExecuteFcnEnableDisableHelper ======================================
%% Abstract: 
%%     Helper function for LibBlockExecuteFcnEnable & LibBlockExecuteFcnDisable
%%     When enableFcn == TLC_TRUE, generate enable function; otherwise, generate
%%     disable function.
%function SLibBlockExecuteFcnEnableDisableHelper(sfcnBlock, callIdx, enableFcn)
  %openfile retBuf
  %assign recIdx    = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
  %assign nCalledFC = sfcnBlock.SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
  
  %foreach fcIdx = nCalledFC
    %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
    
    %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
      %with sfcnBlock
        %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
        %assign fcInpPortEl  = SFcnSystemOutputCall[recIdx].FcnPortElement
        %assign fcInpPortIdx = SFcnSystemOutputCall[recIdx].FcnPortIdx
      %endwith
      
      %if enableFcn == TLC_TRUE %% Generate enable function
        %<SLibExecuteFcnEnableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
      %else %% Generate disable function
        %<SLibExecuteFcnDisableHelper(dstSSBlk, fcInpPortEl, fcInpPortIdx, tidVal,TLC_FALSE)>
      %endif
    %endif
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile retBuf
  
  %return retBuf
%endfunction

%function SLibBlockExecuteFcnInit(sfcnBlock, callIdx)
  %with sfcnBlock
    %assign recIdx    = SFcnSystemOutputCallMappingInfo[callIdx].StartingIdx
    %assign nCalledFC = SFcnSystemOutputCallMappingInfo[callIdx].NumOfCalledFC
    %assign tidVal = ParamSettings.SampleTimesToSet[0][1]
    %assign portEl = SFcnSystemOutputCall[recIdx].FcnPortElement
  %endwith
  
  %openfile retBuf
  %foreach fcIdx = nCalledFC
    %assign dstSSBlk = LibGetFcnCallBlock(sfcnBlock, recIdx)
    
    %if !LibIsEqual(dstSSBlk, "") %% Ignore unconnected function-call signal
      %<SLibExecuteFcnInitHelper(dstSSBlk, portEl, tidVal,TLC_FALSE)>
    %endif
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile retBuf
  
  %return retBuf
%endfunction

%function SLibBlockExecuteSysFcn(sfcnBloc, callIdx, fcnType)
  %openfile retBuf
  %switch(fcnType)
    %case "OutputUpdate"
      %<LibBlockExecuteFcnCall(sfcnBloc, callIdx)>
      %break
    %case "Initialize"
      %<SLibBlockExecuteFcnInit(sfcnBloc, callIdx)>
      %break
    %case "Enable"
      %<LibBlockExecuteFcnEnable(sfcnBloc, callIdx)>
      %break
    %case "Disable"
      %<LibBlockExecuteFcnDisable(sfcnBloc, callIdx)>
      %break
    %default
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidFcnType", fcnType)>
      %break
  %endswitch
  %closefile retBuf
  
  %return retBuf
%endfunction


%function SLibReportObsoleteFcnCallAPI(OldFcnName, NewFcnName, system)
  %<SLibReportErrorWithIdAndArgs("RTW:tlc:ObsoleteFcnCall", ...
    ["%<OldFcnName>", "%<system.Name>", "%<NewFcnName>"])>
%endfunction

%function SLibExecuteFcnCallGeneralHelper(sFcnBlock, recStartingIdx, nCalledFC, tidVal) void
  %assign recIdx = recStartingIdx
  %openfile buffer
  %foreach fcIdx = nCalledFC
    %assign blockToCall   = sFcnBlock.SFcnSystemOutputCall[recIdx].BlockToCall
    %assign sysIdx        = blockToCall[0]
    %assign blkIdx        = blockToCall[1]
    %assign calledBlock   = CompiledModel.System[sysIdx].Block[blkIdx]
    %with sFcnBlock
      %% Get called block's function-call input port element index
      %assign fcInpPortEl = SFcnSystemOutputCall[recIdx].FcnPortElement
      %assign fcPortIdx   = SFcnSystemOutputCall[recIdx].FcnPortIdx
      %assign subsysFcnCall = SLibExecuteFcnCallHelper(calledBlock, fcInpPortEl, ...
        fcPortIdx, tidVal, TLC_FALSE)
    %endwith
    %<subsysFcnCall>
    
    %assign recIdx = recIdx + 1 %% Update the record index
  %endforeach
  %closefile buffer
  %return buffer
%endfunction

%function SLibExecuteFcnCallHelper(fcnCallDstBlock, portEl, portIdx, tidVal,checkUsage) void
  %assign isSubsystem = (fcnCallDstBlock.Type == "SubSystem")

  %if isSubsystem
    %with fcnCallDstBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith

    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall","LibBlockExecuteFcnCall",System[sysIdx])>
    %endif
    
    %if checkUsage && FcnSubsystemIsAsycnTopSS(System[sysIdx])
      %assign ssBlkTid = LibGetSubsystemBlkTID(fcnCallDstBlock, TLC_TRUE)
      %assert LibAsynchronousTriggeredTID(ssBlkTid)
      %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(ssBlkTid)
      %if ISEMPTY(topAsyncSfcn)
        %% If the sfcn block is not the tops sfcn of the rate, 
        %% call task entry fcn for the rate. This sfcn block is 
        %% no repsonsible to generate the function body. 
        %% 
        %<RTWCGBlockExecuteAsyncEntryFcn(portEl,ssBlkTid)>
      %else
        %assign el = SampleTime[ssBlkTid].AsyncSfcnBlkElm 
        %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
      %endif
    %else
      %assign        csIdx = fcnCallDstBlock.CallSiteIdx
      %assign           cs = System[sysIdx].CallSites[csIdx]
      %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
      %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
      %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
        tSimStruct, portEl, tidVal, fciCont, "OutputUpdate")
    %endif
  %else
    %assert (fcnCallDstBlock.Type == "ModelReference")
    %if checkUsage && (portIdx == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnCall", ...
        "LibBlockExecuteFcnCall", fcnCallDstBlock)>
    %endif

    %with System[fcnCallDstBlock.BlockIdx[0]]
      %with fcnCallDstBlock
        %return CallModelBlockAsyncFcnCallInput(fcnCallDstBlock, portIdx, tidVal, ...
          "OutputUpdate")
      %endwith
    %endwith
  %endif
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnCall ======================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnCall(ssBlock, portEl, tidVal) void
  %return SLibExecuteFcnCallHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction


%function  SLibExecuteFcnEnableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
  %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")
  
  %if isSubsystem
    %with fcnCallBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable",System[sysIdx])>
    %endif
    
    %assign        csIdx = fcnCallBlock.CallSiteIdx
    %assign           cs = System[sysIdx].CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %with fcnCallBlock
      %assign bType = (Type == "SubSystem") ? "Subsystem" : ""
      %assign swe   = LibBlockParamSetting(bType, "StatesWhenEnabling")
    %endwith  
    
    %if swe == "reset"
      %openfile initBuffer
      %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
        tSimStruct, portEl, tidVal, fciCont, "Initialize")>
      %closefile initBuffer
      %if !WHITE_SPACE(initBuffer)
        %if ProtectCallInitFcnTwice
          /* protect against calling initialize function twice at startup */
          if (!(%<LibIsFirstInitCond()>)) {
            %<initBuffer>\
          }
        %else  
          %<initBuffer>\
        %endif
      %endif
    %endif
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      tSimStruct, portEl, tidVal, fciCont, "Enable")>
    %closefile tmpBuf
    %return tmpBuf
  %else
    %if checkUsage && (fcnPort == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnEnable","LibBlockExecuteFcnEnable", fcnCallBlock)>
    %endif
    %with System[fcnCallBlock.BlockIdx[0]]
      %with fcnCallBlock
        %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Enable")
      %endwith
    %endwith
  %endif
  %return retBuf
%endfunction


%% DocFunction{Other Useful Functions}: LibExecuteFcnEnable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnEnable(ssBlock, portEl, tidVal) void
  %return  SLibExecuteFcnEnableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction

%function SLibExecuteFcnDisableHelper(fcnCallBlock, portEl, fcnPort, tidVal,checkUsage)
  %assign isSubsystem = (fcnCallBlock.Type == "SubSystem")
  
  %if isSubsystem
    %with fcnCallBlock
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
    %endwith
    
    %if checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys")
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",System[sysIdx])>
    %endif
    
    %assign        csIdx = fcnCallBlock.CallSiteIdx
    %assign           cs = System[sysIdx].CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %openfile tmpBuf
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      tSimStruct, portEl, tidVal, fciCont, "Disable")>
    %closefile tmpBuf
    %return tmpBuf
  %else
    %if checkUsage && (fcnPort == -1)
      %<SLibReportObsoleteFcnCallAPI("LibExecuteFcnDisable","LibBlockExecuteFcnDisable",fcnCallBlock)>
    %endif
    %with System[fcnCallBlock.BlockIdx[0]]
      %with fcnCallBlock
        %assign retBuf = CallModelBlockAsyncFcnCallInput(fcnCallBlock, fcnPort, tidVal, "Disable")
      %endwith
    %endwith
  %endif  
  %return retBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibExecuteFcnDisable ===================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%% Example:
%%   %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %<LibExecuteFcnCall(ssBlock, FcnPortElement, ...
%%                             ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%
%function LibExecuteFcnDisable(ssBlock, portEl, tidVal) void
  %return SLibExecuteFcnDisableHelper(ssBlock, portEl, -1, tidVal,TLC_TRUE)
%endfunction


%function SLibExecuteFcnInitHelper(ssBlock, portEl, tidVal,checkUsage)
  %with ssBlock
    %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
    %assign sysIdx = LibBlockParamSetting(bType, "SystemIdx")
  %endwith
  
  %assert !(checkUsage && ISFIELD(System[sysIdx],"IsBranchedSys"))
  
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = System[sysIdx].CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf
  %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
    tSimStruct, portEl, tidVal, fciCont, "Initialize")>
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% DocFunction{Other Useful Functions}: LibCallFCSS ============================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call function-call subsystem with the appropriate number
%%   of arguments or the generate the subsystem's code right there (inlined).
%%
%%   Note:
%%     Used by inlined S-functions to make a function-call, LibCallFCSS
%%     returns the call to the function-call subsystem with the appropriate
%%     number of arguments or the inlined code.  An S-function can execute
%%     a function-call subsystem only via its first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibCallFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global CompiledModel record.
%%  
%function LibCallFCSS(system, simObject, portEl, tidVal) void
  %assign       sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibCallFCSS")>
    %endif
  %endif
  %if ISFIELD(System[sysIdx],"IsBranchedSys")
    %<SLibReportObsoleteFcnCallAPI("LibCallFCSS","LibBlockExecuteFcnCall",system)>
  %endif
  
  %if FcnSubsystemIsAsycnTopSS(system)
    %assign sysTid = LibGetSubsystemTID(system, TLC_TRUE)
    %assert LibAsynchronousTriggeredTID(sysTid)
    %assign topAsyncSfcn =  FcnGetTaskTopSfcnBlock(sysTid)
    %if ISEMPTY(topAsyncSfcn)
      %% If the sfcn block is not the tops sfcn of the rate, 
      %% call task entry fcn for the rate. This sfcn block is 
      %% no repsonsible to generate the function body. 
      %% 
      %return RTWCGBlockExecuteAsyncEntryFcn(portEl,sysTid)
    %else
      %assign el = SampleTime[sysTid].AsyncSfcnBlkElm 
      %return LibBlockExecuteFcnCall(topAsyncSfcn,el)
    %endif
  %else
    %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
    %assign        csIdx = ssBlock.CallSiteIdx
    %assign           cs = system.CallSites[csIdx]
    %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
    %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
    %return SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "OutputUpdate")
  %endif
%endfunction %% LibCallFCSS

%% Function: FcnGenerateOpenFCSSInitialize =====================================
%% Abstract: 
%%     This function generates the opening guard around calling the enable
%%     function for a function-call subsystem.  If setMode is true, we set the
%%     specfied mode to enabled, otherwise we do not set the mode vector.
%%     Currently, since Initialize is called before Enable, Initialize does not
%%     set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSInitialize(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    CondStates enableState = SUBSYS_DISABLED;
    %foreach mIdx = numModes
      %assign blockMode = LibBlockMode("", "", mIdx)
      if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
        enableState = (CondStates) %<blockMode>;
      }
    %endforeach
    if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSInitialize ====================================
%% Abstract: 
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSInitialize(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateOpenFCSSEnable =========================================
%% Abstract: 
%%    This function generates the opening guard around calling the enable
%%    function for a function-call subsystem.  If setMode is true, we set the
%%    specfied mode to enabled, otherwise we do not set the mode vector.
%%    Currently, since Initialize is called before Enable, Initialize does not
%%    set the mode, but Enable does set the mode.
%%
%function FcnGenerateOpenFCSSEnable(ssBlock, portEl) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    {
      CondStates enableState = SUBSYS_DISABLED;
      %foreach mIdx = numModes
        %assign blockMode = LibBlockMode("", "", mIdx)
        if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
          enableState = (CondStates) %<blockMode>;
        }
      %endforeach
      %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
      if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %elseif numModes == 1
    %openfile tmpBuffer
    %<LibBlockMode(portEl, "", "")> = SUBSYS_ENABLED;
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSEnable ========================================
%% Abstract: 
%%    This function generates the closing guard around calling the enable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSEnable(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
      }
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibEnableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the enable method for a function-call subsystem 
%%   or generate the subsystem's enable code inline (as well as initialize 
%%   code if the subsystem resets states on reset).
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its 
%%     first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibEnableFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global CompiledModel record.
%%  
%function LibEnableFCSS(system, simObject, portEl, tidVal) void
  %assign sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibEnableFCSS")>
    %endif
  %endif
  %if ISFIELD(System[sysIdx],"IsBranchedSys")
    %<SLibReportObsoleteFcnCallAPI("LibEnableFCSS","LibBlockExecuteFcnEnable",system)>
  %endif
  %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = system.CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf
  %if ssBlock.ParamSettings.StatesWhenEnabling == "reset"
    %openfile initBuffer
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "Initialize")>
    %closefile initBuffer
    %if !WHITE_SPACE(initBuffer)
      %if ProtectCallInitFcnTwice
	/* protect against calling initialize function twice at startup */
	if (!(%<LibIsFirstInitCond()>)) {
	  %<initBuffer>\
	}
      %else
	%<initBuffer>\
      %endif
    %endif
  %endif
  {
    %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
      simObject, portEl, tidVal, fciCont, "Enable")>
  }
  %closefile tmpBuf
  %return tmpBuf
%endfunction %% LibEnableFCSS


%% Function: FcnGenerateOpenFCSSDisable ========================================
%% Abstract: 
%%    This function generates the opening guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateOpenFCSSDisable(ssBlock, portEl) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
    {
      CondStates enableState = SUBSYS_DISABLED;
      %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
      %foreach mIdx = numModes
        %assign blockMode = LibBlockMode("", "", mIdx)
        if (((CondStates) %<blockMode>) != SUBSYS_DISABLED) {
          enableState = (CondStates) %<blockMode>;
        }
      %endforeach
      if (enableState == SUBSYS_DISABLED) {
    %closefile tmpBuffer
  %elseif numModes == 1
    %openfile tmpBuffer
    %<LibBlockMode(portEl, "", "")> = SUBSYS_DISABLED;
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% Function: FcnGenerateCloseFCSSDisable =======================================
%% Abstract: 
%%    This function generates the closing guard around calling the disable
%%    function for a function-call subsystem.
%%
%function FcnGenerateCloseFCSSDisable(ssBlock) void
  %with ssBlock
  %assign numModes = ModeVector[0]
  %assign tmpBuffer = ""
  %if numModes > 1
    %openfile tmpBuffer
      }
    }
    %closefile tmpBuffer
  %endif
  %endwith
  %return tmpBuffer
%endfunction

%% DocFunction{Other Useful Functions}: LibDisableFCSS =========================
%% Abstract:
%%   For use by inlined S-Functions with function call outputs. Returns a
%%   string to either call the disable method for a function-call subsystem 
%%   or generate the subsystem's disable code inline.
%%
%%   Note:
%%     An S-function can execute a function-call subsystem only via its 
%%     first output port.
%%  
%%     See the SFcnSystemOutputCall record in the model.rtw file.
%%  
%%     The return string is determined by the current code format.
%%  
%%   Example:
%%     %foreach fcnCallIdx = NumSFcnSysOutputCallDsts
%% 	 %% call the downstream system
%% 	 %with SFcnSystemOutputCall[fcnCallIdx]
%% 	   %% skip unconnected function call outputs
%% 	   %if ISEQUAL(BlockToCall, "unconnected")
%% 	     %continue
%% 	   %endif
%% 	   %assign sysIdx = BlockToCall[0]
%% 	   %assign blkIdx = BlockToCall[1]
%% 	   %assign ssBlock = System[sysIdx].Block[blkIdx]
%% 	   %assign sysToCall = System[ssBlock.ParamSettings.SystemIdx]
%% 	   %<LibDisableFCSS(sysToCall, tSimStruct, FcnPortElement, ...
%% 	     ParamSettings.SampleTimesToSet[0][1])>\
%% 	 %endwith
%%     %endforeach
%%  
%%     BlockToCall and FcnPortElement are elements of the SFcnSystemOutputCall
%%     record.
%%  
%%     System is a record within the global CompiledModel record.
%%  
%function LibDisableFCSS(system, simObject, portEl, tidVal) void
  %assign       sysIdx = system.SystemIdx
  %if !EXISTS("BlockToCall")
    %if EXISTS("SFcnSystemOutputCall")
      %assign BlockToCall = SFcnSystemOutputCall[0].BlockToCall
    %else
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:IncorrectLibFcnCall", "LibDisableFCSS")>
    %endif
  %endif
   %if ISFIELD(System[sysIdx],"IsBranchedSys")
     %<SLibReportObsoleteFcnCallAPI("LibDisableFCSS","LibBlockExecuteFcnDisable",system)>
  %endif
  %assign      ssBlock = System[BlockToCall[0]].Block[BlockToCall[1]]
  %assign        csIdx = ssBlock.CallSiteIdx
  %assign           cs = system.CallSites[csIdx]
  %assign accessSysIdx = System[cs[0]].HStructDeclSystemIdx
  %assign      fciCont = SLibIsFcnCallerContinuous(tidVal)
  %openfile tmpBuf 
  %<SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
    simObject, portEl, tidVal, fciCont, "Disable")>
  %closefile tmpBuf
  %return tmpBuf
%endfunction %% LibDisableFCSS

%% Function: SLibIsFcnCallerContinuous =========================================
%% Abstract:
%%    This function determines if calling s-function block has a continous
%%    sample time.
%%
%function SLibIsFcnCallerContinuous (tid)
  %% 
  %assign tidVal = %<tid>
  %if TYPE(tidVal) == "Number" && tidVal >= 0
    %assign fciST = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[0]
    %assign fciOF = ::CompiledModel.SampleTime[tidVal].PeriodAndOffset[1]
    %return (fciST == 0.0 && fciOF == 0.0)
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: SLibCallFCSS ======================================================
%% Abstract:
%%     This function is called by LibCallFCSS and LibExecuteFcnCall
%%     and friends
%%     It either returns the generated code for inlined 
%%     or a function call to a non-inlined fuction call subsystem.
%%    
%%     See LibCallFCSS and LibExecuteFcnCall for further documentation.
%%
%function SLibCallFCSS(sysIdx, csIdx, accessSysIdx, ...
                       simObject, portEl, tidVal, fciCont, callType) void
  %assign      fcnCallSys = ::CompiledModel.System[sysIdx]
  %assign accelGuardStart = ""
  %assign   accelGuardEnd = ""
  
  %assign fcnCallSys.CurrentTID = FcnGetSubsystemCodeBufTID(fcnCallSys)

  %if fciCont && fcnCallSys.RunFcnCallSSInMinorStep == "yes"
    %assign fciCont = 0
    %%
    %% For Simulink accelerator, do not execute function-call subsystem
    %% code when a function-call initiator is continuous (e.g., an async ISR
    %% pseudo source) and we are in the Simulink consistency check stage.
    %%
    %if Accelerator || IsModelReferenceSimTarget()
      %assign accelGuardStart = "if (!%<RTMSolverAssertCheck()>) {"
      %assign accelGuardEnd   = "}"
    %endif
  %endif
  
  %assign inlinedFCSS = LibSystemIsInlined(fcnCallSys)
      
  %% Return nothing if empty
  %if LibSystemFcnIsEmptyForTID(fcnCallSys,callType) 
    %assign fcnCallSys.CurrentTID = -1
    %return ""
  %endif
  %%
  %% 1. S-Function always have SimStruct.
  %% 2. RealTime only has SimStruct if it is forced to be a function call
  %%    (because it has a non-inlined s-function calling it)
  %% 3. Embedded-C never needs SimStruct.
  %%
  %assign argList = []
  %assign numArgs = 0
  %if Accelerator && LibAsynchronousTriggeredTID(tidVal)
    %% Accelerator does not maintain timing information for 
    %% asynchronous tasks, asynchronous task should use 
    %% base rate timing information. See g313672
    %assign tidVal = 0
  %endif
  %if (inlinedFCSS)
    %%
    %if FcnSysNeedAddRTMArg(fcnCallSys, callType)
      %if RTMGetModelSS() != simObject
	%assign argList = argList + ...
	  "%<tSimStructType> *const %<RTMGetModelSS()> = %<simObject>"
	%assign numArgs = numArgs + 1
      %endif
    %endif
    %if LibSystemFcnNeedsCPI(fcnCallSys,callType)
      %assign argList = argList + "int_T %<tControlPortIdx> = %<portEl>"
      %assign numArgs = numArgs + 1
    %endif	   
    %if LibSystemFcnNeedsTID(fcnCallSys,callType)
      %assign argList = argList + "int_T %<tTID> = %<tidVal>"
      %assign numArgs = numArgs + 1
    %endif
  %else
    %% Non-inlined FCSS
     %if FcnSysNeedAddRTMArg(fcnCallSys, callType)
      %assign argList = argList + "%<simObject>"
      %assign numArgs = numArgs + 1
    %endif
    %if LibSystemFcnNeedsCPI(fcnCallSys, callType)
      %assign argList = argList + "%<portEl>"
      %assign numArgs = numArgs + 1
    %endif
    %if LibSystemFcnNeedsTID(fcnCallSys, callType)
      %assign argList = argList + "%<tidVal>"
      %assign numArgs = numArgs + 1
    %endif
  %endif
  %%
  %assign fcnInfo = LibGetFcnInfo(fcnCallSys, callType, fcnCallSys.CurrentTID)
  %openfile callBuffer
  %if inlinedFCSS
    %assign needBrace = (numArgs > 0) 
    %if (needBrace > 0)
      {
    %endif
    %if (numArgs > 0)
      %foreach argIdx = numArgs
	%<argList[argIdx]>;
      %endforeach
    %endif
    %assign fcnCache = "SLibGetBody%<callType>FcnCache"
    %assign fcnCacheBuf = %<fcnCache>(fcnCallSys)
    %if fciCont
      if (%<RTMIs("MajorTimeStep")>) {
      %<fcnCacheBuf>
      }
    %else
      %<accelGuardStart>
      %<fcnCacheBuf>
      %<accelGuardEnd>
    %endif
    %if (needBrace > 0)
      }
    %endif
  %else
    %% Dump the args array to a string
    %assign args = "()"
    %if !ISEMPTY(fcnInfo.Params) 
      %assign args = ""
      %if (numArgs > 0)
	%foreach argIdx = numArgs - 1
	  %assign args = args + "%<argList[argIdx]>" + ", "
	%endforeach
	%assign args = args + "%<argList[numArgs - 1]>"
      %endif
      %assign addArgs = ...
        FcnGetAdditionalArgs([], [], callType, sysIdx, accessSysIdx, csIdx)
      %assign comma = (WHITE_SPACE(addArgs) || WHITE_SPACE(args)) ? "" : ", "
      %assign  args = "(%<args>%<comma>%<addArgs>)"
      %% indes here
    %endif
    %assign fcnCallSysFcn = fcnInfo.Name
    %if fciCont
      if (%<RTMIs("MajorTimeStep")>) {
      %<fcnCallSysFcn>%<args>;
      }
    %else
      %<accelGuardStart>
      %<fcnCallSysFcn>%<args>;
      %<accelGuardEnd>
    %endif
  %endif %% inlinedFCSS
  %closefile callBuffer
  %assign fcnCallSys.CurrentTID = -1
  %if !WHITE_SPACE(callBuffer)
    %return callBuffer
  %else
    %return ""
  %endif    
%endfunction %% SLibCallFCSS

%<LibAddToCompiledModel("LibTID01Eq_Seen", 0)>
%% Function: LibTID01Eq ========================================================
%% Abstract:
%%      Return 1 if TID 0 and 1 are equivalent tasks, otherwise return 0.
%%
%% 	Note:  This function is left for backward compatibility only.  Use
%% 	       CompiledModel.FixedStepOpts.TID01EQ instead of this
%% 	       function.  This function may produce incorrect results due
%% 	       to round-off errors.
%%
%function LibTID01Eq() void
  %if !LibTID01Eq_Seen
    %assign ::CompiledModel.LibTID01Eq_Seen = 1
    %<SLibReportWarningWithId("RTW:tlc:DetectLibTID01Eq")>
  %endif
  %if NumSynchronousSampleTimes > 1
    %assign periodTID0 = SampleTime[0].PeriodAndOffset[0]
    %assign periodTID1 = SampleTime[1].PeriodAndOffset[0]
    %assign stepSize = FixedStepOpts.FixedStep
    %if periodTID0 == 0.0 && (stepSize == periodTID1)
      %return 1
    %endif
  %endif
  %return 0
%endfunction

%with ::CompiledModel
%assign RootSystemTasks = []
%foreach tidIdx = NumSynchronousSampleTimes
  %assign RootSystemTasks = RootSystemTasks + tidIdx
%endforeach
%assign ::CompiledModel = ::CompiledModel + RootSystemTasks
%endwith

%% Function: LibSystemTasks ====================================================
%% Abstract:
%%   LibSystemTasks returns a vector containing the subsystem's TIDs.
%%
%%   Note, for convenience, the model tasks are group in a vector named
%%   RootSystemTasks and attached to CompiledModel
%%
%function LibSystemTasks(system) void
  %if system.Type == "root"
    %return ::CompiledModel.RootSystemTasks
  %endif
  %assign sysIdx  = system.CallSites[0][2]
  %assign blkIdx  = system.CallSites[0][3]
  %assign ssBlock = ::CompiledModel.System[sysIdx].Block[blkIdx]
  %if TYPE(ssBlock.SubsystemTID) == "Vector"
    %return ssBlock.SubsystemTID
  %else
    %return [%<ssBlock.SubsystemTID>]
  %endif
%endfunction

%% Function: LibTasksEqual =====================================================
%% Abstract:
%%   Determine if all specified tasks are equal (i.e. have the same TID)
%%
%%   Arguments:
%%      taskVector: Vector of TIDs
%%
%%
%function LibTasksEqual(taskVector) void
  %assign task = taskVector[0]
  %foreach idx = SIZE(taskVector, 1) - 1
    %if !ISEQUAL(taskVector[idx+1], task)
      %return 0
    %endif
  %endforeach
  %return 1
%endfunction

%% Function: LibIsSingleRateSystem ============================================
%% Abstract:
%%   LibIsSingleRateSystem returns one if the system is a single rate
%%   system, and zero otherwise.
%%   
%%   The system paramsetting for single rate is used to determine result.
%%
%%
%function LibIsSingleRateSystem(system) void
  %if system.Type == "root"
    %assign sr = ::CompiledModel.SingleRate
  %else
    %assign sysIdx = system.CallSites[0][2]
    %assign blkIdx = system.CallSites[0][3]
    %with System[sysIdx].Block[blkIdx]
      %assign bType  = (Type == "SubSystem") ? "Subsystem" : ""
      %assign sr     = LibBlockParamSetting(bType, "SingleRate")
    %endwith    
  %endif
  %if sr == "yes"
    %return 1
  %else
    %return 0
  %endif
%endfunction

%% Function: LibIsRateTransitionBlock ==========================================
%% Abstract:
%%   	LibIsRateTransitionBlock returns one if a block is being used as a rate
%%	transition and zero otherwise. The build-in unit delay and zoh
%%      block can be rate transition blocks. S-function blocks can also
%%      be rate transition blocks if they specify the SS_OPTION to do so.
%%
%function LibIsRateTransitionBlock(system, block)
  %if !LibIsSingleRateSystem(system) && SIZE(TID,1) == 1 && ...
    EXISTS("SampleTimeIdx")
    %if (TID != SampleTimeIdx)
      %return 1
    %endif
  %endif
  %return 0
%endfunction


%% Function: FcnERTsSampleHit ==================================================
%% Abstract
%%   Called by LibIsSampleHit for ERT code format.  Not to be call directly.
%%
%function FcnERTIsSampleHit(tid) void
  %if !SLibSingleTasking()
    %% Multitasking
    %if Tid01Eq && ISEQUAL(tid,1)
      %if NumContStates > 0 || IsModelReferenceTarget()
        %if SLibIsRateGrouping()
          %return "%<RTMIs("MajorTimeStep")>"
        %else
          %return "%<RTMIs("MajorTimeStep")> && \n" + "%<LibTID()> == 0"
        %endif
      %else
        %if SLibIsRateGrouping()
          %return "1"
        %else
          %return "%<LibTID()> == 0"
        %endif
      %endif
    %else
      %return "%<LibTID()> == %<tid>"
    %endif
  %elseif ISEQUAL(tid,0)
    %% Singletasking and tid==0; base rate always runs
    %return "1"
  %elseif IsModelReferenceTarget()
    %assert ::CompiledModel.NumSynchronousSampleTimes > 1
    %assert TYPE(tid) == "Number" && tid > 0
    %assign ans = ""
    %if Tid01Eq && ISEQUAL(tid,1)
      %assert LibIsContinuous(0)
      %assign ans = "%<RTMIs("MajorTimeStep")>"
    %else
      %if LibIsContinuous(0)
        %assign ans = "%<RTMIs("MajorTimeStep")> && "
      %endif
      %assign ans = "%<ans>%<RTMIsSampleHit(tid)>"
    %endif
    %return ans
  %elseif NumContStates > 0
    %% Singletasking, need MajorStepGuard + task counter
    %if RTMTaskCountersIsReqFcn()
      %assign taskCountStr = RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + " == 0"
      %return "%<RTMIs("MajorTimeStep")> &&\n" + "%<taskCountStr>"
    %else
      %return "%<RTMIs("MajorTimeStep")>"
    %endif
  %elseif Tid01Eq && ISEQUAL(tid,1)
    %return "1"
  %else
    %% Otherwise
    %if RTMTaskCountersIsReqFcn()
      %return RTMGet("TaskCounters") + "." + ...
        SLibERTMultiRateCounterField(tid) + ...
        " == 0"
    %else
      %return "1"
    %endif
  %endif
%endfunction

%% Function: LibIsSampleHit ====================================================
%% Abstract:
%%   LibIsSampleHit returns the appropriate TID scope given that the tid is
%%   
%%   Discrete:   ssIsSampleHit(S, %<tid>, tid)
%%   Continuous: ssIsContinuousTask(S, tid)
%%   
%%   This function cannot be called with a TID that is neither
%%   discrete nor continuous.
%%   
%%   S-function blocks should not use this function directly. They should 
%%   instead use LibIsSFcnSampleHit().
%%
%%   Arguments:
%%      tid: Global integer task identifier (TID) of block
%%       or
%%      tid: String indicating that you are accessing discrete tasks
%%           using an indexing array.  This form is useful when looping
%%           over the sample times.  String indexing for ERT code format
%%           is supplied for backwards compatibility, however, results
%%           in inefficient code.
%%
%%   Returns:
%%      Non-ERT code formats:
%%
%%	One of the following sample hit macros:
%%
%%      rtmIsSampleHit(S, %<tid>, tid)  for a discrete TID
%%      rtmIsContinuousTask(S, tid)     for a continuous TID
%%
%%      ERT code format:
%%
%%      Appropriate tid check (e.g., tid == 0)
%%
%%
%function LibIsSampleHit(tid) void
  %% See Also:
  %%      LibIsSFcnSampleHit
  %%
  %if LibAsynchronousTriggeredTID(tid) && GenRTModel
    %% Generated code allways rate group async task 
    %% code. LibIsSampleHit(asyncTid) is not neccessary 
    %% for async code. It always returns true
    %return "1"
  %endif
  %if TYPE(tid) == "String"
    %if LibTriggeredTID(tid) || tid == "constant"
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:InvalidTID", tid)>
    %endif
    %if SLibIsERTCodeFormat()
      %return FcnERTIsSampleHit(tid)
    %else
      %return RTMIsSampleHit(tid)
    %endif
  %else
    %if SLibIsERTCodeFormat()
      %return FcnERTIsSampleHit(tid)
    %endif
    %assign period = ::CompiledModel.SampleTime[tid].PeriodAndOffset[0]
    %assign offset = ::CompiledModel.SampleTime[tid].PeriodAndOffset[1]
    %if period == 0.0 && offset == 0.0
      %return RTMIsContinuousTask()
    %else
      %return RTMIsSampleHit(tid)
    %endif
  %endif
%endfunction %% LibIsSampleHit


%% Function: LibIsSpecialSampleHit =============================================
%% Abstract:
%%   LibIsSpecialSampleHit returns the appropriate special sample hit macro.
%%   
%%   S-function blocks should not use this function directly. They should
%%   instead use LibIsSFcnSpecialSampleHit().
%%   (See the Simulink Coder documentation for more
%%   information about multi-tasking models.)
%%
%%   Arguments:
%%      sti: Sample time index of block (only relevant for Zero-Order Hold and
%%           Unit Delay blocks). The sample time index is the index of the
%%           slower sample time.
%%      tid: task identifier (TID) of block.  The TID is the index of the task
%%           with the faster sample time.
%%
%%   Returns:
%%	Non-ERT: rtmIsSpecialSampleHit(rtM,a,b,tid)
%%      ERT    : Appropriate rate interaction flag
%%
%function LibIsSpecialSampleHit(sti, tid) void
  %% See Also:
  %%      LibIsSFcnSpecialSampleHit
  %%
  %if SLibIsERTCodeFormat()
    %if SLibSingleTasking()
      %assign ::CompiledModel.RequireMultiRateSampleHits = 1
      %return LibIsSampleHit(%<sti>)
    %else
      %<SLibSetNeedRateInteraction(sti,tid)>
      %if IsModelReferenceTarget()
        %assign returnVal =  RTMIsSpecialSampleHit(%<sti>, %<tid>)
      %elseif SuppressMultiTaskScheduler
        %if SLibConcurrentTasks()
          %assign returnVal = ...
            "(%<RTMGet("PerTaskSampleHits") + "." + ...
            SLibERTMultiRateTimingField(sti,tid)> == 0)"
        %else
          %assign returnVal = ...
            "(%<RTMGet("PerTaskSampleHits") + "." + ...
            SLibERTMultiRateTimingField(sti,tid)> == 1)"
        %endif
        %% Base system update need maintain SpecialSampleHit flags
        %assign baseSystem =  System[GetBaseSystemIdx()]
        %<SLibAccessThisSysFcnArgHelper(baseSystem.Interface.RTMArgDef,"Update","",tid)>
      %else
        %assign returnVal = ...
          "%<RTMGet("PerTaskSampleHits") + "." + ...
          SLibERTMultiRateTimingField(sti,tid)>"
      %endif
      %if (NumContStates > 0) && ISEQUAL(%<tid>, 0)
        %assign returnVal = "%<RTMIs("MajorTimeStep")>" + " && " + returnVal
      %endif
      %return returnVal
    %endif
  %else
    %return RTMIsSpecialSampleHit(%<sti>, %<tid>)
  %endif
%endfunction

%<LibAddToCompiledModel("BlockInstanceDataCache", 0)>
%% Function: LibGenerateBlockInstanceData ======================================
%% Abstract:
%%   LibCacheBlockInstanceData generates the data allocation code for
%%   each block in a Simulink system.  This function updates
%%   the global variable, CompiledModel.BlockInstanceDataCache.
%%
%function LibCacheBlockInstanceData() void
  %assign rootSystem = System[NumSystems-1]
  %openfile buffer
  %with rootSystem
    %foreach blkIdx = NumBlocks
      %openfile tmpBuffer
      %<GENERATE(Block[blkIdx], "BlockInstanceData", rootSystem)>\
      %closefile tmpBuffer
      %if WHITE_SPACE(tmpBuffer) == 0
        {
          %<tmpBuffer>\
        }
      %endif
    %endforeach
  %endwith
  %closefile buffer
  %assign ::CompiledModel.BlockInstanceDataCache = buffer
%endfunction

%% Function: LibBlockInstanceDataIsEmpty =======================================
%% Abstract:
%%   LibBlockInstanceDataIsEmpty determines if there is any block instance
%%   data for this model.  It returns one if the cache is only white space
%%   and zero otherwise.
%% 
%%   Returns:
%%	1 if CompiledModel.BlockInstanceDataCache is only white space
%%      0 otherwise
%%
%function LibBlockInstanceDataIsEmpty() void
  %<LibTrapCacheAssert(BlockInstanceDataCache)>
  %return WHITE_SPACE(BlockInstanceDataCache)
%endfunction

%% Function: LibDumpBlockInstanceData =========================================
%% Abstract:
%%   LibDumpBlockInstanceData outputs the current block instance data
%%   cache to the output buffer.  The data cache that is output is
%%   stored in CompiledModel.BlockInstanceDataCache.
%%
%function LibDumpBlockInstanceData() Output
  %<LibTrapCacheAssert(BlockInstanceDataCache)>
  %if !WHITE_SPACE(BlockInstanceDataCache)
    
    /* block instance data */
    %<BlockInstanceDataCache>
  %endif
  %<SLibResetTLCGlobal("BlockInstanceDataCache")>\
%endfunction


%%------------------------------%
%% End of function library code %
%%------------------------------%

%% Function: SLibSetSkipInitializationFlag =====================================
%% Abstract:
%%   Low level function used by discrete integrator and unit-delay block to
%%   avoid re-initializing memory to zero.  This function is called in
%%   BlockInstanceSetup.  When the parameter is scalar, initialization
%%   requirements are determined up front (once).  If there is no initial
%%   value parameter, call this function with [] for the param.
%%
%function SLibSetSkipInitializationFlag(system,block,param) void
  %if ISEMPTY(param)
    %<SETFIELD(block, "SkipInitialization", ...
      !SLibXBInitRequired(system,block,[],"","",0))>
  %else
    %if system.StatesCanReset == "no" && !FcnParamInitRequired(param, -1)
      %<SETFIELD(block,"SkipInitialization",1)>
    %else
      %<SETFIELD(block,"SkipInitialization",0)>
    %endif
  %endif
%endfunction


%% Function: SLibXBInitRequired ================================================
%% Abstract:
%%   Whenever possible, avoid re-initializing the states and block outputs to
%%   zero since they are initialized to zero in the model's registration
%%   function.  Initialization is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) The code is located inside the system's initialize function (the
%%      states must re-initialize whenever the system enables).
%%   3) Initial condition (IC) value is not zero or not empty
%%
%%   This check will not be necessary when state and block outputs
%%   initialization is changed from run-time to static initialization.
%%
%% Note:
%%	Always returns true if the parameter is complex or the code format
%%      is other than Embedded-C.
%%
%%
%%   Arguments:
%% 	system: Reference to a Simulink system
%% 	block:  Reference to a block
%% 	param:  Parameter (If there is no initial value parameter, call 
%%              this function with [] for the param)
%% 	ucv:    User control variable string
%% 	lcv:    Loop control variable string
%% 	idx:    Index into parameter vector
%%
%%   Returns:
%%	1 if initialization of states and block outputs is required
%%      0 otherwise
%%
%%
%function SLibXBInitRequired(system, block, param, ucv, lcv, idx) void 

  %if system.StatesCanReset == "yes"
    %return 1
  %else
    %return !ISEMPTY(param) && SLibParamInitRequired(param,ucv,lcv,idx)
  %endif

%endfunction


%% Function: SLibParamInitRequired =============================================
%% Abstract:
%%   Whenever possible, avoid re-initializing parameters to zero since they
%%   are initialized to zero in the model's registration function.
%%   Parameter initialization (on it's own without enable and reset
%%   considerations) is necessary in the following cases:
%%
%%   1) The code will roll (to avoid an empty for-loop).
%%   2) Initial condition (IC) value is not zero.
%%
%% Note:
%%   Always returns true if the parameter is complex or the code format
%%   is other than Embedded-C.
%%
%%   Arguments:
%% 	param:  Parameter
%% 	ucv:    User control variable string
%% 	lcv:    Loop control variable string
%% 	idx:    Index into parameter vector
%%
%%   Returns:
%%	1 if initialization is required
%%      0 otherwise
%%
%%
%function SLibParamInitRequired(param, ucv, lcv, idx) void 

  %assign nRows = SIZE(param.Value,0)
  %assign nCols = SIZE(param.Value,1)
  %assign width = nRows * nCols

  %% If we are initializing any of the elements in the array (checked by SkipInitialization)
  %% then we need to initialize all of the elements if rolling.
  %% Otherwise, check this element to see if it needs to be initialized.
  %if (width > 1 && (ucv != "" || lcv != ""))
    %return 1
  %else
    %return FcnParamInitRequired(param, idx)
  %endif
%endfunction


%% Function: FcnParamInitRequired =============================================
%% Abstract:
%%   Helper function; use idx == -1 to check all the elements
%%
%function FcnParamInitRequired(param, idx) void 

  %assign nRows = SIZE(param.Value,0)
  %assign nCols = SIZE(param.Value,1)
  %assign width = nRows * nCols

  %if !SLibIsERTTarget()
    %return 1
  %endif
  
  %assign ASTNode = param.ASTNode

  %switch (ASTNode.Op)
    %case "SL_INLINED"
    %case "SL_CALCULATED"
      %% if the parameter is inlined or calculated, it is a candidate for
      %% the optimization
      %assign complex = SLibGetASTNodeIsComplex(ASTNode)

      %if complex
        %return 1
      %endif

      %assign dtype   = SLibGetASTNodeDataTypeId(ASTNode)
      %% Can use param.Value in following line
      %% since param.Value == ModelParameter.Value
      %if TYPE(idx) == "Number" && idx == -1
	%foreach idx2 = width
	  %assign icValue = SLibParameterValue(param.Value, dtype, complex, 0, idx2)
	  %if !ISEQUAL(icValue,0)
	    %return 1
	  %endif
	%endforeach
      %else
	%assign icValue = SLibParameterValue(param.Value, dtype, complex, 0, idx)

	%if !ISEQUAL(icValue,0)
	  %return 1
	%endif
      %endif

      %break

    %default
      %% if the parameter is tunable or not inlined, don't optimize away 
      %% initialization
        %return 1
      %break
  %endswitch

  %return 0
%endfunction


%% =============================================================================
%% Enable subsystems use the ssIsFirstInitCond macro to determine time zero.
%% In order to optionally generate the boolean in the ERT real-time object,
%% we track the usage of this macro with LibIsFirstInitCond().
%%

%<LibAddToCompiledModel("IsFirstInitCondMacroUsed", 0)>
%% Function: SLibGetIsFirstInitCondAccessed ===================================
%% Abstract:
%%   SLibGetIsFirstInitCondAccessed returns the value of the global flag
%%   CompiledModel.IsFirstInitCondMacroUsed.
%%
%function SLibGetIsFirstInitCondAccessed() void
  %return IsFirstInitCondMacroUsed
%endfunction


%% Function: SLibIsFirstInitCond ==============================================
%% Abstract:
%%   Implements LibIsFirstInitCond. This bypasses the ExportFunctionsMode
%%   check. This bypass is generally not safe except to implement enabling
%%   semantics.  The following 'positive' case is safe if the call is made 
%%   during the Initialize (or Start, although superfluous) function since
%%   the initCondFlag is still maintained properly in the model Initialize 
%%   (and Start) functions when ExportFunctionsMode==1:
%%     if(%<LibIsFirstInitCond>) { ... }
%%   The following 'negative' case is safe only if guarded by:
%%     %if ProtectCallInitFcnTwice
%%        if(!%<LibIsFirstInitCond) {...}
%%     %endif
%%
%function SLibIsFirstInitCond() void
  %assign ::CompiledModel.IsFirstInitCondMacroUsed = 1
  %return RTMIs("FirstInitCond")
%endfunction

%% DocFunction{Other Useful Functions}: LibIsFirstInitCond =====================
%% Abstract:
%%   LibIsFirstInitCond returns generated code intended for placement in
%%   the initialization function.  This code determines, during run-time,
%%   whether the initialization function is being called for the first time.
%%
%%   This function also sets a flag to determine if the first-initialize-condition
%%   flag is needed.
%%
%%   This function is the TLC version of the SimStruct macro: ssIsFirstInitCond
%%
%function LibIsFirstInitCond() void
  %if ExportFunctionsMode == 1
    %<SLibReportErrorWithId("RTW:tlc:FirstInitInExpFcn")>
  %endif
  %return SLibIsFirstInitCond()
%endfunction




%% Function: SLibCallerHStuctDeclSystem =======================================
%% Abstract:
%%     return root or callers' HStructDeclSystem (caller's reused parent)
%%
%function SLibCallerHStuctDeclSystem(system, callSiteIdx) void

  %assign parentIdx = system.CallSites[callSiteIdx][0]
  %assign rSysIdx   = ::CompiledModel.System[parentIdx].HStructDeclSystemIdx
  %assign parent    = ::CompiledModel.System[rSysIdx]
  
  %return parent
  
%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibCallerReusedParentSystem ====================================
%% Abstract:
%%     return root or callers' ReusedParentSystemIdx
%%
%function SLibCallerReusedParentSystem(system, callSiteIdx) void

  %assign parentIdx = system.CallSites[callSiteIdx][0]
  %assign rSysIdx   = ::CompiledModel.System[parentIdx].ReusedParentSystemIdx
  
  %return ::CompiledModel.System[rSysIdx]
  
%endfunction %% SLibCallerHStuctDeclSystem

%% Function: SLibResetNextVHTDueToEnable ======================================
%% Abstract:
%%   This method is called by a block's private enable method to properly 
%%   handle variable sample time inside an enabled subsystem.
%%   The subsystem will be calling BdSystemOutput before the sampleHit 
%%   vector is updated so we need to set the block's entry to true to 
%%   make sure it gets to run its output function in the next opportunity
%%
%function SLibResetNextVHTDueToEnable(block) void
  %assign tid = block.VarTsTID
  %assign idx = CAST("Number",::CompiledModel.SampleTime[tid].PeriodAndOffset[1])
  %openfile buffer
  /* Force a sample hit at this major time step */
  %<RTMGet("SampleHitPtr")>[%<tid>] = true; 
  %<RTMuSetIdxed("TaskTime", tid, LibGetT())>;
  %<RTMuSetIdxed("VarNextHitTime", "%<idx>", LibGetT())>;
  %closefile buffer
  %return buffer
%endfunction %% SLibResetNextVHTDueToEnable

%% Function: SLibFcnComputeInput ===============================================
%% Abstract:
%%    This function is used by blocks that conditionally need their inputs, 
%%    e.g., switch block. This function generates output code for the 
%%    conditionally executed subsystem driving the specified input.
%%
%function SLibFcnComputeInput(block, portIdx) Output
  %assign sysToCall   = SLibBlockSystemToCallForInput(portIdx)
  %assign sysIdx      = sysToCall[0]
  %assign callSiteIdx = sysToCall[1]
  %if sysIdx >= 0
    %assign ss = ::CompiledModel.System[sysIdx]
    %if !LibSystemFcnIsEmpty(ss, "Output")
      %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
    %endif
  %endif
%endfunction %%SLibFcnComputeInput

%% Function: SLibFcnComputeOutput ===============================================
%% Abstract:
%%    This function is used by blocks that conditionally call their outputs, 
%%    This function generates output code for the conditionally executed 
%%    subsystem driven by the specified output port.
%%
%function SLibFcnComputeOutput(block, portIdx) Output
  %assign sysToCall   = SLibBlockSystemToCallForOutput(portIdx)
  %assign sysIdx      = sysToCall[0]
  %assign callSiteIdx = sysToCall[1]
  %if sysIdx >= 0
    %assign ss = ::CompiledModel.System[sysIdx]
    %if !LibSystemFcnIsEmpty(ss, "Output")
      %<LibGenSystemFcnCall(ss, "Output", callSiteIdx)>\
    %endif
  %endif
%endfunction %%SLibFcnComputeOutput

%% Function: SLibZeroOutDerivativesForSystem ===================================
%% Abstract: 
%%   This function will geenrate the code to zero out the derivatives
%%   in a conditionally executed subsystem. Note it is
%%   the callers responsibility to declare the loop index i and 
%%   the double pointer dx.
%function SLibZeroOutDerivativesForSystem(ssBlock,system) Output

%%  %assign idx = system.Interface.ContStatesArgDef.FirstLocation
  %with  ssBlock
    %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
  %endwith
  %assign ncStates = cStates[0]
  %if (ncStates == 0) 
    %return 
  %endif  
  %assign idx = cStates[1]
  %assign cs = ::CompiledModel.ContStates.ContState[idx]
  %assign blkIdx = cs.SigSrc[2]
  %assign isMdlRef = FcnOwnerBlkType(cs) == "ModelReference"
  %assign varGroupIdx = cs.VarGroupIdx[2]
  %assign cross = system.CrossNoArgFcnBound  
  %assign blockPath = SLibCGIRVarGroupPath( ...
    varGroupIdx, system.HStructDeclSystemIdx, cross)

  %% Cstates for model reference block is stored in a structure
  %assign dxId = "%<blockPath>%<cs.Identifier>"
  
  %if ncStates > 1
    %if isMdlRef
      dx = (real_T *) &(%<dxId>);
    %elseif  cs.Width >1 
      dx = &(%<dxId>[0]);
    %else 
      dx = &(%<dxId>);
    %endif
    %assign dxZeroUpperLimitPlus1 = ncStates
    for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
    dx[i] = 0.0;
    }
  %else
    %if  isMdlRef
      {
	real_T *dx = (real_T *) &(%<dxId>);
	(*dx) = 0.0;
      }
    %else
      %<dxId> = 0.0;
    %endif
  %endif
%endfunction

%% Function: SLibZeroOutZcSignalsForSystem ================================
%% Abstract: 
%%   This function will generate the code to zero out the zcSignals 
%%   in a conditionally executed subsystem. 
%% for adzc
%function SLibZeroOutZcSignalsForSystem(ssBlock,system) Output
  %with  ssBlock
    %assign nNSZC = LibBlockParamSetting("Subsystem", "NumNonsampledZCs")
  %endwith
  %if (nNSZC == 0)
    %return
  %endif
  
  %assert(SolverType == "VariableStep")
  %% This is not done before and happend to be ok becuase the zcsWith
  %% of modelref zcSignal is always 1. even so, the pointer is not casted.
  %% Need to handle model reference block (see 
  %%   SLibZeroOutDerivativesForSystem function)
  %assert(!IsModelReferenceTarget())
  
  %with  ssBlock
    %assign idx  =  LibBlockParamSetting("Subsystem", "BlkZcRecOffset")
    %assign nZCs =  LibBlockParamSetting("Subsystem", "NumZcSignalEls")
  %endwith
  
  %assign blkZcRec = ::CompiledModel.ZcRec.BlkZcRec[idx]
  %assign isMdlRef = FcnOwnerBlkType(blkZcRec) == "ModelReference"
  %assign idxVec = SLibGetSystemAndCallSideIndex(blkZcRec)
  %assign cross  = system.CrossNoArgFcnBound
  %assign sysIdx = idxVec[0]
  %assign  csIdx = idxVec[1]
  %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], ...
    "ZCSV", csIdx)
  %assign blockPath = SLibCGIRVarGroupPath...
      (varGroupIdx, system.HStructDeclSystemIdx, cross)
  %assign zcSignalInfo = blkZcRec.ZcSignalInfo[0]
  %assign name = FcnGetZCSignalCGVarName(zcSignalInfo)
  %if nZCs > 1    
    %if isMdlRef 
      real_T* zcsv = (real_T*)&(%<blockPath>%<name>);
    %elseif zcSignalInfo.Width > 1 
      real_T* zcsv = &(%<blockPath>%<name>[0]);
    %else
      real_T* zcsv = &(%<blockPath>%<name>);
    %endif
    int_T i;
    %assign dxZeroUpperLimitPlus1 = nZCs
    for (i=0; i < %<dxZeroUpperLimitPlus1>; i++) {
      zcsv[i] = 0.0;
    }
  %else
    %if  isMdlRef
      real_T *zcsv = (real_T *) &(%<blockPath>%<name>);
      (*zcsv) = 0.0;
    %else
      %<blockPath>%<name> = 0.0;
    %endif 
  %endif	
%endfunction


%% Function SLibSetStatesDisabled ===========================================
%% Abstract: 
%%   This function generates code to set the system states to the value
%%   passed
%function SLibSetStatesDisabled(ssBlock,system,value) Output
  %with  ssBlock
    %assign cStates = LibBlockParamSetting("Subsystem", "SystemContStates")
  %endwith
  %assign ncStates = cStates[0]
  %if (ncStates == 0) 
    %return 
  %endif  
  
  %assert(SolverType == "VariableStep")

  %assign idx = cStates[1]
  %assign cs = ::CompiledModel.ContStates.ContState[idx]
  %assign varGroupIdx = cs.VarGroupIdx[1]
  %assign cross = system.CrossNoArgFcnBound
  %assign blockPath = SLibCGIRVarGroupPath( ...
    varGroupIdx, system.HStructDeclSystemIdx, cross)

  %if ncStates > 1
    %if FcnOwnerBlkType(cs) == "ModelReference"
      %assign blk = System[cs.SigSrc[0]].Block[cs.SigSrc[2]]
      %assign intrf = GetModelrefInterface(blk)
      %assign mdlRefCsWith  = CAST("Number", %<intrf.xOptWidth>)
      %assign isArray = mdlRefCsWith > 1
    %else
      %assign isArray = cs.Width > 1
    %endif
      
    %if isArray >1
      (void) %<LibGenMemFcnCall("memset", ...
	"&(%<blockPath>%<cs.Identifier>[0])", value, ...
	"%<ncStates>*sizeof(boolean_T)")>;
    %else 
      (void) %<LibGenMemFcnCall("memset", ...
	"&(%<blockPath>%<cs.Identifier>)", value, ...
	"%<ncStates>*sizeof(boolean_T)")>;
    %endif
  %else
    %<blockPath>%<cs.Identifier> = %<value>;
  %endif
%endfunction

%% Function: SLibUnusedParameter ========================
%%
%function SLibUnusedParameter(param) 
  %if IsModelReferenceTarget()
    %openfile retBuf
    (void) (%<param>);
    %closefile retBuf
  %else
    %openfile retBuf
    %<LibGenUnusedParamFcnCall("RT_UNUSED_PARAMETER", "%<param>")>;
    %closefile retBuf
  %endif
  %return retBuf
%endfunction 


%% Function: SLibGenNonReusableSubsysFcnAsClassMemFcn =======================
%%  Should a non-reusable subsystem function be generated as a member function
%%  in the model class?
%function SLibGenNonReusableSubsysFcnAsClassMemFcn(system)
  %assign result = GenerateClassInterface && ...
                   !IsModelReferenceBaseSys(system) && ...
                   LibSystemIsNonReusedFcn(system)

  %return result
%endfunction %% SLibGenNonReusableSubsysFcnAsClassMemFcn


%% Function: SLibGetAlignmentSyntax =======================
%%  Should a non-reusable subsystem function be generated as a member function
%%  in the model class?
%function SLibGetAlignmentSyntax(mdlName, symbol, dataType, align, alignType)
  %assert (align > 0)
  %assign ret = ""
  %assign das = FEVAL("rtwprivate", "da_syntax", mdlName, symbol, dataType, align, alignType)  
  %if !ISEMPTY(das.err)
    %openfile errMsg
    %<das.err>
    %closefile errMsg
    %<SLibReportErrorWithIdAndArgs("RTW:tlc:GenericMsg", errMsg)>
  %else
    %assign ret = das.syntax
  %endif  
  %return ret
  
%endfunction

%endif %% _SYSLIB_

%% [EOF] syslib.tlc
