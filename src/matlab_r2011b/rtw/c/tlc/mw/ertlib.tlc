%% ============================================================================
%% File : ertlib.tlc
%%
%% Abstract:
%%   This is the system library file for the Embedded-C code format.
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%% ============================================================================
%selectfile NULL_FILE

%if EXISTS("_ERTLIB_") == 0
%assign _ERTLIB_ = 1

%include "ertmdlrefabstime.tlc"
%include "ertmdlreftiming.tlc"
%include "ertmodelarg.tlc"
%include "ertcontstate.tlc"
%include "ertextmode.tlc"
%include "ertmdlrefcontinuous.tlc"

%addtorecord ::CompiledModel RequireMapTIDViaFunction 0

%% Function: SLibIncludeERTFirstTime()
%% Abstract:
%%   Returns if we should suppress usage of firstTime flag in 
%%   model_initialize() function
%function SLibIncludeERTFirstTime() void
  %if LibIsDeploymentDiagram()
    %return TLC_FALSE
  %elseif ExportFunctionsMode == 1 
    %return TLC_FALSE
  %elseif SLibAutosarActive()
    %return TLC_FALSE
  %% If ERTFirstTimeCompliant use the IncludeERTFirstTime flag
  %elseif ::CompiledModel.ConfigSet.ERTFirstTimeCompliant == 1 
    %return ::CompiledModel.ConfigSet.IncludeERTFirstTime == 1
  %else
    %return TLC_TRUE
  %endif
%endfunction

%% Function: SLibHasSetEventsForThisBaseRateFcn
%% Abstract:
%%   Returns true if ERT generats SetEventsForThisBaseStep function
%function SLibHasSetEventsForThisBaseRateFcn()
  %return !SLibSingleTasking() && ...
    !SuppressSetEventsForThisBaseRateFcn && ...
    !InlineSetEventsForThisBaseRateFcn
%endfunction

%% Function: SLibDumpERTAndModelrefInitMemoryCode() Ouput
%% Abstract:
%%   Dumps the registration code and initialization code
%%   to initialize model internal and external memory.
%%   This includes initialization of fields of RT_MODEL,
%%   and initialization of various other model structures.
%%   For ERT target, registration code and initialization code
%%   are both dumped into the <model>_initialize() function,
%%   and thus there is a single call with bEmitReg true (emit
%%   registration code) and bEmitInit true (emit initialization code).
%%   For other targets, registration code and initialization code
%%   may get dumped to separate functions, and thus 2 separate calls are
%%   made, one with bEmitReg true and one with bEmitInit true.
%%
%function SLibDumpERTAndModelrefInitMemoryCode(bEmitReg, bEmitInit, fromSFcn) Output
  %assign addr = IsMultiInsatnceERTOrModelReference() ? "" : "&"
  %assign rootSystem = System[NumSystems-1]

  %if GenerateClassInterface
    %assign addr = "&"
  %endif

  %if UsingMalloc && bEmitReg
     %assign OpenBlock = "{"
     %assign CloseBlock = "}"
  %else
     %assign OpenBlock = ""
     %assign CloseBlock = ""
  %endif
  
  %openfile retBuf
  %% ===========================
  %% Initialize internal memory
  %% ===========================
  %%
  %% Block I/O
  %%
  %openfile tmpBuf
  %% Those with internal stoarge
  %if !LibBlockIOStructIsEmpty()
    %if bEmitReg
      %if UsingMalloc 
        %% In the UsingMalloc case, we allocate the BlockIO struct 
        %% and set the blockIO ptr in the RTM
        %assign varName = "b"
        %assign ptrBlockIOLabel = varName
        void *%<varName> = malloc(sizeof(%<tBlockIOType>));
        %<RTMChkMemAndReturnIfErr(varName)>;

        %if ::CompiledModel.HasSimStructVars == 0
          %<RTMSet("BlockIO", ptrBlockIOLabel)>;
        %endif
      %elseif GenerateGRTWrapper
        %assign blockIO = IsModelReferenceTarget() ? "localB" : LibGetBlockIOStruct()
        %<RTMSet("BlockIO", "(void *) %<addr>%<blockIO>")>;
      %elseif MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn()
        %% In the multi-instance ERT case, we don't need to malloc
        %% the BlockIO struct, but we may still need to generate code to
        %% initialize the blockIO  ptr in the RTM
        %<RTMSet("BlockIO", "%<addr>%<LibGetBlockIOStruct()>")>;
        %<SLibAccessArgHelper(rootSystem.Interface.BlockIOArgDef,"",rootSystem.CurrentTID)>
      %endif
    %endif %% bEmitReg
    %if bEmitInit
      %assign blockIO = IsModelReferenceTarget() && !GenerateClassInterface ? ...
          "localB" : "%<LibGetBlockIOStruct()>"
        %assign ptrBlockIOLabel = "((void *) %<addr>%<blockIO>)"
        %<SLibInitBlockIO(ptrBlockIOLabel)>\
    %endif %% bEmitInit
    
  %elseif !SLibModelBlockIOStructIsEmpty()
    %% It is possible that there is no root level blockIO, but there
    %% is a standalone subsystem that has a blockIO.
    %assert HasStandaloneSubsystem && !GenerateGRTWrapper
    
    %if bEmitInit
      %<SLibInitBlockIO("")>\
    %endif
    
  %endif %% !LibBlockIOStructIsEmpty()
  
  
  %%
  %% Those with external storage
  %% 
  %if !SLibExportedGlobalSignalsIsEmpty() || ...
    CustomStorageClasses.NumCustomStorageClasses > 0
    
    %if bEmitInit
      %<SLibInitBlockIOWithExternalStorage(!UsingMalloc)>\
    %endif
    
  %endif
  %closefile tmpBuf
  %if !WHITE_SPACE(tmpBuf)
    /* block I/O */
    %<OpenBlock>
    %<tmpBuf>\
    %<CloseBlock>
  %endif
  %%
  %% Invariant Block Outputs
  %%
  %if !LibConstBlockIOStructIsEmpty() 
   %if UsingMalloc 
      /* constant block I/O */
      %<RTMuSet("ConstBlockIO", "&%<tInvariantSignals>")>;
    %elseif MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn()
      /* constant block I/O */
      %<RTMSet("ConstBlockIO", "&%<LibGetConstBlockIOStruct()>")>;
      %<SLibAccessArgHelper(rootSystem.Interface.ConstBlockIOArgDef,"",rootSystem.CurrentTID)>
    %endif
  %endif
  %%
  %%  Parameter
  %%
  %if !LibParametersStructIsEmpty()
    %if bEmitReg
      %if UsingMalloc
        /* parameters */
        {
          %<tParametersType> *p;
          static int_T pSeen = FALSE;
          
          /* only malloc on multiple model instantiation */
          if( pSeen == TRUE ) {
            p = (%<tParametersType> *) malloc(sizeof(%<tParametersType>));
            %<RTMChkMemAndReturnIfErr("p")>;
            (void) %<LibGenMemFcnCall("memcpy", "p", "&%<tDefaultParameters>", ...
              "sizeof(%<tParametersType>)")>;
            %<RTMSet("ParamIsMalloced", "TRUE")>;
          } else {
            p = &%<tDefaultParameters>;
            %<RTMSet("ParamIsMalloced", "FALSE")>;
            pSeen = TRUE;
          }
          %<RTMSet("DefaultParam", "(real_T *) p")>;
        }
      %elseif GenerateGRTWrapper || (MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn())
        /* parameters */
        %<RTMSet("DefaultParam", "(real_T *)%<addr>%<LibGetParametersStruct()>")>;
        %<SLibAccessArgHelper(rootSystem.Interface.ParameterArgDef,"",rootSystem.CurrentTID)>
      %endif
   %endif %% bEmitReg
  %endif
  %%
  %% Continuous States
  %%
  %if NumContStates > 0 && !IsModelReferenceTarget() && !LibIsDeploymentDiagram()
    %openfile tmpBuf
    %if bEmitReg && (GenerateGRTWrapper || (MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn()))
      %% Get a pointer to the continuous states in "x"
      %if UsingMalloc
        real_T *x = (real_T *) malloc(sizeof(%<tContStateType>));
        %<RTMChkMemAndReturnIfErr("x")>;
      %else
        real_T *x = (real_T *) %<addr>%<LibGetContinuousStateStruct()>;
        %<SLibAccessArgHelper(rootSystem.Interface.ContStatesArgDef,"",rootSystem.CurrentTID)>
      %endif
      %% Initialize the "contStates" field in the RTM
      %<RTMSet("ContStates", "x")>;
    %endif %% bEmitReg

    %if bEmitInit
      %if SLibZeroMemory("CState")
        (void) %<LibGenMemFcnCall("memset", "(void *)%<addr>%<LibGetContinuousStateStruct()>", "0", ...
          "sizeof(%<tContStateType>)")>;
      %endif
    %endif %% bEmitInit


    %closefile tmpBuf
    %if !WHITE_SPACE(tmpBuf)
      /* states (continuous) */
      {
        %<tmpBuf>\
      }
    %endif
  %endif
  %%
  %%  Mass Matrix
  %%
  %if ModelIsLinearlyImplicit == "yes" && !IsModelReferenceTarget() && ...
    !LibIsDeploymentDiagram()
    %openfile tmpBuf
      %if GenerateGRTWrapper
        %<RTMSet("MassMatrixIr", "ir")>;
        %<RTMSet("MassMatrixJc", "jc")>;
        %<RTMSet("MassMatrixPr", "pr")>;
      %endif
      %if SLibZeroMemory("MassMatrix")
        (void) %<LibGenMemFcnCall("memset", "(void *)ir", "0", ...
          "%<ModelMassMatrixNzMax>*sizeof(int_T)")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)jc", "0", ...
          "(%<NumContStates>+1)*sizeof(int_T)")>;
        (void) %<LibGenMemFcnCall("memset", "(void *)pr", "0", ...
          "%<ModelMassMatrixNzMax>*sizeof(real_T)")>;      
      %endif
    %closefile tmpBuf
    %if !WHITE_SPACE(tmpBuf)
    /* global mass matrix */
    {
      int_T *ir = %<LibGetMassMatrixGlobalIr()>;
      int_T *jc = %<LibGetMassMatrixGlobalJc()>;
      real_T *pr = %<LibGetMassMatrixGlobalPr()>;
      
      %<tmpBuf>\
    }
    %endif
  %endif  
  %%
  %% DWork with internal storage
  %%
  %assign hasDWork = !SLibModelDWorkStructIsEmpty()
  %openfile tmpBuf
  %% SLibInitDWorkOld does not handle model reference the same way.
  %% So if we are in backwards compatibility mode, and
  %% the target is model reference, do not enter here.
  %if hasDWork && (!(ForceBlockIOInitOptimize && IsModelReferenceTarget()))
    %assign stdSSBuf = CacheStandaloneSystemDWorkInfo()
    
    %assign stdSSBuf = SLibInitDWork(stdSSBuf)

    %if bEmitReg
      %if UsingMalloc
        %% In the UsingMalloc case we allocate the DWork structure
        %% and then initialize the Work.dwork ptr in the RTM
        void *dwork = (void *) malloc(sizeof(%<tDWorkType>));
        %if stdSSBuf.DWorkBuff[0].haveFloat && ::CompiledModel.HasSimStructVars == 0
          %assign definition = ...
            "%<tDWorkType> *%<LibGetDWorkStruct()> = (%<tDWorkType> *) dwork;"
          %% AUTOSAR compiler abstraction not needed as AUTOSAR never enters this code
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataInternal", "%<LibGetDWorkStruct()>")>\
        %endif
        %<RTMChkMemAndReturnIfErr("dwork")>;      
        %<RTMSet("RootDWork", "dwork")>;
      %elseif GenerateGRTWrapper
        %assert(SIZE(stdSSBuf.DWorkBuff,1) == 1)
        %<RTMSet("RootDWork", "(void *) %<addr>%<LibGetDWorkStruct()>")>;
      %elseif MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn()
        %% In the multi-instance ERT case, we don't need to allocate
        %% the DWork struct, but we may still need to generate code to
        %% initialize the Work.dwork ptr in the RTM
        %<RTMSet("RootDWork", "%<addr>%<LibGetDWorkStruct()>")>;
        %<SLibAccessArgHelper(rootSystem.Interface.DWorkArgDef,"",rootSystem.CurrentTID)>
      %endif
    %endif  %% bEmitReg
    
    %if bEmitInit
      %assign numGroups = SIZE(stdSSBuf.DWorkBuff,1)
      %foreach groupIdx = numGroups
        %openfile tmpBuf2
        %if stdSSBuf.DWorkBuff[groupIdx].needMemset
          %assign dw     = stdSSBuf.DWorkBuff[groupIdx].DWorkVar
          %assign dwType = stdSSBuf.DWorkBuff[groupIdx].DWorkType
          
        (void) %<LibGenMemFcnCall("memset", "(void *)%<addr>%<dw>", ...
          " 0", " sizeof(%<dwType>)")>;
        %endif
        %if InitFltsAndDblsToZero && stdSSBuf.DWorkBuff[groupIdx].haveFloat
          %<stdSSBuf.DWorkBuff[groupIdx].initBuffer>\
        %endif
        %closefile tmpBuf2
        
        %if groupIdx == 0
          %<tmpBuf2>
        %else
          %assign ssIdx = stdSSBuf.DWorkBuff[groupIdx].SystemIdx
          %<LibAddToSystemField(System[ssIdx], "CachedInitializeDataBody", tmpBuf2)>
        %endif
      %endforeach
    %endif %% bEmitInit
  %endif
  %if bEmitInit
    %% This is unnecessary unless we are using the backwards compatibility 
    %% mode, ForceBlockIOInitOptimize
    %if ForceBlockIOInitOptimize
      %% Initialize internal DWork for Model reference scalable builds
      %% For scalable build, the single instance child model will define its 
      %% own DWork (member of sfcn_DWork). 
      %% Use memset to initialize this memory to zero.
      %%
      %if (IsModelRefScalableBuild() && System[NumSystems-2].HasDWorkArg && ...
        (IsModelReferenceSimTarget() || SLibZeroMemory("RTDWork")) && ...
        !GenerateClassInterface)
        %assert (::BlockFcn == "Registration")
        %<SLibAccessArgHelper(System[NumSystems-2].Interface.DWorkArgDef,"","")>
        %assign varGroupType = FcnSysVarGroupType(System[NumSystems-2],"DWork")
        (void) %<LibGenMemFcnCall("memset", "localDW", ...
          "0", "sizeof(%<varGroupType>)")>;
      %endif
    
      %if IsModelReferenceRTWTarget() && GenerateClassInterface 
        %assign errTxt = "C++ encapsulation is not supported with the ForceBlockIOInitOptimize feature"
        %<LibReportError(errTxt)>
      %endif
    %endif
    
    %%
    %% Dwork with external storage
    %%
    %<SLibInitStatesWithExternalStorage(!UsingMalloc)>\
    
    %if ::CompiledModel.DWorkAndBlockIOCombined
      %if !LibDWorkStructIsEmpty()
        %assign dwork = IsModelReferenceTarget() && !GenerateClassInterface ? ...
          "localDW" : "%<LibGetDWorkStruct()>"
        %assign ptrDWorkLabel = "((void *) %<addr>%<dwork>)"
        %<SLibInitBlockIO(ptrDWorkLabel)>\
      %elseif hasDWork %% !SLibModelDWorkStructIsEmpty()
        %%
        %% It is possible that there is no root level dwork, but there
        %% is a standalone subsystem that has a dwork.
        %%
        %assert HasStandaloneSubsystem && !GenerateGRTWrapper      
        %<SLibInitBlockIO("")>\
      %endif %% !LibBlockIOStructIsEmpty()    
    %endif
  %endif %% bEmitInit
  
  %closefile tmpBuf
  %if !WHITE_SPACE(tmpBuf)

    /* states (dwork) */
    %<OpenBlock>
    %<tmpBuf>\
    %<CloseBlock>
  %endif
  %%
  %% ===========================
  %% Initialize external memory
  %% ===========================
  %%
  %if !IsModelReferenceTarget()
    %%
    %% U (external inputs)
    %%
    %openfile tmpBuf
    %if bEmitReg
      %if !LibExternalInputsStructIsEmpty()
        %if UsingMalloc
          %if ::CompiledModel.HasSimStructVars == 0
            %openfile definition
            %<tInputType> *%<LibGetExternalInputStruct()> = (%<tInputType> *) \
            malloc(sizeof(%<tInputType>));\
            %closefile definition
          %else
            %openfile definition
            %<RTMGet("U")> = (%<tInputType> *) malloc(sizeof(%<tInputType>));\
            %closefile definition
          %endif
          %% AUTOSAR compiler abstraction not needed as this is a local variable
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataIO", "%<LibGetExternalInputStruct()>")>\
          %<RTMChkMemAndReturnIfErr(LibGetExternalInputStruct())>;
          %if ::CompiledModel.HasSimStructVars == 0
            %<RTMSet("U", "((void*) %<LibGetExternalInputStruct()>)")>;
          %endif
        %elseif GenerateGRTWrapper || (MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn())
          %<RTMSet("U", "((void*)%<addr>%<LibGetExternalInputStruct()>)")>;
        %endif 
      %endif %% !LibExternalInputsStructIsEmpty()
    %endif %% bEmitReg
    %if bEmitInit
      %% This call covers external input structure (i.e. with AUTO storage),
      %% and external inputs with external storage
      %<SLibInitExternalInputs(!UsingMalloc,...
        fromSFcn && FcnConditionRootInputsAsSeparateArgs(),fromSFcn)>\
    %endif %% bEmitInit

    %openfile inputSizeBuf
    %if bEmitInit
      %<SLibInitExternalInputSizes()>\
    %endif
    %closefile inputSizeBuf

    %closefile tmpBuf
    %if !WHITE_SPACE(tmpBuf)
      %if GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %if classConfObj.hasGlobalAccessForInport && ...
            !(fromSFcn && SLibCPPClassNeedsDerivedClassWithERTSfcnZeroMem())
          /* external inputs */
          %<OpenBlock>
          %<tmpBuf>\
          %<CloseBlock>
        %endif
      %else
        /* external inputs */
        %<OpenBlock>
        %<tmpBuf>\
        %<CloseBlock>
        
        %if !WHITE_SPACE(inputSizeBuf)
          /* external input sizes */
          %<OpenBlock>
          %<inputSizeBuf>\
          %<CloseBlock>
        %endif
      %endif
    %endif
    %%
    %% Y (external outputs)
    %%
    %openfile tmpBuf

    %if bEmitReg
      %if !LibExternalOutputsStructIsEmpty()
        %if UsingMalloc
          %if ::CompiledModel.HasSimStructVars == 0
            %openfile definition
            %<tOutputType> *%<LibGetExternalOutputStruct()> = \
            (%<tOutputType> *) malloc(sizeof(%<tOutputType>));\
            %closefile definition
          %else
            %openfile definition
            %<RTMGet("Y")> = (%<tOutputType> *) malloc(sizeof(%<tOutputType>));\
            %closefile definition
          %endif
          %% AUTOSAR compiler abstraction not needed as this is a local variable
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataIO", "%<LibGetExternalOutputStruct()>")>\
          %<RTMChkMemAndReturnIfErr(LibGetExternalOutputStruct())>;
          %if ::CompiledModel.HasSimStructVars == 0
            %<RTMSet("Y", LibGetExternalOutputStruct())>;
          %endif
        %elseif GenerateGRTWrapper || (MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn())
          %<RTMSet("Y", "%<addr>%<LibGetExternalOutputStruct()>")>;
        %endif
      %endif %% !LibExternalOutputsStructIsEmpty()
    %endif %% bEmitReg
    %if bEmitInit
      %% This call covers external output structure (i.e. with internal storage),
      %% not including external outputs with external storage (which should
      %% already be covered by Block IO)
      %if fromSFcn && FcnConditionRootOutputsAsSeparateArgs()
        %% for Sfunction wrappers, initialize local data in addition to rtY
        %% just to be safe
        %<SLibInitExternalOutputs(1,1,fromSFcn)>\
      %endif
      %<SLibInitExternalOutputs(1,0,fromSFcn)>\
    %endif %% bEmitInit

    %openfile outputSizeBuf
    %if bEmitInit
      %<SLibInitExternalOutputSizes()>\
    %endif
    %closefile outputSizeBuf

    %closefile tmpBuf
    %if !WHITE_SPACE(tmpBuf)
      %if GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %if classConfObj.hasGlobalAccessForOutport && ...
            !(fromSFcn && SLibCPPClassNeedsDerivedClassWithERTSfcnZeroMem())
          /* external outputs */
          %<OpenBlock>
          %<tmpBuf>\
          %<CloseBlock>
        %endif
      %else
        /* external outputs */
        %<OpenBlock>
        %<tmpBuf>\
        %<CloseBlock>
        
        %if !WHITE_SPACE(outputSizeBuf)
          /* external output sizes */
          %<OpenBlock>
          %<outputSizeBuf>\
          %<CloseBlock>
        %endif
      %endif
    %endif
  %endif %% !IsModelReferenceTarget()
  %%
  %% PrevZCStates
  %%
  %if NumZCEvents > 0 && !LibPrevZCStatesStructIsEmpty()
    %if UsingMalloc || (MultiInstanceERTCode && RTMModelPtrsToInstanceDataIsReqFcn())
      %<LibDumpModelInitializePrevZCStates(bEmitReg, bEmitInit)>
    %endif
  %endif  
  %%
  %% Cache function pointers, if necessary
  %%
    
  %if bEmitReg
    %if UsingMalloc
      %<RTMModelMthsSet("mdlInitializeSizes",       "MdlInitializeSizes")>;
      %<RTMModelMthsSet("mdlInitializeSampleTimes", "MdlInitializeSampleTimes")>;
      %<RTMModelMthsSet("mdlStart",                 "MdlStart")>;
      %<RTMModelMthsSet("mdlOutputs",               "MdlOutputs")>;
      %<RTMModelMthsSet("mdlUpdate",                "MdlUpdate")>;
      %if !SLibSingleTasking() && !SuppressSetEventsForThisBaseRateFcn && ...
        !InlineSetEventsForThisBaseRateFcn
        %<RTMModelMthsSet("mdlDiscreteEvents",        "_rt_SimUpdateDiscreteEvents")>;
      %endif
      %if NumContStates > 0
        %<RTMModelMthsSet("mdlDerivatives", "NULL")>;
        %<RTMModelMthsSet("mdlProjection",  "NULL")>;
        %if ModelIsLinearlyImplicit == "yes"
          %<RTMModelMthsSet("mdlMassMatrix",      "MdlMassMatrix")>;
          %<RTMModelMthsSet("mdlForcingFunction", "MdlForcingFunction")>;
        %else           
          %<RTMModelMthsSet("mdlMassMatrix",      "NULL")>;
          %<RTMModelMthsSet("mdlForcingFunction", "NULL")>;
        %endif        
      %else
        %<RTMModelMthsSet("mdlDerivatives", "NULL")>;
        %<RTMModelMthsSet("mdlProjection",  "NULL")>;
        %<RTMModelMthsSet("mdlMassMatrix",      "NULL")>;
        %<RTMModelMthsSet("mdlForcingFunction", "NULL")>;
      %endif
      %<RTMModelMthsSet("mdlTerminate", "MdlTerminate")>;
      %<RTMModelMthsSet("RTModelPtr", tSimStruct)>;
    %endif
  %endif
    

  %closefile retBuf

  %return retBuf
%endfunction %% SLibDumpERTAndModelrefInitMemoryCode

%function SLibERTGetStopTime()
  %if ISINF(StopTime) || !RTMTUseStopTimeAsTFinal()
    %% When MatFileLogging is off, ERT will not honor stop time.
    %assign stopTime = -1
  %elseif !ISFINITE(StopTime)
    %assign errTxt = "Stop time must be 0.0, inf, or finite: %<StopTime>"
    %<LibReportError(errTxt)>
  %else
    %assign stopTime = StopTime
  %endif
  
  %return stopTime
%endfunction

%% Function: LibDumpERTAndModelrefRegExecution ================================
%% Abstract:
%%   Dumps the model registration code.
%%
%function LibDumpERTAndModelrefRegExecution(bEmitReg, bEmitInit) Output
  %assign tmpBlockFcn = ::BlockFcn
  %assign stepSize = FundamentalStepSize

  

  %if bEmitReg
    %if UsingMalloc 
      %assign rtModelObj     = RTMGetModelSS()
      %assign rtModelObjType = tSimStructType
      %<rtModelObjType> *%<rtModelObj>;
      %if !GenRTModel
        %assign errMsg = "Real-Time malloc target doesn't support SimStruct, target "...
          "must use rtModel. Malloc based targets must not have GenRTModel = 0 in " ...
          "sytem target file."
        %<LibReportFatalError(errMsg)>
      %endif 
      %<rtModelObj> = (%<rtModelObjType> *) malloc(sizeof(%<rtModelObjType>));
      if(%<rtModelObj> == NULL) {
        return NULL;
      }
      (void) %<LibGenMemFcnCall("memset", "(char *)%<rtModelObj>", "0", ...
        "sizeof(%<rtModelObjType>)")>;
    %endif %% UsingMalloc

  %endif %% bEmitReg

  %if bEmitInit  
    %%
    %% Initialize real-time object
    %%
    %if !UsingMalloc 
      %% If use Malloc, model() registration function mallocs
      %% and clears, so skip it here
      
      %if RealTimeModelAccessed
        %if SLibZeroMemory("RTM") && !SLibIsCPPEncapMdlRefBuild()
          %assign baseSysIdx = GetBaseSystemIdx()
          /* initialize real-time model */
          (void) %<LibGenMemFcnCall("memset", "(void *)%<tSimStruct>", ...
            "0", "sizeof(%<tSimStructType>)")>;
          %<SLibAccessArgHelper(::CompiledModel.System[baseSysIdx].Interface.RTMArgDef,"","")>
        %endif
        %if SuppressMultiTaskScheduler && !GenerateSampleERTMain && !IsModelReferenceTarget()
          %foreach i = NumSynchronousSampleTimes
            (%<tSimStruct>)->Timing.TaskCounters.cLimit[%<i>] = %<FcnComputeTaskTickLimit(i)>;
          %endforeach
        %endif
      %endif
    %endif %% !UsingMalloc
  %endif %% bEmitInit
  %if bEmitReg || bEmitInit
  %%
  %% Create Solver data
  
  %if !IsModelReferenceTarget() && !LibIsDeploymentDiagram() && !PurelyIntegerCode && ...
    (LibIsContinuous(0) || NumChildSFunctions) || UsingMalloc 
    
    %<FcnCreateAndInitializeSolverData(bEmitReg, bEmitInit)>
    
  %endif
  %endif %% bEmitReg || bEmitInit
  

  
  %if bEmitInit  
  %if ExportFunctionsMode == 0 
    %if GenerateGRTWrapper || RTMNonInlinedSFcnsIsReqFcn()
      
      %% Initialize timing info.
      %% Initialize timing fields if the IsReqFcn of this field returns true.
      %%
      %% To support GRT interface, non-inline sfunction, or model-ref,
      %% some timing fields that are not used in ert are required and need to be 
      %% initialized. These fields are initialized here.
      %%
      /* Initialize timing info */
      %if RTMModelPtrsForNonERTIsReqFcn() || SLibModelHierarchyContainsNoninlinedSfcn()
        {
          int_T  *mdlTsMap      = %<RTMGet("SampleTimeTaskIDArray")>;
          %%
          %if NumSynchronousSampleTimes >= 1 && ...
            NumSynchronousSampleTimes < RollThreshold
            %% do not use a loop
            %foreach sampIdx = NumSynchronousSampleTimes
              mdlTsMap[%<sampIdx>] = %<sampIdx>;
            %endforeach
          %elseif NumSynchronousSampleTimes >= RollThreshold
            %% use a loop
            int_T i;
            
            for(i = 0; i < %<NumSynchronousSampleTimes>; i++) {
              mdlTsMap[i] = i;
            }
          %endif
          %<RTMSet("SampleTimeTaskIDPtr", "&mdlTsMap[0]")>;
          %<RTMSet("SampleTimePtr", "&%<RTMGet("SampleTimeArray")>[0]")>;
          %<RTMSet("OffsetTimePtr", "&%<RTMGet("OffsetTimeArray")>[0]")>;
          %<LibDumpModelInitializeSampleTimes()>\
        }
      %endif
      
      %if RTMTimePtrIsReqFcn()
        %<RTMSet("TPtr", "&%<RTMGet("TaskTimeArray")>[0]")>;
      %endif
      
      %if SLibModelHierarchyContainsNoninlinedSfcn() || GenerateGRTWrapper
        {
          int_T  *mdlSampleHits = %<RTMGet("SampleHitArray")>;
          %if SLibSingleTasking()
            %if NumSynchronousSampleTimes >= 1 && ...
              NumSynchronousSampleTimes < RollThreshold
              %% do not use a loop
              %foreach sampIdx = NumSynchronousSampleTimes
                mdlSampleHits[%<sampIdx>] = 1;
              %endforeach
            %elseif NumSynchronousSampleTimes >= RollThreshold
              %% use a loop
              int_T i;
              
              for(i = 0; i < %<NumSynchronousSampleTimes>; i++) {
                mdlSampleHits[i] = 1;
              }
            %endif
          %elseif RTMChildSfunctionIsReqFcn()
            int_T *mdlPerTaskSampleHits = %<RTMGet("PerTaskSampleHitsArray")>;
            
            %<RTMSet("PerTaskSampleHitsPtr", "&mdlPerTaskSampleHits[0]")>;
            mdlSampleHits[0] = 1;
          %endif
          %<RTMSet("SampleHitPtr", "&mdlSampleHits[0]")>;
        }
      %endif
    %elseif ( LibIsContinuous(0) && ...
      !IsModelReferenceTarget() )
      %assert RTMTimePtrIsReqFcn()
      %<RTMSet("TPtr", "&%<RTMGet("TaskTimeArray")>[0]")>;
    %endif
  %endif
  %if IsModelReferenceTarget() && !GenerateClassInterface
    %% Declare the global timing  variables at the top of
    %% model.c, and extern them in model_private.h
    %<FcnInitializeModelRefGlobalTimingEngine()>
  %endif
  %endif %% bEmitInit  

  
  %if bEmitReg || bEmitInit
  %if !IsModelReferenceForASimstructBasedTarget()

    %% current
    %if bEmitInit
    %% Non-inlined S-function not supported for model reference coder target yet
    %if NumChildSFunctions
      %assert !IsModelReferenceRTWTarget() || ::ModelReferenceSupportNoninlinedSfcn
    %endif

    %%
    %% Setup absolute time
    %%
    %if !IsModelReferenceTarget() && StartTime != 0.0
      %assign errTxt = "Start time must be 0.0 for the chosen target: %<StartTime>."
      %<LibReportFatalError(errTxt)>
    %endif

    %if (SLibNeedAbsoluteTime() || MatFileLogging || ExtMode) ...
      && !IsModelReferenceTarget()

      %if PurelyIntegerCode && MatFileLogging
	%<LibReportError("Do not yet support integer-only MAT-file logging.")>
      %elseif PurelyIntegerCode && !MatFileLogging
	%% nop
      %else
	%if RTMTFinalIsReqFcn()
	  %% Initialize stop time
	  %<RTMSet("TFinal","%<SLibERTGetStopTime()>")>;
        %endif
	%foreach tid = NumSampleTimes
	  %if SampleTime[tid].NeedFloatTime == "yes" && ...
	    !PurelyIntegerCode
	    %<RTMGet("StepSize%<tid>")>  = %<SampleTime[tid].ClockTickStepSize>;
	  %endif
	%endforeach
      %endif
    %endif

    %if RTMFirstInitCondFlagIsReqFcn()
      %<RTMSet("FirstInitCond", 1)>;
    %endif

    %% All offsets will be initialized by the top model
    %% when using the global timing engine
    %if !IsModelReferenceTarget()
      %<FcnInitializeSampleTimeOffsets()>
    %endif

    %if IsModelReferenceTarget()
      %if !GenerateClassInterface
        %% Setup the error status flag
        %if !SuppressErrorStatus
          /* initialize error status */
          %<RTMSet("ErrorStatusPointer", "rt_errorStatus")>;
        %endif
        %% Setup the stop requested flag
        %if RTMStopReqAccessed()
          /* initialize stop requested flag */
          %<RTMSet("StopRequestedPtr", "rt_stopRequested")>;
          
        %endif
      %endif

      %% Setup the rtwsolverinfo
      %if LibIsContinuous(0) || (NumChildSFunctions > 0)
        %assert !GenerateClassInterface
        /* initialize RTWSolverInfo */
        %<RTMSet("RTWSolverInfo", "rt_solverInfo")>;
        %if LibIsContinuous(0)
          %<FcnModelRefCreateAndInitializeSolverData()>
        %endif
      %endif
    %else
      %%
      %% Initialize error status (only if real-time model has not been accessed
      %% since this will force a memset of rtM regardless).
      %%
      %if !SuppressErrorStatus && !RealTimeModelAccessed && SLibZeroMemory("RTM")

	/* initialize error status */
        %<RTMSet("ErrorStatus",SLibGetNullDefinitionFromTfl())>;
      %endif
    %endif
    %endif %% bEmitInit
    
    %if bEmitReg || bEmitInit
    %%
    %% Setup data logging
    %%
    %if MatFileLogging == 1 
      %assert(!IsModelReferenceTarget())
      %% data logging setup
      
      %<SLibDumpModelRegDataLoggingSetup(bEmitReg, bEmitInit)>
    %endif
    %%
    %% Setup external mode
    %%
    %if ExtMode == 1
      %assert(!IsModelReferenceTarget())
      %if SLibIsERTCodeFormat()

        %if bEmitInit
	/* external mode info */
	%<SLibDumpModelChecksumReg()>
        %endif %% bEmitInit

	%% Dump the system mode vector addresses.
	%<SLibDumpExtModeReg(bEmitReg, bEmitInit)>
      %endif
    %endif
    %endif %% bEmitReg || bEmitInit

        
  %else
    %if bEmitInit
    %if !IsModelReferenceTarget()
      %<FcnInitializeSampleTimeOffsets()>
    %endif
    %<RTMSet("MdlRefSfcnS", tMdlRefSfcnS)>;
    %endif %% bEmitInit
  %endif %% !IsModelReferenceForASimstructBasedTarget
  %endif %% bEmitReg || bEmitInit
  
  

  %if bEmitInit
  %if RTMNonInlinedSFcnsIsReqFcn() || GenerateGRTWrapper
    %% SolverInfo
    %assign solverInfo = "%<RTMGetSolverInfo()>"
    %<RTMSet("RTWSolverInfoPtr", solverInfo)>;
    %% StepSize
    %<RTMSet("StepSize", FixedStepOpts.FixedStep)>;
    %<RTMSolverSet("FixedStepSize", FixedStepOpts.FixedStep)>;
    %% SolverMode
    %if ::CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
      %<RTMSolverSet("SolverMode", "SOLVER_MODE_MULTITASKING")>;
    %else
      %<RTMSolverSet("SolverMode", "SOLVER_MODE_SINGLETASKING")>;
    %endif
  %endif
  %endif %% bEmitInit
  
  %if bEmitReg || bEmitInit
  
  %<SLibDumpERTAndModelrefInitMemoryCode(bEmitReg, bEmitInit, 0)>
  
  %endif %% bEmitReg || bEmitInit

  %%
  %% Model mapping info
  %%
  %if bEmitReg
    %<SLibDumpModelMappingInfo()>\
  %endif %% bEmitReg
  %%
  %% Init MassMatrix-related DWorks (and Base pointer for Model blocks)
  %%
  %if bEmitInit
  %if ModelIsLinearlyImplicit == "yes" 
            
    %if IsModelReferenceTarget()
      /* Init MassMatrixPr Base and Offsets */
      {          
        %<RTMGet("MassMatrixBasePr")> = localMM;
          
        %foreach mmIdx = ::CompiledModel.MassMatrices.NumMassMatrices
          %assign mm = ::CompiledModel.MassMatrices.MassMatrix[mmIdx]
          %assign prOffset = mm.IndexPr
          
          %assign grSrc = mm.GrSrc
          %assign comment  = "/* '%<SLibGrBlockName(grSrc)>' */"    
          
          %assign grSubSys = ::CompiledModel.BlockHierarchyMap.Subsystem[grSrc[0]]
          %assign grBlock  = grSubSys.Block[grSrc[1]]
          
          %assign dwIdx = -1  %% invalid
          %assign dw = ""
          %assign foundMassMatrixDWork = TLC_FALSE
          %foreach blkDW = grBlock.NumDWorks
            %assign dwIdx = grBlock.DWork[blkDW]._idx
            %assign dw = ::CompiledModel.DWorks.DWork[dwIdx]          
            %if dw.Name == "MASS_MATRIX_PR"
              %assign foundMassMatrixDWork = TLC_TRUE 
              %break
            %endif
          %endforeach          
          %assert foundMassMatrixDWork        
          
          %<SLibAccessArgHelper(System[NumSystems-2].Interface.DWorkArgDef,"","")>            
          %if ISFIELD(mm, "ForEachSSLoopBnds")
              %% The owner block is inside For Each subsystem.
              %% Need to initialize the DWork value correctly for each iteration
             %assign ::NeedForEachLoopInReg = TLC_TRUE
             %assign ::NumForEachLoopHierarchyLevel = SIZE(mm.ForEachSSLoopBnds,1)
             %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
             %assign mmPrOffset = "%<prOffset>"
             {
               %% Form loop for every parent For Each subsystem
             %foreach ssIdx = SIZE(mm.ForEachSSLoopBnds,1)
               %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
               %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                 int32_T %<iterVar>;
                 for (%<iterVar> = 0; %<iterVar> < %<mm.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
               %assign mmPrOffset = mmPrOffset + "+" + iterVar + "*%<mm.ForEachSSMassMatrixPrSize[::ForEachLoopHierarchyLevel]>"
             %endforeach
             %assign ::ForEachLoopHierarchyLevel = 1
          %else
            %assign mmPrOffset = "%<prOffset>"
          %endif
          
          %<SLibBlockMassMatrixPrOffsetInternal("", "", 0, dwIdx, dw, 1)> = %<mmPrOffset>; %<comment>        
          %if ISFIELD(mm, "ForEachSSLoopBnds")
              %% Close the loop for every parent For Each subsystem
             %foreach ssIdx = SIZE(mm.ForEachSSLoopBnds,1)
                 }
             %endforeach
             }
             %assign ::NeedForEachLoopInReg = TLC_FALSE
          %endif
          
        %endforeach
      }       
    %else   %% IsModelReferenceTarget()

      %<FcnGenInitMassMatrixPrInRoot()> 

    %endif  
  %endif
  %endif %% bEmitInit
      
  %assign ::BlockFcn = tmpBlockFcn
%endfunction %% LibDumpERTAndModelrefRegExecution() Output


%% Function: SLibErtWideInit ===================================================
%% Abstract:
%%   ertwide.tlc remnant.  Performs error checking an initial setup for
%%   Embedded-C code format
%%
%function SLibErtWideInit() void
  %if !IsModelReferenceForASimstructBasedTarget()
    %% =========================================================================
    %% Error checking
    %%

    %% Temporarily ERT only supports {ODE1, ODE2, ODE3, ODE4, ODE5, ODE8, ODE14x, FSDiscrete}
    %assign notSupported = !(ISEQUAL(Solver,"ode1") || ISEQUAL(Solver,"ode2")  ...
      || ISEQUAL(Solver,"ode3") || ISEQUAL(Solver,"FixedStepDiscrete")         ...
      || ISEQUAL(Solver,"ode4") || ISEQUAL(Solver,"ode5") || ISEQUAL(Solver,"ode8") ...
      ||ISEQUAL(Solver,"ode14x"))

  %if notSupported
      %%
      %% No continuous task blocks allowed
      %% LibIsContinuous(0) may be wrong if all continuous blocks were reduced
      %if LibIsContinuous(0)
	%assign blockList = []

	%foreach sysIdx = NumSystems
	  %assign system = System[sysIdx]
	  %with system
	    %foreach blkIdx = NumBlocks+NumVirtualOutportBlocks
	      %assign block = Block[blkIdx]
	      %with block
		%if ISFIELD(block,"TID")
		  %if TYPE(TID) == "Number"
		    %% limit list to 10 blocks
		    %if LibIsContinuous(TID) && SIZE(blockList, 1) < 10
		      %assign blockList = ...
			blockList + SLibGrBlockPath(block.GrSrc)
		    %endif
		  %endif
		%endif
	      %endwith
	    %endforeach
	    %if SIZE(blockList, 1) >= 10
	      %break
	    %endif
	  %endwith
	%endforeach

	%assign numBlocks = SIZE(blockList, 1)
	%% LibIsContinuous(0) may be wrong if all continuous blocks were reduced
	%% Make sure at least one continuous block remained
	%if IsModelReferenceTarget()
	  %assign str = "Model reference"
	%else
	  %assign str = "Embedded-C code format"
	%endif

	%if numBlocks > 0
	  %assign errTxt = "\n\nThe %<str> does not support " ...
	    "continuous sample time blocks.  "
	  %if numBlocks == 1
	    %assign str = "This block either specifies or inherits a " ...
	      "continuous rate:\n\n%<blockList>"
	  %else
	    %assign str = "Here are %<numBlocks> blocks that " ...
	      "either specify or inherit a continuous rate:\n\n%<blockList>"
	  %endif
	  %assign errTxt = errTxt + str
	  %<LibReportError(errTxt)>
	%endif
      %endif
    %endif %% temporary {ode1, ode2, ode3, ode4, ode5, ode8, fixedstepdiscrete}

    %% MAT-file logging and multi-instance ERT do not play well together.
    %if MultiInstanceERTCode && MatFileLogging && !UsingMalloc
      %selectfile STDOUT

      Note: The MAT-file logging code is not multi-instanced.  Deselect the
      MAT-file logging option.

      %selectfile NULL_FILE
    %endif

  %endif %% !IsModelReferenceForASimstructBasedTarget

  %if IsModelReferenceRTWTarget() && NumChildSFunctions && ...
    !::ModelReferenceSupportNoninlinedSfcn
    %assign errTxt = "\n\nModel reference RTWTarget does not support " ...
         "non-inlined s-functions.  "
    %<LibReportError(errTxt)>
  %endif
  
  %% ERTSfunction doesn't support External Mode
  %if (GenerateErtSFunction == 1) && ConfigSet.ExtMode == 1
    %assign errTxt = "\n\nThe ERT option to create a SIL block " ...
      "does not support Simulink External Mode."
    %<LibReportError(errTxt)>
  %endif

%endfunction %% SLibErtWideInit


%% Function: SLibErtSfunction ==================================================
%% Abstract:
%%   ertwide.tlc remnant.  Performs error checking an initial setup for
%%   Embedded-C code format
%%
%function SLibErtSfunction() void
  %assert(!IsModelReferenceTarget())
  %% ===========================================================================
  %% Optionally create timing_engine.h
  %%
  %if AutoBuildProcedure 
    %include "ertautobuild.tlc"
  %endif

  %% ===========================================================================
  %% Optionally create S-Function wrapper for ERT-C-Code
  %%
  %if GenerateErtSFunction == 1
    %include "ertsfcnbody.tlc"
  %else
     %% Generate the AUTOSAR RTE file if required
     %if SLibAutosarGenRTEHeader()
        %<DumpRTEFile()>
     %endif 
  %endif
%endfunction %% SLibErtSfunction


%% Function: SLibGenERTPrivateRTMMacros =================================
%% Abstract:
%%
%function SLibGenERTPrivateRTMMacros() void
  %if GenRTModel
    %openfile tmpBuf
    %<RTMGenMacroDefines("PRIVATE")>
    %closefile tmpBuf
    %openfile tmpDefBuf
    %if !WHITE_SPACE(tmpBuf)
      /* Private macros used by the generated code to access rtModel */
      %<tmpBuf>
    %endif
    %closefile tmpDefBuf
    %<SLibCacheCodeToFile("mdl_priv_macro_define", tmpDefBuf)>
  %endif
%endfunction

%% Function: SLibGenErtFunctionName =============================
%%
%%
%function SLibGenErtFunctionName(tid, fcnType)
  %if fcnType == "step"
    %assign fcnName = SLibModelStepFcnName("")
  %else
    %assign fcnName = "%<Name>_%<fcnType>"
  %endif
  %if TYPE(tid) == "Number" && tid < NumSynchronousSampleTimes
    %assign fcnName = "%<fcnName>%<tid>"
  %endif
  %return fcnName
%endfunction

%function SLibIsERTFunctionStatic() void
  %return  GenerateGRTWrapper && !ExtMode && NumContStates == 0
%endfunction

%% Function: SLibGenErtFunctionType =============================
%%
%%
%function SLibGenErtFunctionType() void
  %if SLibFcnProtoCtrlActive()
    %assign fcnData = FcnGetFunctionPrototypeRecord()
    %assign returnType = FcnModelStepFcnReturnCode(fcnData, "ReturnType")
  %elseif GenerateClassInterface
    %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
    %assign returnType = FcnModelStepFcnReturnCode(classConfObj, "ReturnType")
  %else
    %assign returnType = "void"
  %endif
  %if SLibIsERTFunctionStatic()
    %return "static %<returnType>"
  %elseif SLibAutosarCompilerAbstractionRequired()
    %return SLibAutosarCompilerAbstractionForFcnDeclRtnType(returnType, "FuncCalledByRTE")
  %else
    %return returnType
  %endif
%endfunction

%function SlibNeedExternRootSysRateGroupingFcn()
  %assign retValue = TLC_FALSE
  
  %if SLibIsERTCodeFormat() && SLibIsRateGrouping()
    %assign retValue = (GenerateSampleERTMain || RateBasedStepFcn) && ...
      (!SLibGenerateNativeThreads())
  %endif
  
  %return retValue
%endfunction

%function SLibNeedDumpRootSysPrototypeInPrivateHeader(fcnType,tid)
  %assign rootSys =  System[NumSystems-1]
  %assign rateGrouping = (TYPE(tid) == "Number") && ...
    SLibSystemFcnRateGrouping(rootSys,fcnType)
  
  %if rateGrouping
    %return !SlibNeedExternRootSysRateGroupingFcn() && ...
      !SLibIsERTFunctionStatic() && !GenerateClassInterface
  %else
    %% Non rate grouping fcn prototypes of root system are 
    %% dumped in model.h. Don't need dump in private.h
    %return TLC_FALSE
  %endif
%endfunction


%% blkStateChangeFlag may be set, need to run one more minor step
%%
%function SLibDumpOneMoreMinorOutput(fcnName, fcnArgType, tid)
  %openfile tempBuf
  %if ::CompiledModel.ModelBlocksUseBlkStateChange || ISFIELD(::CompiledModel, "HasStateChangeFlag") 
    %if (ISEQUAL(tid,0) || ISEQUAL(tid, "")) && (NumContStates > 0)
      /* BlkStateChangeFlag is set, need to run a minor output */ 
      if (%<RTMIs("MajorTimeStep")>) {
        if (%<RTMGetBlkStateChange()>) {
          rtsiSetSimTimeStep(%<RTMGetSolverInfo()>,MINOR_TIME_STEP);  
          %<RTMClearBlkStateChange()>;
          %<fcnName>(%<SLibModelFcnArgs(fcnArgType,2, 0)>);                            
          rtsiSetSimTimeStep(%<RTMGetSolverInfo()>, MAJOR_TIME_STEP);
        }    
      }
    %endif
  %endif
  %closefile tempBuf
  %return tempBuf
%endfunction

    
%% Function: SLibGenErtOutputFunction ====================================
%% Description:
%%    TYPE(tid) ==  number, generate rate grouping code
%%         tid >=0 and tid < NumSynchronousSampleTimes :
%%                          generate code for tid, %<mdlName>_output%<tid>
%%         tid == NumSynchronousSampleTimes :
%%                          generate main function wrapper %<mdlName>_output calling
%%                          all rate grouped function  %<mdlName>_output%<tid>
%%    tid == "", generate non rate grouping code, %<mdlName>_output
%%
%function SLibGenErtOutputFunction(tid)
  %assign rootSystem = System[NumSystems-1]
  %assign mdlName    = Name
  %assign buffsRec   = ::CompiledModel.CachedCodeBuffsForRootSys
  %assign isRateGrouping = SLibIsMultiRateAndRateGrouping(rootSystem)
  %assign fcnName    = SLibGenErtFunctionName(tid, "output")
  %assign fcnReturns    = SLibGenErtFunctionType()
  
  %if ISEQUAL(tid, NumSynchronousSampleTimes)
    %assign rootSystem.CurrentTID = ""
    %<LibSetGlobalSysFcnsForArgAccess("WrapperFcn")>
    %openfile tmpBuffer    
    %assign fcnParams = GetErtModelFcnArgs("Output",TLC_FALSE,"")
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Output"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnReturns> %<fcnName>(%<fcnParams>) {

      %% Profiler declaration code
      %<SLibGenProfSysDeclare(rootSystem, "Output")>

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "Output")>

      %% If concurrent tasks, tid is the task index, and generates code like:
      %% switch (tid) case 0: ...
      %%              case 1: ...
      %%              case 2: ...
      %% Otherwise, tid is the sample time index, and generates code like:
      %% switch (tid) case 0: ...  %% if TID01EQ, skips case 1
      %%              case 2: ... 
      %%              case 3: ...   
      switch(%<::CompiledModel.GlobalScope.tTID>) {
	%foreach tidIdx = NumSynchronousSampleTimes
          %if (FixedStepOpts.TID01EQ && tidIdx == 1 && !SLibConcurrentTasks()) ...
            || (ISEQUAL(tidIdx, NumSynchronousSampleTimes -1) && ...
            SLibConcurrentTasks() && FixedStepOpts.TID01EQ)
            %continue
	  %endif
	  case %<tidIdx> :  
          %if !SLibConcurrentTasks() || !(FixedStepOpts.TID01EQ && tidIdx>0)
            %assign rootSystem.CurrentTID = tidIdx
            %<mdlName>_output%<tidIdx>(%<GetErtModelFcnArgs("Output",2,tidIdx)>);
          %else
            %assign rootSystem.CurrentTID = tidIdx + 1 
            %<mdlName>_output%<tidIdx+1>(%<GetErtModelFcnArgs("Output",2,tidIdx+1)>);
          %endif 
          break;
        %endforeach
	default :
	break;
      }
      %% Profiler finish code
      %<SLibGenProfSysEnd(rootSystem, "Output")>
     }
     %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %closefile tmpBuffer
    %<LibSetGlobalSysFcnsForArgAccess("")>
    %assign rootSystem.CurrentTID = -1
    %return(tmpBuffer)
  %else
    %assign  rootSystem.CurrentTID = tid
    %with rootSystem
    %assign needMajorTimeGuard = NumContStates > 0
    %openfile tmpBuffer
    %if !isRateGrouping
      %assign fcnAbstract = "Model output function"
    %else
      %assign fcnAbstract = "Model output function for TID%<tid>"
    %endif
    %assign ::BlockFcn = "Output"
    %assign timingCodeBuf = ...
      ErtOrModelrefGetTimingForTopOfOutputFcn(rootSystem, tid)
    %openfile fcnProtoType
    %assign fcnParams = SLibModelFcnArgs("Output",TLC_FALSE,tid)
    %<fcnReturns> %<fcnName>(%<fcnParams>)\
    %closefile fcnProtoType
    %if SLibNeedDumpRootSysPrototypeInPrivateHeader("Output", tid)
      %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
    %endif
    %openfile outputCode
    %if (!ISEQUAL(tid, 0) || ISEQUAL(tid, "")) && ...
      LibSystemFcnIsEmptyForTID(rootSystem,"Output") && ...
      WHITE_SPACE(timingCodeBuf)
      /* (no output code required) */

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "Output")>

    %else
      %<SLibDumpLocalTidInSystem(rootSystem, "Output")>
      %<LibGetSystemLocalVars(rootSystem, "Output", tid)>
      %<SLibGetFcnLocalVars(rootSystem, "Output", tid)>

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "Output")>

      %<LibDumpSystemUserCode(rootSystem,"Output","Header")>\
      %if !WHITE_SPACE(timingCodeBuf)
        
        %<timingCodeBuf>      
      %endif
      
      %if (ISEQUAL(tid,0) || ISEQUAL(tid, ""))
        %if ISFIELD(buffsRec,"ExtModeHeader") && !WHITE_SPACE(buffsRec.ExtModeHeader)
          
          /* external mode */
          %<buffsRec.ExtModeHeader>\
        %endif
      %endif
      
      %<LibDumpSystemUserCode(rootSystem,"Output","Body")>\
      %<LibDumpSystemFcn(rootSystem,"Output%<tid>")>\
      %<LibDumpSystemUserCode(rootSystem,"Output","Trailer")>\
    %endif
    %if ISEQUAL(tid,0) || ISEQUAL(tid, "")
      %if ISFIELD(buffsRec,"LogBuffer") && !WHITE_SPACE(buffsRec.LogBuffer)
        
        /* logging */
        %if needMajorTimeGuard
          if (%<RTMIs("MajorTimeStep")>) {
        %endif
        %<buffsRec.LogBuffer>\
        %if needMajorTimeGuard
          } /* end MajorTimeStep */
        %endif
      %endif
    %endif     
    %%
    %<FcnHandlesUnusedTIDArg(rootSystem, "Output")>
    %%
    %closefile outputCode
    %if WHITE_SPACE(outputCode)
      %assign outputCode = "/* (no output code required) */"
    %endif
    %openfile fcnContent

    %% Profiler declaration code
    %<SLibGenProfSysDeclare(rootSystem, "Output")>
    
    %<outputCode>
    
    %% Profiler finish code
    %<SLibGenProfSysEnd(rootSystem, "Output")>

    %closefile fcnContent
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Output"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnProtoType> %<LibTaskComment(tid)>
    {
      %<fcnContent>
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %closefile tmpBuffer
    %assign rootSystem.CurrentTID = -1
    %endwith
    %return(tmpBuffer)
  %endif
%endfunction %% SLibGenErtOutputFunction(tid)

%% Function: SLibGenErtUpdateFunction ====================================
%% Description:
%%    TYPE(tid) ==  number, generate rate grouping code
%%         tid >=0 and tid < NumSynchronousSampleTimes :
%%                          generate code for tid, %<mdlName>_update%<tid>
%%         tid == NumSynchronousSampleTimes :
%%                          generate main function wrapper %<mdlName>_update calling
%%                          all rate grouped function  %<mdlName>_update%<tid>
%%    tid == "", generate non rate grouping code, %<mdlName>_update
%%
%% Function: SLibGenErtUpdateFunction ======================================
%function SLibGenErtUpdateFunction(tid)
  %assign rootSystem = System[NumSystems-1]
  %assign mdlName    = Name
  %assign buffsRec   = ::CompiledModel.CachedCodeBuffsForRootSys
  %assign isRateGrouping = SLibSystemFcnRateGrouping(rootSystem, "Update")
  %assign fcnName    = SLibGenErtFunctionName(tid, "update")
  %assign fcnReturns = SLibGenErtFunctionType()

  %if ISEQUAL(tid, NumSynchronousSampleTimes)
    %assign rootSystem.CurrentTID = ""
    %openfile tmpBuffer
    %assign fcnParams = GetErtModelFcnArgs("Update",TLC_FALSE,"")
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Update"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnReturns> %<fcnName>(%<fcnParams>) {

      %% Profiler declaration code
      %<SLibGenProfSysDeclare(rootSystem, "Update")>

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "Update")>
      
      %% If concurrent tasks, tid is the task index, and generates code like:
      %% switch (tid) case 0: ...
      %%              case 1: ...
      %%              case 2: ...
      %% Otherwise, tid is the sample time index, and generates code like:
      %% switch (tid) case 0: ...  %% if TID01EQ, skips case 1
      %%              case 2: ... 
      %%              case 3: ...
      switch(%<::CompiledModel.GlobalScope.tTID>) {
        %foreach tidIdx = NumSynchronousSampleTimes
          %if (FixedStepOpts.TID01EQ && tidIdx == 1 && !SLibConcurrentTasks()) ...
            || (ISEQUAL(tidIdx, NumSynchronousSampleTimes -1) && ...
            SLibConcurrentTasks() && FixedStepOpts.TID01EQ)
            %continue
          %endif
          case %<tidIdx> :
          %if !SLibConcurrentTasks() || !(FixedStepOpts.TID01EQ && tidIdx>0)
            %assign rootSystem.CurrentTID = tidIdx
            %<mdlName>_update%<tidIdx>(%<GetErtModelFcnArgs("Update",2,tidIdx)>);
          %else
            %assign rootSystem.CurrentTID = tidIdx + 1 
            %<mdlName>_update%<tidIdx+1>(%<GetErtModelFcnArgs("Update",2,tidIdx+1)>);
          %endif 
          break;
        %endforeach
        default :
        break;
      }

      %% Profiler finish code
      %<SLibGenProfSysEnd(rootSystem, "Update")>
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %closefile tmpBuffer
    %assign rootSystem.CurrentTID = -1
    %return(tmpBuffer)
  %else
    %assign recursivefcnName    =  SLibGenErtFunctionName(tid, "output")
    %with rootSystem
    %assign rootSystem.CurrentTID = tid
    %assign continuousUpdate = ...
        (ISEQUAL(tid,0) || ISEQUAL(tid, "")) && (NumContStates > 0)
    %openfile tmpBuffer
    %if !isRateGrouping
      %assign fcnAbstract = "Model update function"
    %else
      %assign fcnAbstract = "Model update function for TID%<tid>"
    %endif
    %openfile fcnProtoType
    %if continuousUpdate
      %assign fcnParams = SLibModelFcnArgs("UpdateContStates",TLC_FALSE,tid)
    %else
      %assign fcnParams = SLibModelFcnArgs("RootUpdate",TLC_FALSE,tid)
    %endif
    %<fcnReturns> %<fcnName>(%<fcnParams>)\
    %closefile fcnProtoType
    %if SLibNeedDumpRootSysPrototypeInPrivateHeader("Update", tid)
      %<LibAddToSystemField(rootSystem, "SystemFcnPrototype","%<fcnProtoType>;")>
    %endif
    %openfile updateCode 
    %<SLibDumpLocalTidInSystem(rootSystem, "Update")>
    %<LibGetSystemLocalVars(rootSystem,"Update",tid)>
    %<SLibGetFcnLocalVars(rootSystem,"Update",tid)>
    %<LibDumpSystemUserCode(rootSystem,"Update","Header")>\
    %<LibDumpSystemUserCode(rootSystem,"Update","Body")>\    
    %<LibDumpSystemFcn(rootSystem,"Update%<tid>")>\
    %% blkStateChangeFlag may be set, need to run one more minor step
    %% 
    %<SLibDumpOneMoreMinorOutput(recursivefcnName, "Output", tid)>\
    %<LibDumpSystemUserCode(rootSystem,"Update","Trailer")>\
    %if ISFIELD(buffsRec,"ExtModeTrailer%<tid>") && ...
      !WHITE_SPACE(buffsRec.ExtModeTrailer%<tid>)
      
      /* external mode */
      %assign tmpBuff = buffsRec.ExtModeTrailer%<tid>
      %<tmpBuff>\
    %endif
    %<ErtOrModelrefGetTimingForBottomOfUpdateFcn(rootSystem, tid, TLC_TRUE)>
    %<FcnHandlesUnusedTIDArg(rootSystem, "Update")>
    %closefile updateCode
    %%
    %if WHITE_SPACE(updateCode)
      %assign updateCode = "/* (no update code required) */"
    %endif
    %%
    %openfile fcnContent

    %% Profiler declaration code
    %<SLibGenProfSysDeclare(rootSystem, "Update")>
    
    %% Profiler start code
    %<SLibGenProfSysStart(rootSystem, "Update")>
    
    %<updateCode>
    
    %% Profiler finish code
    %<SLibGenProfSysEnd(rootSystem, "Update")>
    
    %closefile fcnContent
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Update"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnProtoType> %<LibTaskComment(tid)>
    {
      %<fcnContent>
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %if continuousUpdate
      %% generate root system Derivative function
      %<SLibGetBodyDerivativeFcnCache(rootSystem)>
    %endif
    %closefile tmpBuffer
    %assign rootSystem.CurrentTID = -1
    %endwith
    %return tmpBuffer
  %endif
%endfunction %% SLibGenErtUpdateFunction(tid)

%% Function: SLibGenErtOutputUpdateFunction =====================================
%% Description:
%%    TYPE(tid) ==  number, generate rate grouping code
%%         tid >=0 and tid < NumSynchronousSampleTimes :
%%                          generate code for tid, %<mdlName>_step%<tid>
%%         tid == NumSynchronousSampleTimes :
%%                          generate main function wrapper %<mdlName>_step calling
%%                          all rate grouped function  %<mdlName>_step%<tid>
%%    tid == "", generate non rate grouping code, %<mdlName>_step
%%
%function SLibGenErtOutputUpdateFunction(tid)
  %assign tmpBlockFcn = ::BlockFcn
  %assign ::BlockFcn = "OutputUpdate"  
  %assign rootSystem = System[NumSystems-1]
  %assign mdlName    = Name
  %assign buffsRec = ::CompiledModel.CachedCodeBuffsForRootSys
  %assign isRateGrouping = SLibSystemFcnRateGrouping(rootSystem, "OutputUpdate")
  %if !GenerateClassInterface
    %assign fcnName    = SLibGenErtFunctionName(tid, "step")
  %else
    %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
    %if SLibSingleTasking()
      %assign fcnName =   "%<classConfObj.ModelClassName>::%<classConfObj.FunctionName>" 
    %else %%MR/MT, must be void-void case
      %assign fcnName =   "%<classConfObj.ModelClassName>::%<classConfObj.FunctionName>%<tid>" 
    %endif
  %endif
  %assign fcnReturns  = SLibGenErtFunctionType()

  %if ISEQUAL(tid, NumSynchronousSampleTimes)
    %assign rootSystem.CurrentTID = ""
    %openfile tmpBuffer
    %assign fcnParams = GetErtModelFcnArgs("OutputUpdate",TLC_FALSE,"")
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
      Category "model"; GeneratedBy "ertlib.tlc:SLibGenErtOutputUpdateFunction"; ...
      Type "Output and update"; GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnReturns> %<fcnName>(%<fcnParams>) {

      %% Profiler declaration code
      %<SLibGenProfSysDeclare(rootSystem, "OutputUpdate")>

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "OutputUpdate")>
      
      %% If concurrent tasks, tid is the task index, and generates code like:
      %% switch (tid) case 0: ...
      %%              case 1: ...
      %%              case 2: ...
      %% Otherwise, tid is the sample time index, and generates code like:
      %% switch (tid) case 0: ...  %% if TID01EQ, skips case 1
      %%              case 2: ... 
      %%              case 3: ...
      switch(%<::CompiledModel.GlobalScope.tTID>) {
	%foreach tidIdx = NumSynchronousSampleTimes
	  %if (FixedStepOpts.TID01EQ && tidIdx == 1 && !SLibConcurrentTasks()) || ...
            (ISEQUAL(tidIdx, NumSynchronousSampleTimes -1) && SLibConcurrentTasks()...
            && FixedStepOpts.TID01EQ)
	    %continue
	  %endif
	  case %<tidIdx> :
          %if !SLibConcurrentTasks() || !(FixedStepOpts.TID01EQ && tidIdx>0)
            %assign rootSystem.CurrentTID = tidIdx
            %<SLibModelStepFcnName(tidIdx)>(%<GetErtModelFcnArgs("OutputUpdate",2,tidIdx)>);
          %else
            %assign rootSystem.CurrentTID = tidIdx + 1
            %<SLibModelStepFcnName(tidIdx+1)>(%<GetErtModelFcnArgs("OutputUpdate",2,tidIdx+1)>);
          %endif
          break;
	%endforeach
	default :
	break;
      }
      %% Profiler finish code
      %<SLibGenProfSysEnd(rootSystem, "OutputUpdate")>
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %closefile tmpBuffer
    %assign rootSystem.CurrentTID = -1
    %return(tmpBuffer)
  %else
    %with rootSystem
    %assign rootSystem.CurrentTID = tid
    %assign needMajorTimeGuard = (NumContStates > 0)
    %assign continuousUpdate = ...
          (ISEQUAL(tid,0) || ISEQUAL(tid, "")) && (NumContStates > 0)
    %openfile tmpBuffer
    %if !isRateGrouping
      %assign fcnAbstract = "Model step function"
    %else
      %assign fcnAbstract = "Model step function for TID%<tid>"
    %endif
    %assign timingCodeBuf = ...
      ErtOrModelrefGetTimingForTopOfOutputFcn(rootSystem, tid)
    %openfile fcnProtoType
    %if continuousUpdate
      %assign fcnParams = SLibModelFcnArgs("UpdateContStates",TLC_FALSE,tid)
    %else
      %assign fcnParams = SLibModelFcnArgs("OutputUpdate",TLC_FALSE,tid)
    %endif
    %<fcnReturns> %<fcnName>(%<fcnParams>)\
    %closefile fcnProtoType
    %if SLibNeedDumpRootSysPrototypeInPrivateHeader("OutputUpdate",tid)
      %assign sysFcnDecl = LibExternInFcnDecls() + fcnProtoType + ";"
      %<LibAddToSystemField(rootSystem, "SystemFcnPrototype", sysFcnDecl)>
    %endif
    %openfile fcnContent
      %if GenerateClassInterface
        %% We know we are in a member function body, so set the cpp object name to be
        %% this. Will restore it to its original name when finishing constructing 
        %% this function body.
        %assign backUpCPPObjectName = ::CPPObjectName
        %assign ::CPPObjectName = "this"
      %endif
      
      %assign localOutputVars = SLibGetFcnLocalVars(rootSystem, "Output", tid)
      %assign localUpdateVars = SLibGetFcnLocalVars(rootSystem, "Update", tid)
      %assign needBraces = !ISEMPTY(localOutputVars) && !ISEMPTY(localUpdateVars)
      %openfile outputUpdateCode
      %<SLibDumpLocalTidInSystem(rootSystem, "OutputUpdate")>
      %<LibGetSystemLocalVars(rootSystem, "Output", tid)>
      %if !needBraces
        %<localOutputVars>
        %<localUpdateVars>
      %endif
      %if SLibFcnProtoCtrlActive()
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %<FcnModelStepFcnReturnCode(fcnData, "ReturnDeclaration")>
        %<FcnModelStepBufferInputsCode(fcnData)>
      %elseif GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %if classConfObj.hasReturnValue
          %<FcnModelStepFcnReturnCode(classConfObj, "ReturnDeclaration")>
        %endif
        %<FcnModelStepBufferInputsCode(classConfObj)>
      %endif

      %% Profiler start code
      %<SLibGenProfSysStart(rootSystem, "OutputUpdate")>

      %<LibDumpSystemUserCode(rootSystem,"Output","Header")>\
      %% If absolute time is accessed by this TID,
      %% maintain absolute timer for this TID, otherwise
      %% don't need absolute timer
      %if !WHITE_SPACE(timingCodeBuf)
        
        %<timingCodeBuf>      
      %endif
      
      %if ISEQUAL(tid, "") || ISEQUAL(tid, 0)
        %if ISFIELD(buffsRec,"ExtModeHeader") && !WHITE_SPACE(buffsRec.ExtModeHeader)
          
          %<buffsRec.ExtModeHeader>\
        %endif
      %endif
      %<LibDumpSystemUserCode(rootSystem,"Output","Body")>\
      %if needBraces && !ISEMPTY(localOutputVars)
        %<"{">
        %<localOutputVars>
      %endif
      %<LibDumpSystemFcn(rootSystem,"Output%<tid>")>\
      %if needBraces && !ISEMPTY(localOutputVars)
        %<"}">
      %endif    
      %<LibDumpSystemUserCode(rootSystem,"Output","Trailer")>\
      %if ISEQUAL(tid, "") || ISEQUAL(tid, 0)
        %if ISFIELD(buffsRec,"LogBuffer") && !WHITE_SPACE(buffsRec.LogBuffer)
          %assign needMajorTimeGuard = NumContStates > 0

	  %if needMajorTimeGuard
	    if (%<RTMIs("MajorTimeStep")>) {
	  %endif
	  %<buffsRec.LogBuffer>\
	  %if needMajorTimeGuard
	     } /* end MajorTimeStep */
	  %endif
	%endif
      %endif
      
      %% Generate Update code for step
      %openfile updateCode 
      %if !LibSystemUserCodeIsEmpty(rootSystem, "Update", "Header")
        %<"{">
        %<LibDumpSystemUserCode(rootSystem,"Update","Header")>\
      %endif
      %<LibDumpSystemUserCode(rootSystem,"Update","Body")>\
      %if needBraces && !ISEMPTY(localUpdateVars)
        %if !continuousUpdate
          %<"{">
        %endif
        %<localUpdateVars>
      %endif
      %<LibDumpSystemFcn(rootSystem,"Update%<tid>")>\
      %if needBraces && !ISEMPTY(localUpdateVars) && !continuousUpdate
        %<"}">
      %endif    
      %%
      %% blkStateChangeFlag may be set, need to run one more minor step
      %%      
      %<SLibDumpOneMoreMinorOutput(fcnName, "UpdateContStates", tid)>\                
      %<LibDumpSystemUserCode(rootSystem,"Update","Trailer")>\
      %if !LibSystemUserCodeIsEmpty(rootSystem, "Update", "Header")
        %<"}">
      %endif
      %if ISFIELD(buffsRec,"ExtModeTrailer%<tid>") && ...
        !WHITE_SPACE(buffsRec.ExtModeTrailer%<tid>)
        %assign tmpBuff = buffsRec.ExtModeTrailer%<tid>
        %<tmpBuff>\
      %endif
      %closefile updateCode 
      
      %if !WHITE_SPACE(updateCode)
        %if continuousUpdate
          if (%<RTMIs("MajorTimeStep")>) {
            %<updateCode>
          } /* end MajorTimeStep */
        %else
          %<updateCode>
        %endif
      %endif
      
      %if !GenerateGRTWrapper 
        %% Update timer here only if we don't generate grt interface.
        %% For grt interface, time must be updated in
        %% mdlUpdatefcn.
        %<ErtOrModelrefGetTimingForBottomOfUpdateFcn(rootSystem, tid, TLC_FALSE)>
      %endif
      %if !GenerateClassInterface
        %<FcnHandlesUnusedTIDArg(rootSystem, "Output")>
      %endif
      %closefile outputUpdateCode

      %openfile returnStatement
      %if SLibFcnProtoCtrlActive()
        %assign fcnData = FcnGetFunctionPrototypeRecord()
        %<FcnModelStepBufferOutputsCode(fcnData)>
        %<FcnModelStepFcnReturnCode(fcnData,"ReturnStatement")>
      %elseif GenerateClassInterface
        %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
        %<FcnModelStepBufferOutputsCode(classConfObj)>
        %<FcnModelStepFcnReturnCode(classConfObj,"ReturnStatement")>
      %endif
      %closefile returnStatement

      %if WHITE_SPACE(outputUpdateCode)
        %assign outputUpdateCode = "/* (no output/update code required) */"
      %endif
      %% Profiler declaration code
      %<SLibGenProfSysDeclare(rootSystem, "OutputUpdate")>
      
      %<outputUpdateCode>
      
      %% Profiler finish code
      %<SLibGenProfSysEnd(rootSystem, "OutputUpdate")>
      %<returnStatement>

      %if GenerateClassInterface
        %% We know we have finished constructing a member function body, so
        %% we restore the object name to be its original name as promised.
        %assign ::CPPObjectName = backUpCPPObjectName
      %endif
    %closefile fcnContent
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract fcnAbstract; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Step"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnProtoType> %<LibTaskComment(tid)>  
    {
      %<fcnContent>
    } %% end of combined output/update fcn
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
    %if continuousUpdate
      %% generate root system Derivative function
      %<SLibGetBodyDerivativeFcnCache(rootSystem)>
    %endif
    %%
    %closefile tmpBuffer
    %assign rootSystem.CurrentTID = -1
    %endwith
    %assign ::BlockFcn = tmpBlockFcn
    %return(tmpBuffer)
  %endif
%endfunction %% SLibGenErtOutputUpdateFunction

%% Function:  LibDumpExpFucUpdateRootOutput =====================================
%% Description:
%%  This function is only called when ExportFunctionsMode == 1.
%%  This function generates data push to root outport blocks from exported
%%  functions outputs if necessary.
%function LibDumpExpFucUpdateRootOutput(currentSys,fcnType) Output
  %if ExportFunctionsMode != 1 || SLibAutosarActive() || currentSys.Exported != "yes"
    %return 
  %endif  
  %assign rootSystem = System[NumSystems-1]
  %with rootSystem
    %if NumModelOutputs > 0  && ...
      ISFIELD(currentSys, "ExternalOutputs")
      %foreach idx = SIZE(currentSys.ExternalOutputs, 1)
        %assign extOut       = ExternalOutputs.ExternalOutput[currentSys.ExternalOutputs[idx]]
        %assign sysIdx       = extOut.Block[0]
        %assign blkIdx       = extOut.Block[1]
        %assign outportBlock = System[sysIdx].Block[blkIdx]
        %if !SLibExternalOutputIsVirtual(outportBlock)
          %% %if fcnType == "OutputUpdate" && ...
          %%  LibAsynchronousTriggeredTID(outportBlock.TID) && ...
          %%  SampleTime[outportBlock.TID].IsUnionTs == "yes"
            %% Root output port code have been generated and dumpped for async ts in 
            %% system, OutputUpdateFcn. No need dump again here. 
            %% 
          %%  %continue
          %%%endif
          %with outportBlock
            %% This following code is cloned from block/outport.tlc Output function
            %assign ExtOutRollReg = ISFIELD(currentSys, "NumExternalOutputRollRegions") ? ...
              currentSys.ExternalOutputRollRegion[idx].Elements : RollRegions
            %assign rollVars = ["outportblk", "U"]
            %roll sigIdx = ExtOutRollReg, lcv = RollThreshold, outportBlock, "Roller", rollVars
              %<LibBlockDstSignalLocation("outportblk", "", lcv, sigIdx)> ...
                = %<LibBlockInputSignal(0, "", lcv, sigIdx)>;
            %endroll
          %endwith
        %endif
      %endforeach
    %endif      
  %endwith
%endfunction

%% Fucntion: SLibErtGenLoggingUpdateCode =========================
%%
%%
%function SLibErtGenLoggingUpdateCode(buffsRec, isRateGrouping) void
  %assign ::BlockFcn = "Output"
  %openfile logBuffer
  %if MatFileLogging == 1 && !GenerateGRTWrapper
    %assign rootSystem = System[NumSystems-1]
    %assign rootSystem.CurrentTID = 0 
    /* Matfile logging */
    %if RootSystemIsSingleRate || SLibSingleTasking() || ...
      isRateGrouping
      %<SLibGenTXYLogVarUpdate()>
      %<SLibGenSigLogVarUpdate()>
      %if isRateGrouping
	%% The logging code is added to the tid01eq output code when
	%% rate grouping. Make sure the necessary arguments are passed.
	%% Add to output or outputupdate
	%assign arg = ::CompiledModel.System[NumSystems-1].Interface.RTMArgDef
	%if CombineOutputUpdateFcns == 1
	  %assign ::BlockFcn = "OutputUpdate"
	%endif
	%<SLibAddTIDtoAccessTIDList(arg, ::BlockFcn, "", FixedStepOpts.TID01EQ)>
	%assign ::BlockFcn = "Output"
      %endif
    %else
      %<FcnGenerateTidGuardOpenCode(0)>
      %<SLibGenTXYLogVarUpdate()>
      %<SLibGenSigLogVarUpdate()>
      %<FcnGenerateTidGuardCloseCode(0)>
    %endif
    %assign rootSystem.CurrentTID = -1
  %endif
  %closefile logBuffer
  %addtorecord buffsRec LogBuffer logBuffer

%endfunction %% SLibErtGenLoggingUpdateCode

%% Function: SLibErtGenStopSimCode(buffsRec) ======================
%%
%%
%function SLibErtGenStopSimCode(buffsRec, isRateGrouping) void
  %assign ::BlockFcn = "RootUpdate"
  %assign rootSystem = System[NumSystems-1]
  %assign rootSystem.CurrentTID = 0
  %openfile stopSimBuffer
  %if !IsModelReferenceTarget() && !GenerateGRTWrapper
    %if MatFileLogging || (ExtMode && !PurelyIntegerCode)

      /* signal main to stop simulation */
      %<FcnGenerateTidGuardOpenCode(0)>
      %% Since you can't have PurelyIntegerCode while MatFileLogging,
      %% only need to handle real_T time.
      %% If continuous time, use taskTime(TID01EQ), otherwise taskTime(0)
      %assign taskTime = (NumContStates > 0) ? ...
          LibGetTaskTime(FixedStepOpts.TID01EQ) : LibGetTaskTime(0)
      if ( (%<RTMGet("TFinal")>!=-1) &&
      !((%<RTMGet("TFinal")>-%<taskTime>) > %<taskTime> * ...
        %<LibGetMathConstant("EPSILON",tSS_DOUBLE)>)) {
        %<RTMSetErrStat("\"Simulation finished\"")>;
      }
      %if ExtMode || NumChildSFunctions
	if (%<RTMGetStopRequested()>) {
	  %<RTMSetErrStat("\"Simulation finished\"")>;
	}
      %endif
      %<FcnGenerateTidGuardCloseCode(0)>
    %elseif ExtMode && PurelyIntegerCode

      if ( (rteiGetTFinalTicks(%<RTMGet("RTWExtModeInfo")>)!=-1) &&
      !((uint32_T)rteiGetTFinalTicks(%<RTMGet("RTWExtModeInfo")>) >
      %<LibGetTaskTime(0)>)) {
	%<RTMSetErrStat("\"Simulation finished\"")>;
      }
      %if ExtMode
	if (%<RTMGetStopRequested()>) {
	  %<RTMSetErrStat("\"Simulation finished\"")>;
	}
      %endif
    %endif
    %% Issue warning if TFinal is longer than LifeSpan. Timer may overflow
    %% before reach TFinal. Model may runs forever.
    %assign stopTime = SLibERTGetStopTime()
    %assign lifeSpanInSeconds = ::CompiledModel.ConfigSet.EvaledLifeSpan * 86400
    %if stopTime > lifeSpanInSeconds
      %assign warnTxt = "Stop time %<stopTime> (seconds) is out the range of "...
        "Application life span %<::CompiledModel.ConfigSet.EvaledLifeSpan> (days). "...
        "Generated code may fail to stop because timer can overflow before the stop time is reached. "...
        "Consider choosing smaller 'Stop time' on Solver pane, or longer "...
        "'Application life span' on Optimization pane."
      %<LibReportWarning(warnTxt)>
    %endif
  %endif
  %closefile stopSimBuffer
  %assign rootSystem.CurrentTID = -1

  %addtorecord buffsRec StopSimBuffer stopSimBuffer
%endfunction %% SLibErtGenStopSimCode(buffsRec)


%function SLibErtGenFirstInitConditionCode(buffsRec) void
  %assign ::BlockFcn = "RootUpdate"
  %openfile firstInitCondition
  %if RTMFirstInitCondFlagIsReqFcn()
    %% Need to turn off firstInitCond flag
    /* set "at time zero" to false */
    if (%<RTMIs("FirstInitCond")>) {
      %<RTMSet("FirstInitCond", 0)>;
    }
  %endif
  %closefile   firstInitCondition
  %addtorecord buffsRec FirstInitCondition firstInitCondition
%endfunction

%function  ErtGenerateOutputAndUpdateForRoot()
  %assign tmpBlockFcn = ::BlockFcn
  %assign ::BlockFcn = "OutputUpdate"
  %assert (!IsModelReferenceTarget())

  %assign rootSystem = System[NumSystems-1]
  %assign isRateGrouping = SLibIsMultiRateAndRateGrouping(rootSystem)
    
  %if GenerateSampleERTMain && SLibIsAsyncTaskOnlyModel() && ...
    !LibIsDeploymentDiagram()
    %return ""
  %endif

  %openfile buff
  %% %% -SAM- If SAM active and all "step" code is inlined in runAlgo, don't output anything here.
  %% For now, hardcode until we have implemented support functions.
  %% %if LibSamActive() && LibSamStepsInlined()
  %if LibSamActive()
    %% Nothing to do.
  %elseif LibIsDeploymentDiagram()
    %<SLibDeploymentGenerateOutputAndUpdate()>
  %elseif isRateGrouping
    %% -------------------------------------------------------
    %%   Generate rate grouping  code for ert auto functions.
    %if GenerateGRTWrapper
      %assign genLocalMain = 1
    %elseif (GenerateSampleERTMain || RateBasedStepFcn) && ...
      (!SLibConcurrentTasks())
      %% if generateSampleERTMain, not step main fcn generated in model.c,
      %% it is generated in SampleERTMain fucntion.
      %assign genLocalMain = 0
    %else
      %assign genLocalMain = 1
    %endif
    %foreach TIDIdx = NumSynchronousSampleTimes + genLocalMain
      %if ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ && (TIDIdx==1)
        %continue
      %endif
      %assign rootSystem.CurrentTID = TIDIdx
      %if CombineOutputUpdateFcns == 1

	%<SLibGenErtOutputUpdateFunction(TIDIdx)>
      %else

	%<SLibGenErtOutputFunction(TIDIdx)>

	%<SLibGenErtUpdateFunction(TIDIdx)>
	%% end of seperate output/update fcn
      %endif
    %endforeach
    %%   end of Generate rate grouping  code for ert auto functions.
    %% -----------------------------------------------------------
  %else
    %%   Generate non-rate-grouping  code for ert auto functions.
    %%
    %% When FcnUsingModulesToGenerateCode, non-rate-grouping code 
    %% is put with tid0
    %%
    %assign currentTid = SLibSystemFcnRateGrouping(rootSystem, "Output") ? 0:""
    %assign rootSystem.CurrentTID = currentTid
    %if CombineOutputUpdateFcns == 1

      %<SLibGenErtOutputUpdateFunction(currentTid)>
    %else

      %<SLibGenErtOutputFunction(currentTid)>

      %<SLibGenErtUpdateFunction(currentTid)>
    %endif
    %%   end of Generate non-rate grouping  code for ert auto functions.  .
    %%----------------------------------------------------------------
  %endif
  %if GenerateGRTWrapper
    %assign ::CompiledModel.GRTWrapper = ::CompiledModel.GRTWrapper + ...
      FcnGenerateGRTOutputUpdateWrapper()
  %endif

  %closefile buff
  %assign ::BlockFcn = tmpBlockFcn
  %return buff
%endfunction

%% Function: FcnGenerateInitializeSizes ====================================
%%   This function is called when if generate grt wrapper and one 
%%   of the followings is Not true
%%    GenerateSampleERTMain 
%%    SLibIsAsyncTaskOnlyModel
%%
%function FcnGenerateInitializeSizes()
  %openfile tmpBuf  
  %assign fcnName = "MdlInitializeSizes"
  %assign fcnReturns = "%<SLibGetGRTWrapperLinkage()> void"
  %assign fcnParams = "void"
  %assign rootSystem = System[NumSystems-1]
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
    Category "model"; GeneratedBy "ertlib.tlc"; Type "Initialize"; ...
    GeneratedFor FcnGeneratedFor(rootSystem)}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\  
  %<fcnReturns> %<fcnName>(%<fcnParams>) {
    %<LibDumpModelInitializeSizes()>\
  }
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% Function: FcnGenerateGRTOutputUpdateWrapper ====================================
%%   This function is called when GenerateGRTWrapper is true.
%%
%%
%function FcnGenerateGRTOutputUpdateWrapper()
  %assign mdlName = Name
  %assign rootSystem = System[NumSystems-1]
  %assign rootSystem.CurrentTID = ""

  %assert CombineOutputUpdateFcns == 0
  %openfile tmpBuf
  %% MdlOutput MdlUpdate
  %assign needAdjustTID = !SLibSingleTasking() && ...
    !LibIsSingleRateSystem(rootSystem) && ...
    ISEQUAL(SolverType, "FixedStep") && FixedStepOpts.TID01EQ

  %if needAdjustTID
    %openfile adjustTID
    if (%<LibTID()> == 1) %<LibTID()> = 0;
    %closefile adjustTID
  %else
    %assign adjustTID = ""
  %endif
  %assign ::SystemFcnsForArgAccess = "WrapperFcn"

    %assign fcnName = "MdlOutputs"
    %if UsingMalloc
      %assign arg = "%<tSimStructType>* %<tSimStruct>, int_T %<::CompiledModel.GlobalScope.tTID>"
    %else
      %assign arg = "int_T %<::CompiledModel.GlobalScope.tTID>"
    %endif
    %assign fcnReturns = "%<SLibGetGRTWrapperLinkage()> void"
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params arg; Abstract ""; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Output"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnReturns> %<fcnName>(%<arg>) {
      %if !LibIsDeploymentDiagram() && !SLibConcurrentTasks()
      %<adjustTID>
      %endif
      %if CombineOutputUpdateFcns == 1
        %<SLibModelStepFcnName("")>(%<SLibModelFcnArgs("OutputUpdate",TLC_TRUE,"%<tTID>")>);
      %else
        
        %<mdlName>_output(%<SLibModelFcnArgs("Output",TLC_TRUE,"%<tTID>")>);
      %endif
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\
       
    %assign fcnName = "MdlUpdate"
    %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params arg; Abstract ""; ...
      Category "model"; GeneratedBy "ertlib.tlc"; Type "Output"; ...
      GeneratedFor FcnGeneratedFor(rootSystem)}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Pre")>\
    %<fcnReturns> %<fcnName>(%<arg>) {
      %% GRT interface requires updating timer in MdlUpdate function.
      %if !LibIsDeploymentDiagram() && !SLibConcurrentTasks()
      %<adjustTID>
      %endif
      %if CombineOutputUpdateFcns == 1
        %<ErtOrModelrefGetTimingForBottomOfUpdateFcn(rootSystem, "", TLC_FALSE)>
      %else
        %if UsingMalloc
        
        %<mdlName>_update(%<SLibModelFcnArgs("RootUpdate",TLC_TRUE,"%<tTID>")>);
        %else
        %<mdlName>_update(%<SLibModelFcnArgs("Update",TLC_TRUE,"%<tTID>")>);
        %endif
      %endif
    }
    %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncExecute", "Post")>\

  %% Others Mdl function called from grt_main.
  %if UsingMalloc
    %assign arg = "%<tSimStructType>* %<tSimStruct>"
  %else
    %assign arg = "void"
  %endif
  
  %assign fcnName = "MdlInitializeSizes"
  %assign fcnReturns = "%<SLibGetGRTWrapperLinkage()> void"
  %assign fcnParams = arg
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
    Category "model"; GeneratedBy "ertlib.tlc"; Type "Initialize"; ...
    GeneratedFor FcnGeneratedFor(rootSystem)}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
  %<fcnReturns> %<fcnName>(%<fcnParams>) {
    %<LibDumpModelInitializeSizes()>\
  }
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\

  %assign fcnName = "MdlInitializeSampleTimes"
  %assign fcnReturns = "%<SLibGetGRTWrapperLinkage()> void"
  %assign fcnParams = arg
  %createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
    Category "model"; GeneratedBy "ertlib.tlc"; Type "Initialize"; ...
    GeneratedFor FcnGeneratedFor(rootSystem)}
  %<SLibDumpFunctionBanner(fcnRec)>
  %undef fcnRec
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Pre")>\
  %<fcnReturns> %<fcnName>(%<fcnParams>) {
  }
  %<SLibGetFcnMemSecPragma(fcnName, "MemSecFuncInitTerm", "Post")>\
  %assign ::SystemFcnsForArgAccess = []

  %closefile tmpBuf
  %assign rootSystem.CurrentTID = -1
  
  %return tmpBuf
%endfunction

%% Function: SLibErtAutoFunctions ==============================================
%% Abstract:
%%   Return a buffer with the Embedded-C auto functions.  The auto functions
%%   include the generated run-time code main routine and model algorithm.
%%
%function SLibErtAutoFunctions() void

  %assign rootSystem = System[NumSystems-1]
  %assign isRateGrouping = SLibIsMultiRateAndRateGrouping(rootSystem)
  %addtorecord ::CompiledModel CachedCodeBuffsForRootSys {}
  %assign buffsRec = ::CompiledModel.CachedCodeBuffsForRootSys

  %<SLibGenERTPrivateRTMMacros()>

  %% The buffer stop simulation code should be in the context
  %% of the step method, thus the object name should be the implicit
  %% "this" object
  %if GenerateClassInterface
    %assign saveCPPObjectName = ::CPPObjectName
    %assign ::CPPObjectName = "this"
  %endif

  %% Buffer stop simulation
  %<SLibErtGenStopSimCode(buffsRec, isRateGrouping)>

  %% Restore the cpp object name to be whatever should be outside 
  %% the context of the step method.
  %if GenerateClassInterface
    %assign ::CPPObjectName = saveCPPObjectName
  %endif
  
  %<SLibErtGenFirstInitConditionCode(buffsRec)>

  %% Model Reference uses a global timing engine, so the parent
  %% will take care of the scheduler and absolute time.
  %if !IsModelReferenceTarget() 
    %if !LibIsDeploymentDiagram()
      %% Buffer update absolute time
      %<SLibErtGenUpdateAbsoluteTimeCode(NumSystems-1, buffsRec, isRateGrouping)>
    %endif
    %<FcnDumpMultiRateScheduler()>
  %endif

  %if !IsModelReferenceTarget()
    %% The following buffer code should be in the context
    %% of the step method, thus the object name should be the implicit
    %% "this" object
    %if GenerateClassInterface
      %assign saveCPPObjectName = ::CPPObjectName
      %assign ::CPPObjectName = "this"
    %endif

    %% Cach external mode code
    %<SLibErtGenExtModeCode(buffsRec, isRateGrouping)>
    
    %% Buffer logging update code
    %<SLibErtGenLoggingUpdateCode(buffsRec, isRateGrouping)>
   
    %% If deployment diagram, do not dump top level solver code because they are 
    %% dumped at the task level
    %if (NumContStates > 0) && !LibIsDeploymentDiagram()
      %<SLibDumpSolverCode("")>\
    %endif
    
    %% Restore the cpp object name to be whatever should be outside 
    %% the context of the step method.
    %if GenerateClassInterface
      %assign ::CPPObjectName = saveCPPObjectName
    %endif

  %endif

  %openfile autoFunctions
  %foreach sysIdx = NumSystems - 1
    %% Write them to "Functions" cache
    %<SLibGetSystemBodyCache(System[sysIdx])>
  %endforeach

  %% Dump stateflow cache for root system
  %<SLibGetSystemStateflowFcnCache(rootSystem)>

  %% Dump subfunctions of the root system
  %<LibGetSystemField(rootSystem, "CachedSubFunctions")>
  
  %if !IsModelReferenceTarget() && (ExportFunctionsMode != 1)
    %% Generate output and update function for root system
    %<ErtGenerateOutputAndUpdateForRoot()>
  %endif

  %if ExportFunctionsMode == 1 
    %if NumSynchronousSampleTimes > 1
      %assign errTxt = "Model specifies multiple periodic rates. This mode of operation"
      %assign errTxt = "%<errTxt> is not supported for exported function-calls."
      %<LibReportError(errTxt)>
    %elseif SLibNeedAbsoluteTime() && !SLibAutosarActive()
      %assign errTxt = "Model is time dependent."
      %assign errTxt = "%<errTxt> A common cause of this error is the use of"
      %assign errTxt = "%<errTxt> S-function blocks which access absolute time."    
      %<LibReportError(errTxt)>  
    %elseif MatFileLogging
      %assign errTxt = "MAT-file logging not supported for exported function-calls."
      %<LibReportError(errTxt)>
    %endif
    %if !(GenerateSampleERTMain && SLibIsAsyncTaskOnlyModel()) && ...
      GenerateGRTWrapper
      %assign ::CompiledModel.GRTWrapper = ::CompiledModel.GRTWrapper + ...
        FcnGenerateInitializeSizes()
    %endif
  %endif
  
  %closefile autoFunctions

  %assert (!IsModelReferenceTarget() || WHITE_SPACE(autoFunctions))
  %return autoFunctions

%endfunction %% SLibErtAutoFunctions

%% Function: SLibErtNeedNonFiniteInit ==========================================
%% Abstract:
%%   Return whether call to nonfinite initialize function is needed.
%%   Note, this function dependent on all caching being completed due to
%%   call to SLibRealNonFinitesRequired().
%%
%function SLibERTNeedNonFiniteInit(tmfVersion) void
  %if !SLibIsERTTarget() || SLibRealNonFinitesRequired() || ...
    (tmfVersion == "Standalone" && !ConfigSet.PurelyIntegerCode) || ...
    ModelReferenceTargetType == "SIM"
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction %% SLibERTNeedNonFiniteInit

%% Function: SLibGetGRTWrapperLinkage ==========================================
%% Abstract:
%%   Return the linkage specifier prefix for GRT wrapper model APIs.  Examples:
%%                 void MdlOutputs for GRT        C   targets
%%      extern "C" void MdlOutputs for GRT        C++ targets
%%      static     void MdlOutputs for GRT malloc C   targets
%%
%function SLibGetGRTWrapperLinkage() void
  %assert GenerateGRTWrapper == TLC_TRUE
  %assign MdlApiLinkageSpecifier = ::ExternCPrefix
  %%  Assign the linkage specification for Mdl* APIs
  %%  (eg. static, extern "C", default, etc.)
  %if UsingMalloc
    %%  GRT malloc C:                  static
    %%  GRT malloc C++:                static
    %%  GRT malloc C++ encapsulated:   unsupported
    %assign MdlApiLinkageSpecifier = "static"
  %endif %% 
  %return MdlApiLinkageSpecifier
%endfunction %% SLibGetGRTWrapperLinkage()

%endif %% _ERTLIB_

%% [EOF] ertlib.tlc
