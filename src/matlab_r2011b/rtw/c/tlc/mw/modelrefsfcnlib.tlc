%% ============================================================================
%%
%% Abstract:
%%   This system file contains helper functions to create an
%%   S-Function wrapper for any target.
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%

%include "ertmdlreftiming.tlc"
%include "sfcnlib.tlc"

%% Function DumpSFcnExternalInputs =========================================
%% Abstract:
%%   Generate the S-Function input signal registration for the generated ERT-
%%   C-Code. This code will register the signal properties (like type and size)
%%   for every ERT external input signal in the mdlInitializeSizes function.
%%   The registration will be generated as follow:
%%
%%   /* Number of input ports */
%%   if (!ssSetNumInputPorts(S, NumberOfInputPorts)) return;
%%
%%   ssSetInputPort<Property>(S, PortNumber, <PropertyValue`>);
%%   ...
%%
%function DumpSFcnExternalInputs() Output
  %with ExternalInputs
    /* Number of input ports */
    if (!ssSetNumInputPorts(S, %<NumExternalInputs>)) return;
    %if NumExternalInputs > 0
      %foreach idx = NumExternalInputs
	%assign extInp = ExternalInput[idx]
	%with extInp
	  %assign portWidth    = LibGetRecordWidth(extInp)
	  %assign sampleTime   = SampleTime[TID].PeriodAndOffset[0]
	  %assign offsetTime   = SampleTime[TID].PeriodAndOffset[1]
	  %assign isComplex    = LibGetRecordIsComplex(extInp)
	  %assign isFrame      = (FrameData == "yes")
	  %assign directFT     = DirectFeedThrough == "yes"

          %assign dims    = LibGetRecordDimensions(extInp)
          %assign numDimensions = SIZE(%<dims>,1)
          %<SLibDumpSfcnInpDims("S",idx,portWidth,numDimensions,dims)>
          %<SLibDumpSfcnInpDimsMode(idx)>
	  %if isFrame
	    ssSetInputPortFrameData(S, %<idx>, FRAME_YES);
	  %else
	    ssSetInputPortFrameData(S, %<idx>, FRAME_NO);
	  %endif
          %assign dataTypeIdx = LibGetRecordDataTypeId(extInp)
          %assign isBus = LibDataTypeIsBus(dataTypeIdx)
          %if CompiledModel.AllowModelRefFcnCallInputs == 0 || ...
            extInp.FunctionCallInitiator == "no"
            %<SLibSfunRegisterAndSetDataType("input","S",idx,dataTypeIdx,"namedObject")>
          %else
            ssSetInputPortDataType(S, %<idx>, SS_FCN_CALL);
          %endif
	  %if isComplex
	    ssSetInputPortComplexSignal(S, %<idx>, COMPLEX_YES);
	  %endif
	  ssSetInputPortDirectFeedThrough(S, %<idx>, %<directFT>);
          ssSetInputPortRequiredContiguous(S, %<idx>, 1);
          %if NotReusable == "yes"
            %if GlobalInRTW == "yes"
              %assign opt = "SS_NOT_REUSABLE_AND_GLOBAL"
            %else
              %assign opt = "SS_NOT_REUSABLE_AND_LOCAL"
            %endif
          %else
            %if GlobalInRTW == "yes"
              %assign opt = "SS_REUSABLE_AND_GLOBAL"
            %else
              %assign opt = "SS_REUSABLE_AND_LOCAL"
            %endif
          %endif
          %assign overwritable = OverWritable == "yes" ? "TRUE" : "FALSE"
          
	  ssSetInputPortOptimOpts(S, %<idx>, %<opt>);
	  ssSetInputPortOverWritable(S, %<idx>, %<overwritable>);

          %if MdlRefDisallowSampleTimeInheritance() && ...
            !MdlRefIsAPERTriggeredBlock() && ...
            (CompiledModel.AllowModelRefFcnCallInputs == 0 || ...
            extInp.FunctionCallInitiator == "no") && ...
            !LibAsynchronousTriggeredTID(TID)
	    ssSetInputPortSampleTime(S, %<idx>, %<sampleTime>);
	    ssSetInputPortOffsetTime(S, %<idx>, %<offsetTime>);
	  %elseif  LibAsynchronousTriggeredTID(TID)
            ssSetInputPortSampleTime(S, %<idx>, -1);
            ssSetInputPortOffsetTime(S, %<idx>, %<LibRealNonFinite("-inf")>);
          %else
	    ssSetInputPortSampleTime(S, %<idx>, -1);
	  %endif

	  %% model reference does not support constant input sample
	  %% time
	  %assert(TYPE(TID) == "Number")
          
          %if LibBlockIsIndexZeroBased(extInp)
            ssSetZeroBasedIndexInputPort(S, %<idx>);
          %elseif LibBlockIsIndexOneBased(extInp)
            ssSetOneBasedIndexInputPort(S, %<idx>);
          %endif
	%endwith %% extInp
      %endforeach
    %endif
  %endwith %% ExternalInputs
%endfunction %% DumpSFcnExternalInputs


%% Function GetStorageClassEnumFromStr ========================================
%% Abstract:
%%      Get enum str from string dumped in .rtw file
%%
%function GetStorageClassEnumFromStr(sc)
  %assign retStr= "SS_RTW_STORAGE_AUTO"
  %switch sc
    %case "Auto"
      %assign retStr = "SS_RTW_STORAGE_AUTO"
      %break
    %case "ExportedGlobal"
      %assign retStr = "SS_RTW_STORAGE_EXPORTED_GLOBAL"
      %break
    %case "ImportedExtern"
      %assign retStr = "SS_RTW_STORAGE_IMPORTED_EXTERN"
      %break
    %case "ImportedExternPointer"
      %assign retStr = "SS_RTW_STORAGE_IMPORTED_EXTERN_POINTER"
      %break
    %case "Custom"
      %assign retStr = "SS_RTW_STORAGE_CUSTOM"
      %break
    %default
      %<LibReportFatalError("Unexpected storage class")>
  %endswitch
  %return retStr
%endfunction %% GetStorageClassEnumFromStr


%% Function AppendRTWStorageClassInfo =========================================
%% Abstract:
%%   Append info related to Storage class to the infoRec.
%%   port can be an input port or output port record.
%%
%function AppendRTWStorageClassInfo(infoRec, port)
  %assign id      = port.PropagatedRTWIdentifier
  %assign stClass = port.PropagatedStorageClass
  %assign stType  = port.PropagatedStorageTypeQualifier
  %assign resSig  = port.ResolvedToSignalObject
  %assign t       = port.TestPoint

  %assign ssStClass = GetStorageClassEnumFromStr(stClass)
  %if t == "no"
    %assign tval = "0"
  %else
    %assign tval = "1"
  %endif

  %if id !=  ""
    %assign infoRec.HasIdentifier = TLC_TRUE
  %endif

  %if ssStClass != "Auto"
    %assign infoRec.HasStorageClass = TLC_TRUE
  %endif

  %if stType != ""
    %assign infoRec.HasTypeQualifier = TLC_TRUE
  %endif

  %if resSig == "embedded"
    %assign resSig = "1"
    %assign infoRec.HasResolved = TLC_TRUE
  %elseif resSig == "external"
    %assign resSig = "2"
    %assign infoRec.HasResolved = TLC_TRUE
  %else
    %assign resSig = "0"
  %endif
    
  %if tval != "0"
    %assign infoRec.HasTestPoint = TLC_TRUE
  %endif

  %assign comma = infoRec.comma
  %assign infoRec.RTWIdentifier = infoRec.RTWIdentifier + comma + "\"" + id + "\""
  %assign infoRec.StorageClass  = infoRec.StorageClass  + comma +        ssStClass
  %assign infoRec.StorageTypeQualifier = infoRec.StorageTypeQualifier+ comma + "\"" + stType + "\""
  %assign infoRec.Resolved = infoRec.Resolved + comma + resSig
  %assign infoRec.TestPoint =     infoRec.TestPoint     + comma +        tval
  %assign infoRec.comma = ", "

  %return infoRec
%endfunction %% AppendRTWStorageClassInfo


%% Function GetModelrefPortRTWStorageInfo =====================================
%% Abstract:
%%     Create a record and return info related to Signal storage class
%%
%function GetModelrefPortRTWStorageInfo()
  %createrecord infoRec { \
    RTWIdentifier        ""; \
    StorageClass         ""; \
    StorageTypeQualifier ""; \
    Resolved             ""; \
    TestPoint            ""; \
    HasIdentifier        TLC_FALSE;  \
    HasStorageClass      TLC_FALSE;  \
    HasTypeQualifier     TLC_FALSE;  \
    HasResolved          TLC_FALSE; \
    HasTestPoint         TLC_FALSE;  \
    comma                ""          \
  }

  %with ExternalInputs
    %if NumExternalInputs > 0
      %foreach idx = NumExternalInputs
	%assign infoRec = AppendRTWStorageClassInfo(infoRec,ExternalInput[idx])
      %endforeach
    %endif
  %endwith

  %with ExternalOutputs
    %if NumExternalOutputs > 0
      %foreach idx = NumExternalOutputs
	%assign extOut  = ExternalOutput[idx]
	%assign infoRec = AppendRTWStorageClassInfo(infoRec,ExternalOutput[idx])
      %endforeach
    %endif
  %endwith

  %return infoRec
%endfunction %%GetModelrefPortRTWStorageInfo

%% Function GetSignalDesignMinMax ========================================
%%
%function GetSignalDesignMinMax() Output
  %%
  %% External Inputs
  %%
  %with CompiledModel.ExternalInputs
    %foreach idx=NumExternalInputs
      %assign thisPort = ExternalInput[idx]

      {
        real_T minValue = %<thisPort.DesignMin[0]>;
        real_T maxValue = %<thisPort.DesignMax[0]>;
        ssSetModelRefInputSignalDesignMin(S,%<idx>,&minValue);
        ssSetModelRefInputSignalDesignMax(S,%<idx>,&maxValue);
      }
    %endforeach
  %endwith
  %%
  %% External Outputs
  %%
  %with CompiledModel.ExternalOutputs
    %foreach idx=NumExternalOutputs
      %assign thisPort = ExternalOutput[idx]

      {
        real_T minValue = %<thisPort.DesignMin[0]>;
        real_T maxValue = %<thisPort.DesignMax[0]>;
        ssSetModelRefOutputSignalDesignMin(S,%<idx>,&minValue);
        ssSetModelRefOutputSignalDesignMax(S,%<idx>,&maxValue);
      }
    %endforeach
  %endwith
%endfunction %%GetSignalDesignMinMax

%% Function GetSimstructRTWStorageInfo ========================================
%% Abstract:
%%     Dump code to set simstruct
%%
%%      (1) Identifiers
%%      (2) Storage classes
%%      (3) Storage class type qualifiers
%%      (4) Signal labels resolved to signal objects
%%      (5) Test points
%%
%function GetSimstructRTWStorageInfo()
  %openfile tmpBuf
  %assign portInfo = GetModelrefPortRTWStorageInfo()
  %assign numPorts = ExternalOutputs.NumExternalOutputs + ...
    ExternalInputs.NumExternalInputs

  %if  portInfo.HasIdentifier
    {
      /* Input/output identifiers */
      static char *identifiers[%<numPorts>] = {%<portInfo.RTWIdentifier>};
      ssSetModelRefPortRTWIdentifiers(S, identifiers);
    }
  %endif

  %if  portInfo.HasStorageClass
    {
      /* Input/output storage classes */
      static ssRTWStorageType storageClass[%<numPorts>] = {%<portInfo.StorageClass>};
      ssSetModelRefPortRTWStorageClasses(S, storageClass);
    }
  %endif

  %if  portInfo.HasTypeQualifier
    {
      /* Input/output storage class types */
      static char *storageClassType[%<numPorts>] = {%<portInfo.StorageTypeQualifier>};
      ssSetModelRefPortRTWStorageTypeQualifiers(S, storageClassType);
    }
  %endif

  %if  portInfo.HasResolved
    {
      /* Input/output signal labels must be resolved to signal objects */
      static int_T resolved[%<numPorts>] = {%<portInfo.Resolved>};
      ssSetModelRefPortResolvedToSignalObjects(S, resolved);
    }
  %endif
  
  %if  portInfo.HasTestPoint
    {
      /* Input/output test points */
      static int_T testPt[%<numPorts>] = {%<portInfo.TestPoint>};
      ssSetModelRefPortRTWTestPoints(S, testPt);
    }
  %endif
  %closefile tmpBuf
  %return tmpBuf
%endfunction %% GetSimstructRTWStorageInfo


%% Function MdlRefHasConstantOutput =========================================
%% Abstract:
%%     Return true if there are any output ports with a constant sample time
%%
%function MdlRefHasConstantOutput()
  
  %return (CompiledModel.HasConstantOutput == "yes")
%endfunction %%MdlRefHasConstantOutput


%% Function  MdlRefIsConstSampleBlock=========================================
%% Abstract:
%%       Return true if all block sample times are constant.
%function MdlRefIsConstSampleBlock()
  
  %return (CompiledModel.IsModelConstant == "yes")
%endfunction %%MdlRefIsConstSampleBlock

%% Function  ===================================================================
%function MdlRefIsFcnCallBlock()
  %return (CompiledModel.HasRootTriggerPort == "yes") && ...
    (CompiledModel.RootTriggerType == "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsTriggerBlock()
  %return (CompiledModel.HasRootTriggerPort == "yes") && ...
    (CompiledModel.RootTriggerType != "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsAPERTriggeredBlock()
  %return (CompiledModel.IsAPERRootTriggeredSystem == "yes")
%endfunction

%% Function  ===================================================================
%function MdlRefDisallowSampleTimeInheritance()
  %return (CompiledModel.ModelRefTsInheritance == ...
    "DISALLOW_SAMPLE_TIME_INHERITANCE")
%endfunction

%% =============================================================================
%%
%function MdlRefIsVarStepMultiRate() void

  %return ( IsModelReferenceForASimstructBasedTarget() && ...
            SolverType == "VariableStep" && ...
	    LibIsContinuous(0) && NumSampleTimes > 1)

%endfunction

%% Function DumpSFcnExternalOutputs ========================================
%% Abstract:
%%   Generate the S-Function output signal registration for the generated ERT-
%%   C-Code. This code will register the signal properties (like type and size)
%%   for every ERT external output signal in the mdlInitializeSizes function.
%%   The registration will be generated as follow:
%%
%%   /* Number of output ports */
%%   if (!ssSetNumOutputPorts(S, NumberOfOutputPorts)) return;
%%
%%   ssSetOutputPort<Property>(S, PortNumber, <PropertyValue>);
%%   ...
%%
%function DumpSFcnExternalOutputs() Output
  %with ExternalOutputs
    /* Number of output ports */
    if (!ssSetNumOutputPorts(S, %<NumExternalOutputs>)) return;
    %if NumExternalOutputs > 0
      %foreach idx = ExternalOutputs.NumExternalOutputs
	%assign extOut       = ExternalOutputs.ExternalOutput[idx]
	%assign sysIdx       = extOut.Block[0]
	%assign blkIdx       = extOut.Block[1]
	%assign outportBlock = System[sysIdx].Block[blkIdx]
	%with System[sysIdx]
	%with outportBlock
	  %assign portWidth     = LibBlockInputSignalWidth(0)
	  %assign dataTypeIdx   = LibBlockInputSignalDataTypeId(0)
	  %assign dataTypeName  = CompiledModel.DataTypes.DataType[dataTypeIdx].DTName
	  %assign numDimensions = LibBlockInputSignalNumDimensions(0)
	  %assign isComplex     = LibBlockInputSignalIsComplex(0)
	  %assign isFrame       = LibBlockInputSignalIsFrameData(0)

	  %if TYPE(TID) == "Number"
	    %assign sampleTime    = SampleTime[TID].PeriodAndOffset[0]
	    %assign offsetTime    = SampleTime[TID].PeriodAndOffset[1]
	    %assign isConstant    = 0
	  %else
	    %assign sampleTime    = "mxGetInf()"
	    %assign offsetTime    = 0
	    %assign isConstant    = 1
	    %assert(TID == "constant")
	  %endif
          %assign dims = LibBlockInputSignalDimensions(0)
          %<SLibDumpSfcnOutDims("S",idx,portWidth,numDimensions,dims)>
          %<SLibDumpSfcnOutDimsMode(idx)>

	  %if isFrame
	    ssSetOutputPortFrameData(S, %<idx>, FRAME_YES);
	  %else
	    ssSetOutputPortFrameData(S, %<idx>, FRAME_NO);
	  %endif
          
          %assign isBus = LibDataTypeIsBus(dataTypeIdx)
          
          %<SLibSfunRegisterAndSetDataType("output","S",idx,dataTypeIdx,"namedObject")>

	  %if isComplex
	    ssSetOutputPortComplexSignal(S, %<idx>, COMPLEX_YES);
	  %endif
	  %% Sample time
	  %% We may need to use subsystem sample time
	  %if (MdlRefDisallowSampleTimeInheritance() && ...
            !MdlRefIsAPERTriggeredBlock() && ...
            !LibAsynchronousTriggeredTID(TID)) || ...
            isConstant
	    ssSetOutputPortSampleTime(S, %<idx>, %<sampleTime>);
	    ssSetOutputPortOffsetTime(S, %<idx>, %<offsetTime>);
          %elseif  LibAsynchronousTriggeredTID(TID)
            ssSetOutputPortSampleTime(S, %<idx>, -1);
            ssSetOutputPortOffsetTime(S, %<idx>, %<LibRealNonFinite("-inf")>);
          %else
	    ssSetOutputPortSampleTime(S, %<idx>, -1);
	  %endif

          %if ExternalOutput[idx].DiscreteValuedOutput == "yes"
            ssSetOutputPortDiscreteValuedOutput(S, %<idx>, 1);
          %else
            ssSetOutputPortDiscreteValuedOutput(S, %<idx>, 0);
          %endif
          
	  %if ExternalOutput[idx].OkToMerge == "yes"
	    ssSetOutputPortOkToMerge(S, %<idx>, SS_OK_TO_MERGE);
	  %elseif ExternalOutput[idx].OkToMerge == "conditional"
	    ssSetOutputPortOkToMerge(S, %<idx>, SS_OK_TO_MERGE_CONDITIONAL);
	  %else
	    ssSetOutputPortOkToMerge(S, %<idx>, SS_NOT_OK_TO_MERGE);
	  %endif

     %% OutputPortICAttributes
     %<SLibWriteSetOutputPortICAttributes(idx)>

          %if ISFIELD(ExternalOutput[idx],"BlkIOUpdatedInAnotherExecContext")
            %if ExternalOutput[idx].BlkIOUpdatedInAnotherExecContext == "yes"
              %assign updatedInAnotherCtx = "true"
            %else
              %assign updatedInAnotherCtx = "false"
            %endif
            ssSetModelRefOutputBlkIOUpdatedInAnotherExecContext(S, %<idx>, %<updatedInAnotherCtx>);
          %endif

	  %% Possible settings
	  %%  SS_NOT_REUSABLE_AND_GLOBAL
          %%  SS_REUSABLE_AND_LOCAL
          %%  SS_REUSABLE_AND_GLOBAL
          %%  SS_NOT_REUSABLE_AND_LOCAL
          %if extOut.NotReusable == "yes"
            %if extOut.GlobalInRTW == "yes"
              %assign opt = "SS_NOT_REUSABLE_AND_GLOBAL"
            %else
              %assign opt = "SS_NOT_REUSABLE_AND_LOCAL"
            %endif
          %else
            %if extOut.GlobalInRTW == "yes"
              %assign opt = "SS_REUSABLE_AND_GLOBAL"
            %else
              %assign opt = "SS_REUSABLE_AND_LOCAL"
            %endif
          %endif
          ssSetOutputPortOptimOpts(S, %<idx>, %<opt>);

          %if LibBlockIsIndexZeroBased(extOut)
            ssSetZeroBasedIndexOutputPort(S, %<idx>);
          %elseif LibBlockIsIndexOneBased(extOut)
            ssSetOneBasedIndexOutputPort(S, %<idx>);
          %endif
	%endwith %% outportBlock
	%endwith %% System[sysIdx]
      %endforeach
      %undef extOut, sysIdx, blkIdx
    %endif
  %endwith %% ExternalOutputs
%endfunction %% DumpSFcnExternalOutputs

%% Function SLibWriteSetOutputPortICAttributes ========================================
%% Abstract:
%%   Helper function to share generation of ssSetOutputPortICAttributes call between
%%   the Model block sim target s-function and the Model block SIL/PIL s-function.
%%
%function SLibWriteSetOutputPortICAttributes(idx) void
  %openfile tmpBuffer
  %with CompiledModel.ExternalOutputs
     %if EXISTS(ExternalOutput[idx].ICAttributes)
        %if ExternalOutput[idx].ICAttributes.Start == "yes"
           %assign inStart = "true"
        %else
           %assign inStart = "false"
        %endif
        %if ExternalOutput[idx].ICAttributes.FirstInitialize == "yes"
           %assign inFirstInitialize = "true"
        %else
           %assign inFirstInitialize = "false"
        %endif
        %if ExternalOutput[idx].ICAttributes.Disable == "yes"
           %assign inDisable = "true"
        %else
           %assign inDisable = "false"
        %endif
           ssSetOutputPortICAttributes(S, %<idx>, %<inStart>, %<inFirstInitialize>, %<inDisable>);
        %endif
  %endwith
  %closefile tmpBuffer
  %return tmpBuffer
%endfunction

%% Function DumpSFcnExternalPortGroups ========================================
%% Abstract:
%%   Generate the S-Function port group registration for the generated ERT-
%%   C-Code. This code will register function-call and data port group
%%   in the mdlInitializeSizes function.
%%
%function DumpSFcnExternalPortGroups() Output
  %if EXISTS(ExternalPortGroups)
    %with ExternalPortGroups
      %foreach groupIdx = NumFcnCallPortGroups

        /* Function-Call Port Group %<groupIdx> */
        ssModelRefInitNewFcnCallPortGroup(S);
        %with FcnCallPortGroup[groupIdx]
          ssModelRefFcnCallPortGroupSetFcnCallInputPort(S, %<FcnCallInputPort>);
          ssSetInputPortSampleTime(S, %<FcnCallInputPort>, -1);
          ssSetInputPortOffsetTime(S, %<FcnCallInputPort>,  %<LibRealNonFinite("-inf")>);
          %foreach elIdx = SIZE(DataInputPorts, 1)
            ssModelRefPortGroupAddDataInputPort(S, %<DataInputPorts[elIdx]>);
            ssSetInputPortSampleTime(S, %<DataInputPorts[elIdx]>, -1);
            ssSetInputPortOffsetTime(S, %<DataInputPorts[elIdx]>,  %<LibRealNonFinite("-inf")>);
          %endforeach  
          %foreach elIdx = SIZE(LatchedDataInputPorts, 1)
            ssModelRefFcnCallPortGroupAddLatchedDataInputPort(S, %<LatchedDataInputPorts[elIdx]>);
          %endforeach
          %foreach elIdx = SIZE(DataInputPortsWithMultiDsts, 1)
            ssModelRefFcnCallPortGroupAddDataInputPortWithMultiDsts(S, %<DataInputPortsWithMultiDsts[elIdx]>);
          %endforeach
          %foreach elIdx = SIZE(DataOutputPorts, 1)
            ssModelRefPortGroupAddDataOutputPort(S, %<DataOutputPorts[elIdx]>);
            ssSetOutputPortSampleTime(S, %<DataOutputPorts[elIdx]>, -1);
            ssSetOutputPortOffsetTime(S, %<DataOutputPorts[elIdx]>,  %<LibRealNonFinite("-inf")>);
          %endforeach  
          %foreach elIdx = SIZE(SrcPortGroups, 1)
            ssModelRefPortGroupAddSrcPortGroup(S, %<SrcPortGroups[elIdx]>);
          %endforeach
          ssModelRefFcnCallPortGroupSetAsyncTid(S, %<AsyncTid>);
          ssModelRefFcnCallPortGroupSetHasAsyncTaskPriority(S, %<HasAsyncTaskPriority>);
          ssModelRefFcnCallPortGroupSetAsyncTaskPriority(S, %<AsyncTaskPriority>);
          ssModelRefFcnCallPortGroupSetHasEnableMethod(S, %<HasEnableMethod>);
          ssModelRefFcnCallPortGroupSetHasDisableMethod(S, %<HasDisableMethod>);
          ssModelRefFcnCallPortGroupSetNeedAbsoluteTime(S, %<NeedAbsoluteTime>);
        %endwith %% FcnCallPortGroup[groupidx]
      %endforeach

      /* Data Port Group */
      ssModelRefInitDataPortGroup(S);
      %with DataPortGroup
        %foreach elIdx = SIZE(DataInputPorts, 1)
          ssModelRefPortGroupAddDataInputPort(S, %<DataInputPorts[elIdx]>);
        %endforeach  
        %foreach elIdx = SIZE(DataOutputPorts, 1)
          ssModelRefPortGroupAddDataOutputPort(S, %<DataOutputPorts[elIdx]>);
        %endforeach  
        %foreach elIdx = SIZE(SrcPortGroups, 1)
          ssModelRefPortGroupAddSrcPortGroup(S, %<SrcPortGroups[elIdx]>);
        %endforeach
      %endwith %% DataPortGroup
    %endwith %% ExternalPortGroups
  %endif
%endfunction %% DumpSFcnExternalPortGroups

%% Function: DumpTimeConditioningCode =========================================
%% Abstract:
%%
%%
%function DumpTimeConditioningCode() Output
  %if !SLibSingleTasking()
    {
      int_T localTid = 0;
      %foreach idx = NumSynchronousSampleTimes
	if (ssIsSampleHit(S, %<idx>, %<CompiledModel.GlobalScope.tTID> )) {
	  %if Tid01Eq && ISEQUAL(idx,1)
	    localTid = 0;
	  %else
	    localTid = %<idx>;
	  %endif
	}
      %endforeach
      %<CompiledModel.GlobalScope.tTID> = localTid;
    }
  %endif
%endfunction %% DumpTimeConditioningCode

%% Function: GenerateSFunctionOutputSignalDefinition ==========================
%% Abstract:
%%   This function generates the S-Function output signal definition for the
%%   mdlOutputs function.
%%
%% Syntax:
%%   GenerateSFunctionOutputSignalDefinition(prefix)
%%
%% Arguments:
%%   prefix - signal name prefix
%%
%% Returns:
%%   real_T *<prefix>_0 = ssGetOutputPortSignal(S, 0);
%%
%function GenerateSFunctionOutputSignalDefinition(prefix) Output
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %with System[sysIdx]
    %with outportBlock
      %assign dataType  = LibBlockInputSignalDataTypeName(0, "")
      %<dataType> *%<prefix>%<idx> = ssGetOutputPortSignal(S, %<idx>);
    %endwith %% outportBlock
    %endwith %% System[sysIdx]
  %endforeach
%endfunction %% GenerateSFunctionOutputSignalDefinition

%% Function: GenerateConstOutputSignalConditioning ============================
%% Abstract:
%%   This function generates the necessary code to update outputs with conatant
%%   sample time.
%%
%function GenerateConstOutputSignalConditioning(rolllimit) Output
  %assign prefix       = "constY"

  %% Decalre const outputs
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %assign tid          = System[sysIdx].Block[blkIdx].TID
    %assign baseSysIdx   = NumSystems - 2

    %assert(sysIdx == NumSystems - 1)

    %if TYPE(tid) == "Identifier" && tid == "constant"
      %with System[baseSysIdx]
	%with outportBlock
	  %assign dataType  = LibBlockInputSignalDataTypeName(0,"")
	  %<dataType> *%<prefix>%<idx> = (%<dataType> *) ...
	    ssGetOutputPortSignal(S, %<idx>);
	%endwith %% outportBlock
      %endwith %% System[sysIdx]
    %endif
  %endforeach

  %% Initialize const output
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %assign tid          = System[sysIdx].Block[blkIdx].TID
    %assign prefix       = "constY"

    %assert(sysIdx == NumSystems - 1)

    %if TYPE(tid) == "Identifier" && tid == "constant"
      %with System[baseSysIdx]
	%with outportBlock
	  %assign portWidth = LibBlockInputSignalWidth(0)
	  %if portWidth == 1
	    %<prefix>%<idx>[0] = \
	    %<LibBlockInputSignal(0, "", "", 0)>;
	  %elseif portWidth < rolllimit
	    %foreach sigIdx = portWidth
	      %<prefix>%<idx>[%<sigIdx>] = \
	      %<LibBlockInputSignal(0, "", "", sigIdx)>;
	    %endforeach
	  %else %% portWidth > rolllimit
	    {
	      int i = 0;
	      for(i = 0; i < %<portWidth>; i++) {
		%<prefix>%<idx>[i] =  \
		%<LibBlockInputSignal(0, "i", "", 0)>;
	      }
	    }
	  %endif
	%endwith %% outportBlock
      %endwith %% System[sysIdx]
    %endif
  %endforeach
%endfunction %% GenerateConstOutputSignalConditioning


%% ============================================================================
%% S-FUNCTION FRAME FOR MODEL REFERENCE WRAPPER S-FCN CODE
%%
%% The S-Function <model>_sf.c is created as follows:
%%
%% #defines
%%
%% #includes
%%
%% external inputs structure definition and declaration
%%
%% external outputs structure definition and declaration
%%
%% imported and exported signal declaration
%%
%% static void mdlInitializeSizes(SimStruct *S) {
%%
%%   inputs and outputs signal type registration
%%
%% }
%%
%% static void mdlInitializeSampleTimes(SimStruct *S) {
%%
%%   number of sample times and sample rate registration
%%
%% }
%%
%% static void mdlInitializeConditions(SimStruct *S) {
%%
%%   initialization function call
%%
%% }
%%
%% static void mdlOutputs(SimStruct *S, int_T tid) {
%%
%%   Simulink S-Function inputs to inputs declaration
%%
%%   time conditioning
%%
%%   Output fcn call
%%
%%   outputs to Simulink S-Function outputs copy
%%
%% }
%%
%% static void mdlTerminate(SimStruct *S) {
%%
%%  termination function call
%%
%% }
%%


%% Function: SLibCacheModelRefSFcnProcessParametersFcn ========================
%% Abstract:
%%    The function generates the mdlProcessParameters function and sets the
%%    declaration & body buffers in the model reference S-Function.
%%
%function SLibCacheModelRefSFcnProcessParametersFcn() void
  %assert IsModelReferenceSimTarget()
  %assign nTunableParams = 0
  %%
  %with CompiledModel.ModelParameters
    %% For ModelReferenceSimTarget, all tunable global params must be in rtP.
    %assert (NumInrtP == (NumParameters - NumConstPrmsWithInit - NumConstPrms))
    %assign locIdx = 0
    %openfile declBuffer
    %foreach prmIdx=NumInrtP
      %assign param    = Parameter[prmIdx]
      %if (param.Tunable == "yes")
	%assign tq             = SLibGetModelParameterTypeQualifier(param)
	%assign dataType       = SLibGetRecordDataTypeName(param, "")
	%assign ptr            = "GlobalPrm_%<locIdx>"
	%% Generate local pointer for each global parameter
	%%
	%% For example:
	%%   real_T *GlobalPrm_0 = NULL;
	%%
	%<tq> %<dataType> *%<ptr> = %<SLibGetNullDefinitionFromTfl()>;
	%assign locIdx = locIdx+1
      %endif %% (param.Tunable == "yes")
    %endforeach %% prmIdx=NumInrtP
    %closefile declBuffer
    %assign nTunableParams = locIdx
    %assign locIdx = 0
    %openfile initBuffer
    %if (nTunableParams > 0)
      /* Initialize tunable global parameters */
      %foreach prmIdx=NumInrtP
	%assign param    = Parameter[prmIdx]
	%if (param.Tunable == "yes")
	  %assign tq       = SLibGetModelParameterTypeQualifier(param)
	  %assign dataType = SLibGetRecordDataTypeName(param, "")
	  %assign ptr      = "GlobalPrm_%<locIdx>"
	  %assign prmWidth = LibBlockParameterWidth(param)
	  %assign sizeStr  = prmWidth==1 ? "" : "*%<prmWidth>"
	  %% Generate initialization:
	  %% - Get pointer to new parameter value from block's run-time parameter
	  %% - Copy this new value into the global variable (in rtP structure).
	  %%
	  %% For example:
	  %%   if (!ssGetModelRefGlobalParamData(S, 0, (void **)(&GlobalParam_0)))
	  %%       return;
	  %%   (void)memcpy(&(rtP->paramName), GlobalParam_0, sizeof(real_T));
	  %%
	  if (!ssGetModelRefGlobalParamData(S, %<locIdx>, (void **)(&%<ptr>))) \
	        return;
	  (void) %<LibGenMemFcnCall("memcpy", ...
	    LibModelParameterAddr(param, "", "", 0), ptr, ...
	    "sizeof(%<dataType>)%<sizeStr>")>;

	  %assign locIdx = locIdx+1
	%endif %% (param.Tunable == "yes")
      %endforeach %% prmIdx=NumInrtP
      %assert (locIdx == nTunableParams)
    %endif %% (nTunableParams > 0)
    %closefile initBuffer
  %endwith %% CompiledModel.ModelParameters
  %<SetModelrefSFunctionField("CachedProcessParametersDeclarations", declBuffer)>
  %<SetModelrefSFunctionField("CachedProcessParametersBody", initBuffer)>
  %return nTunableParams
%endfunction %% SLibCacheModelRefSFcnProcessParametersFcn

  
%% Function: CommonDeclarationsAndInit============================================
%% Abstract:
%%    The function returns two fields.  The first field is the common variables
%%    needed by mdlOutputs, mdlUpdate, etc...  The second field is the 
%%    initialization of some of the common variables.
%function CommonDeclarationsAndInit(tid, isRateGrouping) void
  %openfile tmpBuf
  %assign prmArgCodeBuffer   = ""
  %assign inportNamePrefix   = "InPort_"
  %assign outportNamePrefix  = "OutPort_"
  %assign paramArgNamePrefix = "ParamArg_"
  %assign tmpSFcnSysIdx      = NumSystems-2
  %assign tmpSFcnSystem      = System[tmpSFcnSysIdx]
  %with tmpSFcnSystem.Interface
    %foreach argIdx=NumCanonicalInputArgDefs
      %if FcnArgNeeded(CanonicalInputArgDef[argIdx], tid, isRateGrouping)
        %assign ci = CanonicalInputArgDef[argIdx]
        %assign dataType      = SLibGetRecordDataTypeName(ci, "")
	%assign inputPortInfo = ci.SignalSrc
	%assign u_str_idx     = IDNUM(inputPortInfo[0])
        %assign u_idx         = u_str_idx[1]
        %% If the direct feedthrough is false, don't access the
        %% input signal, set it to NULL and print a warning.
        %if BlockFcn == "Output" && ...
          ExternalInputs.ExternalInput[u_idx].DirectFeedThrough == "no"
          %assign inputSig = SLibGetNullDefinitionFromTfl()
          %assign warnstr = "LibBlockInputSignal was used by a block " + ...
            "in this model, but the direct feedthrough was set to " + ...
            "false for root input port %<argIdx+1>. Please fix the TLC " + ...
            "for the block reading this input port."
          %<LibReportWarning(warnstr)>
        %else
          %assign inputSig = "ssGetInputPortSignal(S, %<u_idx>)"
        %endif
        const %<dataType> *%<inportNamePrefix>%<argIdx> = ...
          (%<dataType> *) %<inputSig>;
      %endif
    %endforeach
    %%
    %foreach argIdx=NumCanonicalOutputArgDefs
      %if FcnArgNeeded(CanonicalOutputArgDef[argIdx], tid, isRateGrouping)
	%assign idx = CanonicalOutputArgDef[argIdx].RootOutputIdx
	%assign co = CanonicalOutputArgDef[argIdx]
	%assign dataType = SLibGetRecordDataTypeName(co, "")
	%<dataType> *%<outportNamePrefix>%<argIdx> = ...
	  (%<dataType> *) ...
	  ssGetOutputPortSignal(S, %<idx>);
      %endif
    %endforeach
    %%

    %assign vardimsDeclInit = CommonDeclarationAndInitCanIOVarDims(TLC_TRUE, ...
      tid, isRateGrouping)
    %<vardimsDeclInit[0]>
    
    %assign numIterDecInit = CommonDeclarationAndInitCanNumIters(tid, isRateGrouping)
    %<numIterDecInit>
    
    %%
    %with tmpSFcnSystem.Interface
      %assign hasDwork = %<ModelrefBlockNeedsDwork()>
      %if hasDwork
        %assert !IsModelRefScalableBuild()
	%<tsysMdlrefDWorkType> *dw = (%<tsysMdlrefDWorkType> *) ssGetDWork(S, 0);
      %endif
    %endwith
    %%
    %% Get the needed arguments from the simstruct.
    %if FcnArgNeeded(ContStatesDerivativeArgDef, tid, isRateGrouping)
      %assign type = IsModelRefScalableBuild() ? ...
          "real_T" : FcnSysVarGroupType(tmpSFcnSystem,"ContStatesDerivative")
      %<type> *rtxdot = (%<type> *)ssGetdX(S);
    %endif
    %%
    %if FcnArgNeeded(ContStatesArgDef, tid, isRateGrouping)
      %assign type = IsModelRefScalableBuild() ? ...
          "real_T" : FcnSysVarGroupType(tmpSFcnSystem,"ContStates")
      %<type> *rtx = (%<type> *)ssGetContStates(S);
    %endif
    %%
    %if FcnArgNeeded(ContStatesDisabledArgDef, tid, isRateGrouping)
      %assign type = IsModelRefScalableBuild() ? ...
          "boolean_T" : FcnSysVarGroupType(tmpSFcnSystem,"ContStatesDisabled")
      %<type> *rtxdis = (%<type> *)ssGetContStateDisabled(S);
    %endif
    %%   
    %if FcnArgNeeded(ZCSVArgDef, tid, isRateGrouping)
      %assign type = IsModelRefScalableBuild() ? ...
          "real_T" : FcnSysVarGroupType(tmpSFcnSystem,"ZCSV")
      %<type> *rtzcsv = (%<type> *)ssGetNonsampledZCs(S);
    %endif
    %% In the output fcn, we may be accessing signals in rtC or rtB
    %% so we need to declare these local variables.
    %if ::BlockFcn == "Output"
      %if FcnArgNeeded(BlockIOArgDef, tid, isRateGrouping) && !IsModelRefScalableBuild()
        %<FcnSysVarGroupType(tmpSFcnSystem,"BlockIO")> *localB = &(dw->rtb);
      %endif
    %endif
    
    %% In the _initialize fcn, we may need a pointer to the base of MassMatrixPr 
    %if (CompiledModel.ModelIsLinearlyImplicit == "yes")
      %if ::BlockFcn == "RegistrationAndStart"
        %assign type = "real_T"
        %<type> *rtMM = (%<type> *)ssGetMassMatrixPr(S);
      %endif
    %endif
    
    %%
    %% NOTE: Canonical parameter (parameter arguments) must go last
    %% because we initialize them by calling the model reference block.
    %%
    %if NumCanonicalPrmArgDefs > 0
      %openfile prmArgDeclBuffer
      %foreach argIdx=NumCanonicalPrmArgDefs
	%assign canPrmDef = CanonicalPrmArgDef[argIdx]
	%if FcnArgNeeded(canPrmDef, tid, isRateGrouping)
	  %assign dataType = SLibGetRecordDataTypeName(canPrmDef, "")
	  %% Generate Parameter Argument Declaration:
	  %%
	  %% For example:
	  %%   real_T *ParamArg_0 = NULL;
	  %%
	  %<dataType> *%<paramArgNamePrefix>%<argIdx> = %<SLibGetNullDefinitionFromTfl()>;
	%endif
      %endforeach
      %closefile prmArgDeclBuffer
      %if !WHITE_SPACE(prmArgDeclBuffer)
	%<prmArgDeclBuffer>
        
        %openfile prmArgCodeBuffer
        /* Initialize parameter arguments */
        %foreach argIdx=NumCanonicalPrmArgDefs
          %assign canPrmDef = CanonicalPrmArgDef[argIdx]
          %if FcnArgNeeded(canPrmDef, tid, isRateGrouping)
            %assign dataType = SLibGetRecordDataTypeName(canPrmDef, "")
            %% Generate initialization:
            %%
            %% For example:
            %%   if (!ssGetModelRefParamArgData(S, 0, (void **)(&ParamArg0)))
            %%       return;
            %%
            if (!ssGetModelRefParamArgData(S, %<argIdx>, \
            (void **)(&%<paramArgNamePrefix>%<argIdx>))) return;
          %endif
        %endforeach
        %closefile prmArgCodeBuffer
      %endif
    %endif
  %endwith
  %closefile tmpBuf
  
  %openfile tmpBuf1
  %<vardimsDeclInit[1]>
  
  %<prmArgCodeBuffer>
  %closefile tmpBuf1

  %assign retVal = ["%<tmpBuf>", "%<tmpBuf1>"]
  %return retVal
%endfunction

%% Function: SetModelrefSFunctionField ==============================================
%% Abstract:
%%    Sets the value of an existing field in the ModelrefSFunction record
%%    This function must be called once
%function SetModelrefSFunctionField(fieldname, value) void
  %if ISFIELD(System[NumSystems-2].ModelrefSFunction, fieldname)
    %assert(WHITE_SPACE(GETFIELD(System[NumSystems-2].ModelrefSFunction, fieldname)))
    %<SETFIELD(System[NumSystems-2].ModelrefSFunction, fieldname, value)>
  %else
    %<LibReportFatalError("SetModelrefSFunctionField, %<fieldname> does not exist")>
  %endif
%endfunction


%% Function: PrependToModelrefSFunctionField ========================================
%% Abstract:
%%    Adds to the beginning of a value of an existing field
%%    in the ModelrefSFunction record
%function PrependToModelrefSFunctionField(fieldname, value) void
  %if ISFIELD(System[NumSystems-2].ModelrefSFunction, fieldname)
    %assign System[NumSystems-2].ModelrefSFunction.%<fieldname> = ...
      value + System[NumSystems-2].ModelrefSFunction.%<fieldname>
  %else
    %<LibReportFatalError("AddToModelrefSFunctionField, %<fieldname> does not exist")>
  %endif
%endfunction


%% Function: CacheModelrefSysFcnMethod =========================================
%% Abstract:
%%    This function caches the basic information for the model reference 
%%    s-function methods.  Some of the methods (like mdlInitializeSizes) 
%%    need specialized code so they won't go through this function
%%
%function CacheModelrefSysFcnMethod(methName) void
  %assert IsModelReferenceSimTarget()
  
  %% For S-Functions, the method names are slightly different
  %% than the generated code function names
  %assign rtwName = SLibGetBlockFcnForFcnType(methName)
  %assign rootSystem = System[NumSystems-1]
  %assign ::BlockFcn = rtwName
  %assign declInitBuf = CommonDeclarationsAndInit("", TLC_FALSE)
  %openfile codeBuf
  %assign subsys = System[NumSystems-2]
  %if !LibSystemFcnIsEmpty(subsys, rtwName)
    %with rootSystem
      %<LibGenSystemFcnCall(subsys, rtwName, 0)>
      %if methName == "Start" || methName == "Disable"
        %assign cTID = subsys.CurrentTID
        %assign isRG = SLibSystemFcnRateGrouping(subsys, rtwName)
        %<SLibGenOutportCurrentDimsWrites(rtwName, cTID, isRG)>
      %endif      
    %endwith
  %endif
  %closefile codeBuf
  %assign ::BlockFcn = "Unknown"
  
  %if methName != "Start"
    %% See mdlrefsfcnbody for caching mdlStart Declarations
    %assign declBuf = declInitBuf[0] + declInitBuf[1]
    %<SetModelrefSFunctionField("Cached%<methName>Declarations", declBuf)>
  %endif

  %<SetModelrefSFunctionField("Cached%<methName>Body", codeBuf)> 

%endfunction

%% Function: GetSFcnMethodPoundDefine ==========================================
%% Abstract:
%%  Get the #define that is written out the model_sf.c file.
%function GetSFcnMethodPoundDefine(methodName) void
  %assign retStr  = ""
  %assign retStr1 = ""
  %assign retStr2 = ""
  %switch(methodName)
    %case "InitializeSizes"
    %case "InitializeSampleTimes"
    %case "Outputs"
    %case "Terminate"
      %break
    %case "InitializeConditions"
      %assign retStr = "#define MDL_INITIALIZE_CONDITIONS"
      %break
    %case "SetWorkWidths"
      %assign retStr = "#define MDL_SET_WORK_WIDTHS"
      %break
    %case "ProcessParameters"
      %assign retStr  = "#define MDL_PROCESS_PARAMETERS"
      %assign retStr1 = "#if defined(MATLAB_MEX_FILE)"
      %assign retStr2 = "#endif"
      %break
    %case "Start"
      %assign retStr = "#define MDL_START"
      %break
    %case "Enable"
      %assign retStr = "#define RTW_GENERATED_ENABLE"
      %break
    %case "Disable"
      %assign retStr = "#define RTW_GENERATED_DISABLE"
      %break
    %case "Update"
      %assign retStr = "#define MDL_UPDATE"
      %break
    %case "ZeroCrossings"
      %assign retStr = "#define MDL_ZERO_CROSSINGS"
      %break
    %case "Derivatives"
      %assign retStr = "#define MDL_DERIVATIVES"
      %break
    %case "Projection"
      %assign retStr = "#define MDL_PROJECTION"
      %break
    %case "ForcingFunction"
      %assign retStr = "#define MDL_FORCINGFUNCTION"
      %break
    %case "MassMatrix"
      %assign retStr = "#define MDL_MASSMATRIX"
      %break
    %case "SetInputPortSampleTime"
      %assign retStr  = "#define MDL_SET_INPUT_PORT_SAMPLE_TIME"
      %assign retStr1 = "#if defined(MATLAB_MEX_FILE)"
      %assign retStr2 = "#endif"
      %break
    %case "SetOutputPortSampleTime"
      %assign retStr  = "#define MDL_SET_OUTPUT_PORT_SAMPLE_TIME"
      %assign retStr1 = "#if defined(MATLAB_MEX_FILE)"
      %assign retStr2 = "#endif"
      %break
    %default
      %% START_ASSERT
      %assign errTxt = "Unhandled Model Reference S-Function method name"
      %<LibReportFatalError(errTxt)>
      %% END_ASSERT
  %endswitch
  %createrecord retRec { \
      FcnDef       "%<retStr>"; \
      MatlabMexDef "%<retStr1>"; \
      MatlabMexEnd "%<retStr2>" \
  }
  %return retRec
%endfunction

%% Function: WriteModelrefSFunctionMethod ==========================================
%% Abstract:
%%  Output a model reference S-Function method.
%function WriteModelrefSFunctionMethod(methodName) Output
  %% Figure out if we need a TID argument
  %switch(methodName)
    %case "Outputs"
    %case "Update"
      %assign extraArg = ", int_T %<CompiledModel.GlobalScope.tTID>"
      %break
    %case "SetInputPortSampleTime"
    %case "SetOutputPortSampleTime"
      %assign extraArg = ",int_T portIdx,real_T sampleTime,real_T offsetTime"
      %break
    %default
      %assign extraArg = ""
  %endswitch
  %with CompiledModel.System[NumSystems-2].ModelrefSFunction
    %assign body = Cached%<methodName>Body
    %if !WHITE_SPACE(body) || methodName == "Terminate" || ...
      methodName == "Outputs"
      %assign rec = GetSFcnMethodPoundDefine(methodName)
      %if !WHITE_SPACE(rec.FcnDef)
	%<rec.FcnDef>
      %endif
      %if !WHITE_SPACE(rec.MatlabMexDef)
	 %<rec.MatlabMexDef>
      %endif
      %assign tmpfcnName = "mdl%<methodName>"
      %assign fcnReturns = "static void"
      %assign fcnParams = "SimStruct *S%<extraArg>"
      %createrecord fcnRec {Name tmpfcnName; Returns fcnReturns; Params fcnParams; ...
        Abstract ""; Category "model"; GeneratedBy "modelrefsfcnlib.tlc"; ...
        Type "%<methodName>"}
      %<SLibDumpFunctionBanner(fcnRec)>
      %undef fcnRec
      %<fcnReturns> %<tmpfcnName>(%<fcnParams>)
      {
        %assign decl = Cached%<methodName>Declarations
        %<decl>\

        %<body>\
      }
      %if !WHITE_SPACE(rec.MatlabMexEnd)
	 %<rec.MatlabMexEnd>
      %endif
    %endif
  %endwith
%endfunction


%function WriteModelrefInitSystemMatrices() Output

  %assign tmpSFcnSysIdx      = NumSystems-2
  %assign tmpSFcnSystem      = System[tmpSFcnSysIdx]
  %with tmpSFcnSystem.Interface

    #define MDL_INIT_SYSTEM_MATRICES
    %assign tmpfcnName = "mdlInitSystemMatrices"
    %assign fcnReturns = "static void"
    %assign fcnParams = "SimStruct *S"
    %createrecord fcnRec {Name tmpfcnName; Returns fcnReturns; Params fcnParams; Abstract ""; ...
      Category "model"; GeneratedBy "modelrefsfcnlib.tlc"; Type "InitSystemMatrices"}
    %<SLibDumpFunctionBanner(fcnRec)>
    %undef fcnRec
    %<fcnReturns> %<tmpfcnName>(%<fcnParams>)
    {      
      %assign nx  = %<NumContStates>
      %assign nnz = %<ModelMassMatrixJc[nx]>        
      static int_T modelMassMatrixIr[%<nnz>] = {\
        %assign comma = ""
        %foreach idx = nnz
          %<comma>%<ModelMassMatrixIr[idx]>\
          %assign comma = ", "
        %endforeach
      };              
      %assign njc = nx+1    
      static int_T modelMassMatrixJc[%<njc>] = {\
        %assign comma = ""
        %foreach idx = njc
          %<comma>%<ModelMassMatrixJc[idx]>\
          %assign comma = ", "
        %endforeach
      };          
      static real_T modelMassMatrixPr[%<nnz>] = {\
        %assign comma = ""
        %foreach idx = nnz
          %<comma>1.0\
          %assign comma = ", "
        %endforeach
      };      
      int_T *massMatrixIr = ssGetMassMatrixIr(S);
      int_T *massMatrixJc = ssGetMassMatrixJc(S);
      real_T *massMatrixPr = ssGetMassMatrixPr(S);      
      
      %assign copySize = "%<nnz>*sizeof(int_T)"    
      (void) %<LibGenMemFcnCall("memcpy","massMatrixIr","modelMassMatrixIr",copySize)>;        
      %assign copySize = "%<njc>*sizeof(int_T)"    
      (void) %<LibGenMemFcnCall("memcpy","massMatrixJc","modelMassMatrixJc",copySize)>;              
      %assign copySize = "%<nnz>*sizeof(real_T)"    
      (void) %<LibGenMemFcnCall("memcpy","massMatrixPr","modelMassMatrixPr",copySize)>;
    }
  %endwith
  
%endfunction  


%% Function:  GetConstBIOExternBuf ============================================
%% Abstract:
%%
%function GetConstBIOExternBuf()
  %openfile extCBIOExtern
  %if !LibConstBlockIOInstanceIsEmpty()
    extern %<FcnSysVarGroupType(System[NumSystems-2],"ConstBlockIO")>  %<tConstBlockIOStruct>;
  %endif
  %closefile extCBIOExtern
  %return extCBIOExtern
%endfunction %% GetConstBIOExternBuf


%% Function:  GetConstPrmExternBuf ============================================
%% Abstract:
%%
%function GetConstPrmExternBuf()
  %openfile extCPrmExtern
  %if !SLibPrmBufferIsEmpty("Const", "Typedef")
    %assign qualifiers = SLibGetConstParamQualifiers()    
    /* Constant parameters (auto storage) */
    extern %<qualifiers> %<tConstParamType> %<tConstParamStruct>;
  %endif
  %closefile extCPrmExtern
  %return extCPrmExtern
%endfunction %% GetConstPrmExternBuf


%% Function:  GetConstPrmWithInitExternBuf =====================================
%% Abstract:
%%
%function GetConstPrmWithInitExternBuf()
  %openfile extCPrmExtern
  %if !SLibPrmBufferIsEmpty("ConstWithInit", "Typedef")
    %assign qualifiers = SLibGetConstParamWithInitQualifiers()
    
    /* Constant parameters with dynamic initialization (auto storage) */
    extern %<qualifiers> %<tConstParamWithInitType> %<tConstParamWithInitStruct>;
  %endif
  %closefile extCPrmExtern
  %return extCPrmExtern
%endfunction %% GetConstPrmWithInitExternBuf

%function SLibWriteModelRefFunctionCallInputs() Output
  %assign baseSystem = CompiledModel.System[GetBaseSystemIdx()]
  %<baseSystem.ModelrefSFunction.CachedFcnCallInputBuffers>\
%endfunction

%% Function: SLibWriteModelrefSFunctionMethods =================================
%% Abstract:
%%  Write out the model reference S-Function methods to a file.
%function SLibWriteModelrefSFunctionMethods() void
  %assign sFunctionName = GetModelrefSFunctionName(Name)
  %assign opFile = SLibAddModelFile("SystemBody","Simulink", sFunctionName)
  %<SLibSetModelFileAttribute(opFile, "Group", "interface")>
  
  %assign cBIOExtBuf = GetConstBIOExternBuf()
  %<SLibCacheCodeToFile("mdlsfcn_extern_data_defn", cBIOExtBuf)>

  %% Generate code for each of the sfcn methods
  %openfile fcnsBuf
  %<WriteModelrefSFunctionVarDimsSetDimsMethods("SetDims")>
  %<WriteModelrefSFunctionVarDimsSetDimsMethods("FinalizeDims")>
  %<SLibWriteModelRefFunctionCallInputs()>
  %<WriteModelrefSFunctionMethod("InitializeSizes")>
  %<WriteModelrefSFunctionMethod("InitializeSampleTimes")>
  %<WriteModelrefSFunctionMethod("SetInputPortSampleTime")>
  %<WriteModelrefSFunctionMethod("SetOutputPortSampleTime")>
  %<WriteModelrefSFunctionMethod("InitializeConditions")>
  %<WriteModelrefSFunctionMethod("SetWorkWidths")>
  %<WriteModelrefSFunctionMethod("ProcessParameters")>
  %<WriteModelrefSFunctionMethod("Start")>
  %<WriteModelrefSFunctionMethod("Enable")>
  %<WriteModelrefSFunctionMethod("Disable")>
  %<WriteModelrefSFunctionMethod("Outputs")>
  %<WriteModelrefSFunctionMethod("Update")>
  %<WriteModelrefSFunctionMethod("ZeroCrossings")>
  %<WriteModelrefSFunctionMethod("Derivatives")>
  %<WriteModelrefSFunctionMethod("ForcingFunction")>
  %<WriteModelrefSFunctionMethod("MassMatrix")>

  %if (CompiledModel.ModelIsLinearlyImplicit == "yes")
    %<WriteModelrefInitSystemMatrices()>
  %endif

  %<WriteModelrefSFunctionMethod("Projection")>
  %<WriteModelrefSFunctionMethod("Terminate")>
  %closefile fcnsBuf
  %<SLibCacheCodeToFile("mdlsfcn_fcn_defn", fcnsBuf)>
%endfunction

%% Function: ModelrefBlockNeedsDwork ===========================================
%% Abstract:
%function ModelrefBlockNeedsDwork() void
  %if IsModelRefScalableBuild()
    %return TLC_FALSE
  %elseif (System[NumSystems-2].HasBlockIOArg || System[NumSystems-2].HasDWorkArg ...
    || !EmptyRealTimeObject || System[NumSystems-2].HasZCEventArg)
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction %%ModelrefBlockNeedsDwork


%% Function: SLibGenerateSFcnDWork =============================================
%% Abstract:
%%  Generate dwork structure for the reference model
%%
%function SLibModelReferenceGenerateDWork() void
  %assert IsModelReferenceTarget()
  %assign sysIdx = GetBaseSystemIdx()
  %with System[sysIdx]
    %openfile dwBuf
    %if HasBlockIOArg
      %<FcnSysVarGroupType(System[sysIdx],"BlockIO")> rtb;
    %endif
    %if HasDWorkArg
      %<FcnSysVarGroupType(System[sysIdx],"DWork")> rtdw;
    %endif
    %if !EmptyRealTimeObject
      %<tSimStructType> rtm;
    %endif
    %if HasZCEventArg
      %<FcnSysVarGroupType(System[sysIdx],"ZCEvent")> rtzce;
    %endif
    %closefile dwBuf
  %endwith
  %if !WHITE_SPACE(dwBuf)
    %openfile dworkBuf
    
    %<GetHideChildDefineSymbol("ifndef")>\
    typedef struct {
      %<dwBuf>\

    } %<System[sysIdx].Interface.tsysMdlrefDWorkType>;
    %<GetHideChildDefineSymbol("endif")>\
    %closefile dworkBuf
    %<SLibCacheCodeToFile("data_DWork_typedef", dworkBuf)>
    
    %if IsModelRefScalableBuild()
      %openfile dWorkDecl
      %<GetHideChildDefineSymbol("ifndef")>\
      extern %<System[sysIdx].Interface.tsysMdlrefDWorkType> %<FcnGetSFcnDWorkIdentifier(System[sysIdx])>;
      %<GetHideChildDefineSymbol("endif")>\
      %closefile dWorkDecl
      %<SLibCacheCodeToFile("data_DWork_decl", dWorkDecl)>

      %assert !GenerateClassInterface

      %assign def = "%<System[sysIdx].Interface.tsysMdlrefDWorkType> %<FcnGetSFcnDWorkIdentifier(System[sysIdx])>;"
      %openfile dWorkDefn
      %<SLibApplyMemSecToDataDefn(def, "MemSecDataInternal", "%<FcnGetSFcnDWorkIdentifier(System[sysIdx])>")>\
      %closefile dWorkDefn
      %<SLibCacheCodeToFile("data_DWork_defn", dWorkDefn)>
    %endif
  %endif
  
%endfunction

%function FcnGetSFcnDWorkIdentifier(system) void
  %return "%<system.Interface.tsysMdlrefDWork>"
%endfunction

%% Function: LibGetFcnInfo ====================================================
%% Abstract:
%%    Return fcnInfo record of the system.
%function LibGetFcnInfo(system, fcnType, tid) void
  %% Output may have been combined with update
  %if fcnType == "Output" && !ISFIELD(system,"OutputFcn") &&  ...
      !(ISFIELD(system,"OutputCalledInUpdate") &&  ...
      system.OutputCalledInUpdate == "yes")
    %assign fcnType = "OutputUpdate"
  %endif
  %if LibIsSingleRateSystem(system) && ...
    LibSystemIsReusedFcn(system)
    %assign tid = FcnGetSubsystemCodeBufTID(system)
  %endif
  %if (SLibSystemFcnRateGrouping(system, fcnType) || ...
    (LibAsynchronousTriggeredTID(tid)  && ...
    (fcnType == "Output" || fcnType == "Update" || ...
    fcnType == "OutputUpdate")))
      %assign tid = "TID%<tid>"
  %else
    %assign tid = ""
  %endif
  %assign fieldname = fcnType + "%<tid>FcnInfo"
  %if LibIsSystemField(system, fieldname)
    %assign fcnInfo = LibGetSystemField(system, fieldname)
  %else
    %assign fcnInfo = ""
  %endif
  %return fcnInfo
%endfunction

%% Function:  CreateModelrefSFunctionForTopSystem =================================
%% Abstract:
%%    Create ModelrefSFunction record for the hidden subsystem
%function CreateModelrefSFunctionForTopSystem() void

  %assert IsModelReferenceTarget()
  %% If we are generating an S-function, add cached variables for
  %% all the s-fcn entry points to the record ModelrefSFunction
  %assert CompiledModel.NumSystems > 1

  %addtorecord CompiledModel.System[NumSystems-2] ModelrefSFunction { ...
    CachedFcnCallInputBuffers ""; ...
    CachedInitializeSizesDeclarations ""; ...
    CachedInitializeSizesBody ""; ...
    CachedInitializeSampleTimesDeclarations ""; ...
    CachedInitializeSampleTimesBody ""; ...
    CachedInitializeConditionsDeclarations ""; ...
    CachedInitializeConditionsBody ""; ...
    CachedSetWorkWidthsDeclarations ""; ...
    CachedSetWorkWidthsBody ""; ...
    CachedProcessParametersDeclarations ""; ...
    CachedProcessParametersBody ""; ...
    CachedStartDeclarations ""; ...
    CachedStartBody ""; ...
    CachedEnableDeclarations ""; ...
    CachedEnableBody ""; ...
    CachedDisableDeclarations ""; ...
    CachedDisableBody ""; ...
    CachedOutputsDeclarations ""; ...
    CachedOutputsBody ""; ...
    CachedUpdateDeclarations ""; ...
    CachedUpdateBody ""; ...
    CachedZeroCrossingsDeclarations ""; ...
    CachedZeroCrossingsBody ""; ...
    CachedDerivativesDeclarations ""; ...
    CachedDerivativesBody ""; ...
    CachedProjectionDeclarations ""; ...
    CachedProjectionBody ""; ...
    CachedForcingFunctionDeclarations ""; ...
    CachedForcingFunctionBody ""; ...
    CachedMassMatrixDeclarations ""; ...
    CachedMassMatrixBody ""; ...
    CachedTerminateDeclarations ""; ...
    CachedTerminateBody ""; ...
    CachedSetInputPortSampleTimeDeclarations ""; ...
    CachedSetInputPortSampleTimeBody "" ;...
    CachedSetOutputPortSampleTimeDeclarations ""; ...
    CachedSetOutputPortSampleTimeBody "" ...
  }
%endfunction


%% Function:  AppendZeroToString ===============================================
%% Abstract:
%%      Append the inStr with zero
%function AppendZeroToString(inStr, comma, num) void
  %foreach i = num
    %assign inStr =  "%<inStr>%<comma>0"
    %assign comma = ", "
  %endforeach
  %return inStr
%endfunction

%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface.
%function SLibGetModelRefFcnNames(thisSystem, blockFcn, fcnCallTaskName, ...
  currentTID, isRateGrouping)
  
  %if ISEMPTY(fcnCallTaskName)
    %assign tlcFcn = ""
    %if blockFcn == "Registration"
      %assert ISEMPTY(fcnCallTaskName)
      %assign sysFcnName = "%<blockFcn>Fcn"
      %assign fcnName = GetModelRefRegistrationFcnName()
      %assign tlcFcnName = []
    %else
      %assign fcnRecord = LibGetFcnInfo(thisSystem, blockFcn, currentTID)
      %assert (TYPE(fcnRecord) == "Scope")
      %assign fcnName = fcnRecord.Name
    
      %switch (blockFcn)
        %case "Output"
        %case "OutputUpdate"
          %assign tlcFcn = "Outputs"
          %break
        %case "Initialize"
          %assign tlcFcn = "InitializeConditions"
          %break
        %case "Derivative"
          %assign tlcFcn = "Derivatives"
          %break
        %case "ZeroCrossing"
          %assign tlcFcn = "ZeroCrossings"
          %break
        %default
          %assign tlcFcn = blockFcn
          %break
      %endswitch
    
      %if !isRateGrouping && ...
        !LibSystemFcnIsEmpty(thisSystem, blockFcn)
        %assign sysFcnName = blockFcn + "Fcn"
        %assign tlcFcnName = tlcFcn + "_Function"
      %elseif !LibSystemFcnIsEmptyForTID(thisSystem, blockFcn)
        %assign sysFcnName = blockFcn + "TID%<thisSystem.CurrentTID>Fcn"
        %assign tlcFcnName = tlcFcn + "_FunctionTID%<thisSystem.CurrentTID>"
      %endif
    %endif
  %else
    %% For Fcn-call inputs, override the sysFcnName with the entry point 
    %% task name.
    %assign sysFcnName = fcnCallTaskName
    %assign fcnName = fcnCallTaskName
    %assign tlcFcnName = []
  %endif
  
  %assign retRec = ["%<sysFcnName>", "%<tlcFcnName>", "%<fcnName>"]
  %return retRec  
%endfunction


%% Function: CreateModelReferenceFcnRec ========================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface
%function CreateModelReferenceFcnRec(sysIdx, blockFcn, sysFcnName, tid, ...
  blkInterface) void
  %assign thisSystem = System[sysIdx]
  %assign System[sysIdx].CurrentTID = tid
  %assign currentTID     = tid
  
  %assign isRateGrouping = SLibSystemFcnRateGrouping(thisSystem, blockFcn) || ...
    (SLibSystemFcnIsRateGroupType(blockFcn) && SLibIsModelRefAsyncTID(tid))
  
  %if !ISFIELD(blkInterface, "NumBlockFcns")
    %addtorecord blkInterface NumBlockFcns 0
  %endif
  
  %% LibSystemFcnIsEmpty has side affect. (When output is passed,
  %% it may check for OutputUpdate!)
  %if blockFcn != "Registration" && ...
    !SLibIsModelRefAsyncTID(tid) && ...
    (!ISFIELD(thisSystem,"%<blockFcn>Fcn") || ...
    LibSystemFcnIsEmpty(thisSystem, blockFcn))
    %createrecord retRec { \
    SysFcnName ""; \
    FcnRec     ""\
    }  
    %return retRec
  %endif
  
  %assign fcnNames = SLibGetModelRefFcnNames(thisSystem, blockFcn, ...
    sysFcnName, currentTID, isRateGrouping)  

  %assign sysFcnName = fcnNames[0]
  %assign tlcFcnName = fcnNames[1]
  %assign fcnName = fcnNames[2]
  
  %assign ::BlockFcn = blockFcn

  %with System[sysIdx].Interface
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical input argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign  comma = ""
    %assign  inStr = ""
    %assign  inCounter = 0
    %assign  numInputs = ExternalInputs.NumExternalInputs
    %foreach argIdx    = NumCanonicalInputArgDefs
      %assign ci      = CanonicalInputArgDef[argIdx].SignalSrc
      %assign U_idx   = IDNUM(ci[0])
      %assign idx     = U_idx[1]

      %assert (U_idx[0] == "U")

      %% fill 0 for unused inputs
      %assign numZeroToAdd = idx - inCounter
      %if  numZeroToAdd > 0
	%assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
	%assign comma = ", "
      %endif
      %assign inCounter = idx

      %if FcnArgNeeded(CanonicalInputArgDef[argIdx],currentTID,isRateGrouping)
	%if CanonicalInputArgDef[argIdx].DeclareAsPointer == "yes"
	  %assign inStr = "%<inStr>%<comma>2"
	%else
	  %assign inStr = "%<inStr>%<comma>1"
	%endif
      %else
	%assign inStr = "%<inStr>%<comma>0"
      %endif
      %assign comma = ", "
      %assign inCounter = inCounter + 1
    %endforeach

    %assign numZeroToAdd = numInputs - inCounter
    %if  numZeroToAdd > 0
      %assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
      %assign comma = ", "
    %endif
    %assign inCounter = numInputs
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dimsize dwork argument for input
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign inDWStr = GetBlockInputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical output argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign comma  = ""
    %assign outStr = ""
    %assign outCounter = 0
    %assign  numOutputs = ExternalOutputs.NumExternalOutputs
    %foreach argIdx   = NumCanonicalOutputArgDefs
      %assign idx     = CanonicalOutputArgDef[argIdx].RootOutputIdx

      %% fill 0 for unused outputs
      %assign numZeroToAdd = idx - outCounter
      %if  numZeroToAdd > 0
	%assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
	%assign comma = ", "
      %endif
      %assign outCounter = idx

      %if FcnArgNeeded(CanonicalOutputArgDef[argIdx],currentTID,isRateGrouping)
	%assign outStr = "%<outStr>%<comma>1"
      %else
	%assign outStr = "%<outStr>%<comma>0"
      %endif
      %assign comma = ", "
      %assign outCounter = outCounter + 1
    %endforeach

    %assign numZeroToAdd = numOutputs - outCounter
    %if  numZeroToAdd > 0
      %assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
      %assign comma = ", "
    %endif
    %assign outCounter = numOutputs
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dimsize dwork argument for output
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign outDWStr = GetBlockOutputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Other flags
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Args: [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDriv, CStateDis, ZC, ZCEvent]

    %% Note the following order is used in blocks/modelref.tlc.
    %% If you update this order, you must update the order in modelref.tlc.
    %% [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDriv, CStateDis, ZC, ZCEvent]
    %assign numArgs = 11
    %assign args = ""
    %assign comma = ""

    %% oIdx and rIdx
    %if blockFcn == "SetDims"
      %assign val = 1
      %assign args = "%<args>%<comma>%<val>"
      %assign args = "%<args>%<comma>%<val>"
    %endif
    
    %% TID
    %if (SLibIsModelRefAsyncTID(tid))
      %% Because we know async is single instance, always return
      %% false for needs TID.  (LibSystemFcnNeedsTID returns needs
      %% TID for the model, which does need TID, but the async doesn't,
      %% which causes code that won't compile)
      %assign val = TLC_FALSE
    %else
      %assign val = LibSystemFcnNeedsTID(System[sysIdx], blockFcn)
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %assign comma = ", "
    %%rtModel
    %assign val = FcnArgNeeded(RTMArgDef,currentTID,isRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface) 
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %assign comma = ", "
    %% BlockIo argument
    %assign val = FcnArgNeeded(BlockIOArgDef,currentTID,isRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %% DWork argument
    %assign val = FcnArgNeeded(DWorkArgDef,currentTID,isRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States argument
    %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States Derivative argument
    %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States Disabled argument
    %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Non Sampled Zero Crossing argument
    %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% ZCEvent H-Valuct argument
    %assign val = FcnArgNeeded(ZCEventArgDef,currentTID,isRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical parameter argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign comma  = ""
    %assign prmStr = ""
    %foreach argIdx = NumCanonicalPrmArgDefs
      %assign argDef = CanonicalPrmArgDef[argIdx]
      %if (argDef.OriginalDataTypeIdx != -1)
      %if FcnArgNeeded(argDef,currentTID,isRateGrouping)
        %assign prmWidth = LibBlockParameterWidth(argDef)
	%assign prmStr = "%<prmStr>%<comma>%<prmWidth>"
      %else
	%assign prmStr = "%<prmStr>%<comma>0"
      %endif
      %assign comma = ", "
      %endif
    %endforeach
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dwork argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign comma  = ""
    %assign canDWStr = ""
    %foreach argIdx = NumCanonicalDWorkArgDefs
      %assign argDef = CanonicalDWorkArgDef[argIdx]
      %if FcnArgNeeded(argDef,currentTID,isRateGrouping)
        %assign dwIdx    = argDef.FirstSignalSrc
        %assign dwRec    = CompiledModel.DWorks.DWork[dwIdx]
        %assign dwWidth  = SLibDWorkWidth(dwRec)
        %assign canDWStr = "%<canDWStr>%<comma>%<dwWidth>"
      %else
	%assign canDWStr = "%<canDWStr>%<comma>0"
      %endif
      %assign comma = ", "
    %endforeach
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Computed stack size
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign stackSize = 0
    %if blockFcn != "Registration" && !SLibIsModelRefAsyncTID(tid)
      %if !ISEMPTY(tlcFcnName)
        %assign rtwFcnConst = ...
          RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx].RTWFcnConst
        %if ISFIELD(rtwFcnConst, tlcFcnName)
          %assign stackSize = rtwFcnConst.%<tlcFcnName>.StackSize
        %endif
      %endif
      %assign localTaskID = isRateGrouping ? currentTID : -1
      %createrecord blockFcnRec {       \
        BlockFcnType "%<blockFcn>";       \
        RateGrouping %<isRateGrouping>; \
        TaskID       %<localTaskID>;    \
        StackSize    %<stackSize>       \
      }
      %assign blkInterface.NumBlockFcns = blkInterface.NumBlockFcns + 1
      %addtorecord blkInterface BlockFcns %<blockFcnRec>
    %endif
    
    %if SLibIsModelRefAsyncTID(tid)
      %% For async, prmSTr, canDWStr, and args should all be empty.
      %% Assert that they are and defensively set them appropriately.
      %assert(args     == "0, 0, 0, 0, 0, 0, 0, 0, 0")
    %endif
    
    %createrecord BlkFcnRec {     \
      FcnName      "%<fcnName>";  \
      ArgInfo      [%<args>];     \
      Outputs      [%<outStr>];   \
      OutDimSizeDW [%<outDWStr>]; \
      Inputs       [%<inStr>];    \
      InDimSizeDW  [%<inDWStr>];  \
      PrmArgs      [%<prmStr>];   \
      DWArgs       [%<canDWStr>]  \
    }

    %assign ::BlockFcn = "Unknown"
  %endwith %% System[sysIdx].Interface

  %createrecord retRec { \
  SysFcnName "%<sysFcnName>"; \
  FcnRec     %<BlkFcnRec>\
  }  
  %return retRec
%endfunction


%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    The following order is used in FcnGetAdditionalArgs and
%%    FcnAddNeededParameter. We must use the same order:
%%           Tid
%%           oIdx,
%%           rIdx,
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           RTModel
%%           BlockIO
%%           ConstBlockIO (not needed. This is global for all instances)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           NonsampledZC
%%           ZCEvent
%%           NumCanonicalPrm
%%           CanDWork (?)
%%
%function FcnAppendToBlockInterface(sysIdx, accessSysIdx, blockFcn, tid, ...
  blkInterface) void
  
  %assign fcnRec = CreateModelReferenceFcnRec(sysIdx, blockFcn, "", ...
    tid, blkInterface)
  
  %assign fcnName = fcnRec.SysFcnName
  %assign BlkFcnRec = fcnRec.FcnRec
  
  %if fcnName != ""
    %addtorecord blkInterface %<fcnName> %<BlkFcnRec>
  %endif

%endfunction %%FcnAppendToBlockInterface

%% Function: FcnCacheMRRegFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the registration function 
%%   body e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName_intialize(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnCacheMRRegFcnLocalVars(thisSystem) void
  
  %assign thisSystem.CurrentTID = ""
  %assign currentTID     = ""
  %assign isRateGrouping = SLibSystemFcnRateGrouping(thisSystem, "Registration")

  %assign ::BlockFcn = "Registration"
  
  %with thisSystem.Interface
    %% Args: [TID, rtModel, BlockIo, DWork, CState, CStateDriv, CStateDis, ZC, ZCEvent]
    %%rtModel
    %assign val = FcnArgNeeded(RTMArgDef,currentTID,isRateGrouping)
    %if val && IsModelRefScalableBuild() 
      %openfile localRTMVar
      %<tSimStructType> *const %<tSimStruct> = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>.rtm);
      %closefile localRTMVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localRTMVar)>
    %endif
    %% BlockIo argument
    %assign val = FcnArgNeeded(BlockIOArgDef,currentTID,isRateGrouping)
    %if val && IsModelRefScalableBuild() && !GenerateClassInterface
      %openfile localBIOVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"BlockIO")
      %<varGroupType> *localB = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>.rtb);
      %closefile localBIOVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localBIOVar)>
    %endif
    %% DWork argument
    %assign val = FcnArgNeeded(DWorkArgDef,currentTID,isRateGrouping)
    %if val && IsModelRefScalableBuild() && !GenerateClassInterface 
      %openfile localDWVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"DWork")
      %<varGroupType> *localDW = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>.rtdw);
      %closefile localDWVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localDWVar)>
    %endif
    %% Continuous States argument
    %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isRateGrouping)
    %if (val && IsModelRefScalableBuild())
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStates")
      %<varGroupType> *localX = (%<varGroupType> *) localX_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Continuous States Derivative argument
    %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isRateGrouping)
    %if (val && IsModelRefScalableBuild())
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDerivative")
      %<varGroupType> *localXdot = (%<varGroupType> *) localXdot_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Continuous States Disabled argument
    %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isRateGrouping)
    %if (val && IsModelRefScalableBuild())
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDisabled")
      %<varGroupType> *localXdis = (%<varGroupType> *) localXdis_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Non Sampled Zero Crossing argument
    %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isRateGrouping)
    %if (val && IsModelRefScalableBuild())
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCSV")
      %<varGroupType> *localZCSV = (%<varGroupType> *) localZCSV_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% ZCEvent H-Valuct argument
    %assign val = FcnArgNeeded(ZCEventArgDef,currentTID,isRateGrouping)
    %if val && IsModelRefScalableBuild()
      %openfile localZCEventVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCEvent")
      %<varGroupType> *localZCE = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>.rtzce);
      %closefile localZCEventVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localZCEventVar)>
    %endif
    %assign ::BlockFcn = "Unknown"
  %endwith %% System[sysIdx].Interface

%endfunction %%FcnCacheMRRegFcnLocalVars

%% Function: FcnCacheModelRefFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnCacheModelRefLocalVars(system, function, tid, localVars) void
  %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
  %if !LibIsSystemField(system, cacheName)
    %<LibAddToSystem(system, cacheName, localVars)>
  %else
    %<LibAddToSystemField(system, cacheName, localVars)>
  %endif
%endfunction

%% Function: FcnDumpModelRefFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnDumpMRLocalVars(system, function, tid) void

  %if !IsModelReferenceBaseSys(system) || !IsModelRefScalableBuild()
    %return ""
  %endif
  
  %if IsModelReferenceBaseSys(system) && GenerateClassInterface
    %return ""
  %endif
  
  %% For functions that don't use rate-grouping, make sure we clear out the TID
  %if !SLibSystemFcnIsRateGroupType(function)
    %assign tid = ""
  %endif

  %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
  %if LibIsSystemField(system, cacheName)
    %assign cacheVal = LibGetSystemField(system, cacheName)
    %if !WHITE_SPACE(cacheVal)
      %return cacheVal
    %endif
  %endif
  %return ""
%endfunction


%% Function: SLibModelReferenceAppendInputsOutputs ===========================
%% Abstract:
%%   Used for the model reference SIM target to define the arguments to
%% a function, or call that function from the S-Function.
%function SLibModelReferenceAppendInputsOutputs(isCallSite, blockFcn, ...
  isRateGrouping, currentTID, recArgs)
  %assign origBlockFcn = ::BlockFcn
  %assign ::BlockFcn = blockFcn
  %assign baseSystem = CompiledModel.System[GetBaseSystemIdx()]
  
  %with baseSystem.Interface
    %foreach argIdx = NumCanonicalInputArgDefs
      %if FcnArgNeeded(CanonicalInputArgDef[argIdx], currentTID,isRateGrouping)
        %if isCallSite
	  %assign recArgs = recArgs + "InPort_%<argIdx>"
	%else
	  %assign ci        = CanonicalInputArgDef[argIdx]
          %assign identi    = LibGetRecordIdentifier(ci)
	  %assign dataType  = SLibGetRecordDataTypeName(ci, "")
	  %assign optWidth  = LibOptionalVectorWidth(LibGetRecordWidth(ci))
	  %assign optStar   = LibGetRecordWidth(ci) == 1 ? " *" : " "
	  %assign dataType  = "const %<dataType> "
          %if SLibGetCanIOIsVarDims(ci)
            %assign   argDef  = dataType + identi + "[]"
          %else
            %assign   argDef  = dataType + optStar + identi + optWidth
          %endif
          %assign recArgs   = recArgs + argDef
        %endif
      %endif
      %assign recArgs = AppendModelReferenceRegFcnInputCanDimSizeDWArgs(argIdx, ...
        currentTID, isRateGrouping, recArgs, isCallSite)
    %endforeach

    %foreach argIdx = NumCanonicalOutputArgDefs
      %if FcnArgNeeded(CanonicalOutputArgDef[argIdx], currentTID,isRateGrouping)
	%if isCallSite
	  %assign recArgs = recArgs + "OutPort_%<argIdx>"
	%else
	  %assign       co = CanonicalOutputArgDef[argIdx]
	  %assign   identi = LibGetRecordIdentifier(co)
	  %assign dataType = SLibGetRecordDataTypeName(co, "")
	  %assign  optStar = LibGetRecordWidth(co) == 1 ? " *" : " "
	  %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
          %if SLibGetCanIOIsVarDims(co)
            %assign   argDef = dataType + " " + identi + "[]"
          %else
            %assign   argDef = dataType + optStar + identi + optWidth
          %endif
	  %assign recArgs  = recArgs + argDef
	%endif
      %endif
      %assign recArgs = AppendModelReferenceRegFcnOutputCanDimSizeDWArgs(argIdx, ...
        currentTID, isRateGrouping, recArgs, isCallSite)
    %endforeach

    
    %foreach argIdx = NumCanonicalPrmArgDefs
      %if FcnArgNeeded(CanonicalPrmArgDef[argIdx], currentTID,isRateGrouping)
	%if isCallSite
	  %assign       prm = CanonicalPrmArgDef[argIdx]
          %assign declAsPtr = prm.DeclareAsPointer == "yes"   
          %assign     width = LibBlockParameterWidth(prm)
          %assign   optStar = ((width > 1) || declAsPtr) ? "" : " *"
	  %assign   recArgs = recArgs + "%<optStar>ParamArg_%<argIdx>"
	%else
	  %assign       prm = CanonicalPrmArgDef[argIdx]
	  %assign    identi = LibGetRecordIdentifier(prm)
	  %assign  dataType = SLibGetRecordDataTypeName(prm, "")
          %assign     width = LibBlockParameterWidth(prm)
          %assign  optWidth = LibOptionalVectorWidth(width)
          %assign declAsPtr = prm.DeclareAsPointer == "yes"          
          %assign  optConst = ((width > 1) || declAsPtr) ? "const " : ""
          %assign  dataType = "%<optConst>%<dataType> "
          %assign   optStar = declAsPtr ? " *" : " "
          %assign    argDef = dataType + optStar + identi + optWidth
	  %assign   recArgs = recArgs + argDef
	%endif
      %endif
    %endforeach

    %assign recArgs = AppendImplicitIterSubsysNumItersDWorkForRefModel(recArgs, ...
      currentTID, isRateGrouping, isCallSite)
  %endwith

  %assign ::BlockFcn = origBlockFcn
  %return recArgs
  
%endfunction
  
  

%% Function: SLibModelReferenceRegFcnArgs ===================================
%% Abstract:
%%   Generate model fcn arg list.
%%
%% isCallSite = TLC_TRUE (called from modelrefsfcn)
%%            = TLC_FALSE (called from ertreg)
%%
%% The following order should be maintianied for ref args. See GetFunctionStr()
%%           TID
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%
%function SLibModelReferenceRegFcnArgs(isCallSite) void
  %assign recArgs = []
  %assign rootSystem        = System[NumSystems-1]
  %assign baseSystem        = System[NumSystems-2]
  %assign isRateGrouping    = SLibIsMultiRateAndRateGrouping(rootSystem)

  %assert IsModelReferenceTarget()
  
  %assign ::BlockFcn = "Registration"

  %if !IsModelReferenceForASimstructBasedTarget()
    %% ModelInitializeIsEmpty is computed in ertreg.tlc
    %% Why do we need this?  Who calls it with 0?
    %assert !isCallSite
    %if SLibGetNeedFirstTime()
      %if isCallSite
	%assign recArgs = recArgs + "1"
      %else
	%assign recArgs = recArgs + "boolean_T %<SLibFirstTime()>"
      %endif
    %endif

    %if !SuppressErrorStatus
      %if isCallSite
	%assign recArgs = recArgs + "&(ssGetErrorStatus(S))"
      %else
	%assign recArgs = recArgs + "const char_T **rt_errorStatus"
      %endif
    %endif

    %if RTMStopReqAccessed() || CompiledModel.ModelBlocksUseStopReq
      %if isCallSite
	%assign recArgs = recArgs + "&(ssGetStopRequested(S))"
      %else
	%assign recArgs = recArgs + "boolean_T *rt_stopRequested"
      %endif
    %endif

    %if LibIsContinuous(0) || SLibModelHierarchyContainsNoninlinedSfcn()
      %assign recArgs = recArgs + "RTWSolverInfo *rt_solverInfo"
    %endif
    
    %if SLibModelHierarchyContainsNoninlinedSfcn()
      %assign recArgs = recArgs + "RTWSfcnInfo *rt_sfcnInfo"
    %endif
  
  %endif
  
  %% Add the canonical inputs/outputs to the interface
  %assign recArgs = SLibModelReferenceAppendInputsOutputs(isCallSite, "Registration", ...
    isRateGrouping, rootSystem.CurrentTID, recArgs)
  
  %if IsModelReferenceForASimstructBasedTarget() 
    %if isCallSite
      %assign recArgs = recArgs + "S"
    %else
      %assign recArgs = recArgs + "%<tMdlRefSfcnSType> %<tMdlRefSfcnS>"
    %endif
    
    %if RTMIsVarStepSolver() && HasNonContSigFeedingOutport()
      %if isCallSite
        %assign recArgs = recArgs + "mr_nonContOutputArray"
      %else
        %assign recArgs = recArgs + "ssNonContDerivSigFeedingOutports **mr_nonContOutputArray"
      %endif
    %endif
  %endif %% !IsModelReferenceForASimstructBasedTarget()

  %% Pass the timing info to the registration function, we only
  %% do this for non simstruct based targets.
  %if !isCallSite && !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed
    %assert SLibIsERTCodeFormat()
    %assign recArgs = recArgs + "const rtTimingBridge *timingBridge"
  %endif

  %% Only loop over the sample times if the model reference
  %% block will not become constant/triggered.
  %if ::tMdlRefNeedTIDArgs
    %if !MdlRefIsConstSampleBlock()
      %assert ((NumSampleTimes == NumSynchronousSampleTimes) || ...
        CompiledModel.AllowModelRefFcnCallInputs)
      %foreach idx = NumSampleTimes
        %if isCallSite
          %% Map the s-function TID to the root model TID
          %% NOTE: In simulation, async TID's will map to 0.
          %if LibAsynchronousTriggeredTID(idx)
            %assign tidArg = "0"
          %else
            %assign tidArg = "ssGetSampleTimeTaskID(S, %<idx>)"
          %endif
          %assign recArgs = recArgs + tidArg
        %else
          %assign recArgs = recArgs + "int_T mdlref_TID%<idx>"
        %endif
      %endforeach
    %else
      %if isCallSite
        %% Map the s-function TID to the root model TID
        %assign recArgs = recArgs + "0"
      %else
        %assign recArgs = recArgs + "int_T mdlref_TID0"
      %endif
    %endif
  
    %if SLibModelNeedsTriggerTIDArg()
      %if isCallSite
        %assign recArgs = recArgs + "sysTid"
      %else
        %assign recArgs = recArgs + "int_T mdlref_TriggerTID"
      %endif
    %endif
  %endif
    
  %with baseSystem.Interface
    %if !IsModelRefScalableBuild()
      %if FcnArgNeeded(RTMArgDef,rootSystem.CurrentTID,isRateGrouping)
        %if isCallSite
          %assign tSSCaller = "&(dw->rtm)"
          %assign recArgs = recArgs + "%<tSSCaller>"
        %else
          %assign recArgs = recArgs + "%<tSimStructType> *const %<tSimStruct>"
        %endif
      %endif
      %if FcnArgNeeded(BlockIOArgDef,rootSystem.CurrentTID,isRateGrouping)
        %if isCallSite
          %assign blockIOCaller = "&(dw->rtb)"
          %assign recArgs = recArgs + "%<blockIOCaller>"
        %else
          %assign blockIOCallee = "localB"
          %assign blockIOType = FcnSysVarGroupType(System[NumSystems-2],"BlockIO")
          %assign recArgs = recArgs + "%<blockIOType> *%<blockIOCallee>"
        %endif
      %endif
      %if FcnArgNeeded(DWorkArgDef,rootSystem.CurrentTID,isRateGrouping)
        %if isCallSite
          %assign dworkCaller = "&(dw->rtdw)"
          %assign recArgs = recArgs + "%<dworkCaller>"
        %else
          %assign dworkCallee = "localDW"
          %assign dworkType = FcnSysVarGroupType(System[NumSystems-2],"DWork")
          %assign recArgs = recArgs + "%<dworkType> *%<dworkCallee>"
        %endif
      %endif
    %endif %% scalable
    %if FcnArgNeeded(ContStatesArgDef,rootSystem.CurrentTID,isRateGrouping)
      %if isCallSite
        %assign contStateCaller = "rtx"
        %assign recArgs = recArgs + "%<contStateCaller>"
      %else
        %assign contState = IsModelRefScalableBuild() ? ...
          "localX_" : "localX"
        %assign contStateType = IsModelRefScalableBuild() ? ...
          "real_T" : FcnSysVarGroupType(System[NumSystems-2],"ContStates")
        %assign recArgs = recArgs + "%<contStateType> *%<contState>"
      %endif
    %endif
    %if FcnArgNeeded(ContStatesDerivativeArgDef, ...
                     rootSystem.CurrentTID,isRateGrouping)
      %if isCallSite
        %assign contDerivStateCaller = "rtdx"
        %assign recArgs = recArgs + "%<contDerivStateCaller>"
      %else
        %assign contDerivState = IsModelRefScalableBuild() ? ...
          "localdX_" :"localdX"
        %assign contDerivStateType = IsModelRefScalableBuild() ? ...
          "real_T" : FcnSysVarGroupType(System[NumSystems-2],"ContStatesDerivative")
        %assign recArgs = recArgs + "%<contDerivStateType> *%<contDerivState>"
      %endif
    %endif
    %if !IsModelRefScalableBuild()
      %if FcnArgNeeded(ZCEventArgDef,rootSystem.CurrentTID,isRateGrouping)
        %if isCallSite
          %assign prevZCCaller = "&(dw->rtzce)"
          %assign recArgs = recArgs + "%<prevZCCaller>"
        %else
          %assign prevZCCallee = "localZCE"
          %assign prevZCEvType = FcnSysVarGroupType(System[NumSystems-2],"ZCEvent")
          %assign recArgs = recArgs + "%<prevZCEvType> *%<prevZCCallee>"
        %endif
      %endif
    %endif
    
    %if (CompiledModel.ModelIsLinearlyImplicit == "yes")
      %if isCallSite
        %assign prevMMCaller = "rtMM"
        %assign recArgs = recArgs + "%<prevMMCaller>"
      %else
        %assign prevMMCallee = "localMM"
        %assign prevMMType = "real_T"
        %assign recArgs = recArgs + "%<prevMMType> *%<prevMMCallee>"
      %endif
    %endif
      
  %endwith
  
  %%
  %% Pass in the initial context system and tid
  %%
  %if IsModelReferenceSimTarget()
    %if isCallSite
      %assign recArgs = recArgs + "sysRanPtr"
      %assign recArgs = recArgs + "sysTid"
    %else
      %assign recArgs = recArgs + "void *sysRanPtr"
      %assign recArgs = recArgs + "int contextTid"
    %endif
  %endif
  
  %%
  %if (RTWCAPI == 1) && !GenerateClassInterface
    %if isCallSite
      %% Call-site here is model's S-function mdlStart function. The S-function
      %% is not the parent model. These args need to be set only by parentmodel
      %assign recArgs = recArgs + SLibGetNullDefinitionFromTfl()
      %assign recArgs = recArgs + SLibGetNullDefinitionFromTfl()
      %assign recArgs = recArgs + "0"
      %assign recArgs = recArgs + "-1"
    %else
      %assign recArgs = recArgs + "rtwCAPI_ModelMappingInfo *rt_ParentMMI"
      %assign recArgs = recArgs + "const char_T *rt_ChildPath"
      %assign recArgs = recArgs + "int_T rt_ChildMMIIdx"
      %assign recArgs = recArgs + "int_T rt_CSTATEIdx"
    %endif
  %endif
  
  %assign ::BlockFcn = "Unknown"

  %if ISEMPTY(recArgs)
    %if isCallSite
      %return ""
    %else
      %return "void"
    %endif
  %endif
  
  %return SLibSerializeFcnArgs(recArgs)
%endfunction %%SLibModelReferenceRegFcnArgs


%% Function: FcnGetNoncontMangledName ==========================================
%% Abstract:
%%  Get the mangled name for the array of noncontinuous signals.
%function FcnGetNoncontMangledName(name, systemIdx, blockIdx, instIdx) void
  %assign instance = instIdx < 0 ? 0 : instIdx
  %return "%<name>_%<systemIdx>_%<blockIdx>_%<instance>"
%endfunction

%% Function: FcnCheckForConstConsistency ======================================
%% Abstract:
%%    Check whether the model being called passes the signal as a non-const
%%    pointer, yet this signal is a const arg to this model's step function.
%%    block, argIdx, portIdx, and FPC all pertain to the submodel being called.
%function FcnCheckForConstConsistency(block, argIdx, portIdx, FPC) void
  %% See if the signal is passed to the child model by pointer or reference, 
  %% without a const qualifier; if not, exit.
  %if FPC.ArgSpecData[argIdx].Category != "Pointer" && ...
      FPC.ArgSpecData[argIdx].Category != "Reference"
    %return TLC_TRUE
  %endif
  %assign hasConstQualifier = TLC_FALSE
  %switch FPC.ArgSpecData[argIdx].Qualifier
    %case "none"
      %break
    %case "const"
    %case "const *"
    %case "const * const"
    %case "const &"
      %assign hasConstQualifier = TLC_TRUE
      %break
    %default
      %assign errTxt = "Unhandled qualifier"
      %<LibReportFatalError(errTxt)>
      %break
  %endswitch
  %if hasConstQualifier
    %return TLC_TRUE
  %endif
    
  %% If we get to this point, the child model passes the input by pointer or ref
  %% without a const qualifier.  Now see if the parent model or reusable
  %% subsystem declares the input with a const qualifier
  
  %assign portObj  = FcnGetInputPortRecord(portIdx)
  %% We only have to check element 0 because if the input to the mdlref block
  %% is discontiguous, we insert a hidden buffer, and then the signal can't be
  %% const.  We only can get const if the input arg is specified as const by FPC
  %% and passed directly into the mdlref block.
  %assign sigRecAndMapInfo = ...
    SLibGetSourceRecordAndMapInfo(portObj, 0, TLC_TRUE)

  %% See if the signal is coming from the root inport in the parent model; if not,
  %% no worry: it is not const.
  %if sigRecAndMapInfo.mapSrc == "U"
    %if ( SLibFcnProtoCtrlActive() && ...
          (CompiledModel.RTWFcnClass.Object.Class != "FcnDefault") ) || ...
        GenerateClassInterface
      %assign parentPortIdx = sigRecAndMapInfo.mapIdx
      %if !GenerateClassInterface
        %assign parentFPC = FcnGetFunctionPrototypeRecord()
      %else
        %%%% Parent model is using C++ Encapsulated Interface
        %assign parentFPC = FcnGetRTWCPPStepPrototypeRecord()
      %endif
      %assign parentArgIdx = parentFPC.inportsMapping[parentPortIdx]
      
      %% See if the parent model specifies a const qualifier with its inport; if it 
      %% does not, we can exit
      %assign hasConstQualifier = TLC_FALSE
      %switch parentFPC.ArgSpecData[parentArgIdx].Qualifier
        %case "none"
          %break
        %case "const"
        %case "const *"
        %case "const * const"
        %case "const &"
          %assign hasConstQualifier = TLC_TRUE
          %break
        %default
          %assign errTxt = "Unhandled qualifier"
          %<LibReportFatalError(errTxt)>
          %break
      %endswitch
      %if hasConstQualifier
        %return TLC_FALSE
      %else
        %return TLC_TRUE
      %endif

    %% Just a "vanilla" root input; no problem.
    %else
      %return TLC_TRUE
    %endif

  %% If a canonical input
  %elseif sigRecAndMapInfo.mapSrc == "u"
    %assign sigRec = sigRecAndMapInfo.sigRec
    
    %% Trouble if the canonical input is passed as const
    %if FcnPassCanonicalInputAsConst(sigRec)
      %return TLC_FALSE
    %else
      %return TLC_TRUE
    %endif
  %elseif sigRecAndMapInfo.mapSrc == "C"
    %%%% The source is a constant
    %return TLC_FALSE
  %else
    %return TLC_TRUE

  %endif

%endfunction


%function SLibAttachTimingArgsForCPPEncap(block, blockInterface, inArgs)
  %assert SLibIsCPPEncapMdlRefBuild() || ...
          (GenerateClassInterface && SLibIsLangCPPEncap(block.MdlRefTargetLang))
  
  %assign args = inArgs
  
  %if !IsModelReferenceForASimstructBasedTarget()
    %if blockInterface.NeedsGlobalTimingEngine
      %if IsModelReferenceTarget()
        %assign args = args + "%<SLibGetGlobalTimingBridge()>"
      %else
        %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
      %endif
    %endif
  %endif
  
  %% If the block is completely constant, then just 
  %% pass 0 as the TID.  If it is inherited, pass the 
  %% TID that this instance is running at.  This will 
  %% help with data logging.
  %if blockInterface.NeedsTIDArgs
    %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
    %if TYPE(block.TID) != "Identifier"
      %if LibAsynchronousTriggeredTID(block.TID)
        %% if it is in async fcn-call subsystem, 
        %% pass -1
        %assign args = args + "-1"
      %else
        %% constant is handled in the loop
        %foreach idx = NumSynchronousSampleTimes
          %assign childTID = MapParentTID2ChildTID(block, idx)
          %if childTID != -1
            %if IsModelReferenceTarget()
              %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<idx>]"
            %else
              %assign args = args + "%<idx>"
            %endif
          %endif
        %endforeach
      %endif
    %else
      %% There is only one TID in the model and it
      %% is constant/triggered, pass 0 if it is constant
      %% and pass -1 if it is triggered.
      %if ISEQUAL(block.TID, "triggered")
        %assign args = args + "-1"
      %else
        %assign args = args + "0"
      %endif
    %endif
    
    %if GetModelRefFcnCallTriggerTIDIsReq(block)
      %if SLibModelNeedsTriggerTIDArg()
        %assign args = args + "%<FcnGetMdlRefTriggerTIDMap("")>"
      %else
        %assert ISEQUAL(block.TID, "triggered") || ...
          LibAsynchronousTriggeredTID(block.TID)
        %if LibAsynchronousTriggeredTID(block.TID)
          %assign args = args + "%<block.TID>"
        %elseif IsModelReferenceTarget()
          %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<idx>]"
        %else
          %assign args = args + "%<block.TriggerTID>"
        %endif
      %endif
    %endif
  %endif

  %return args
  
%endfunction %%SLibAttachTimingArgsForCPPEncap

%% Function: SLibCallModelBlockFunction ========================================
%% Abstract::
%%   Contruct a string which is a call to some function in a referenced model.
%function SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, blockInterface, ...
  fcnInfo, instIdx, tid, childIdx, blkPath)
  %% Initially assume there is no outport returned by value (set retArgPortIdx to -1)
  %assign retArgPortIdx = -1
  %assign fcnName = fcnInfo.FcnName
  %assign args  = []
  %assign canInputInfo = fcnInfo.Inputs
  %assign canOutputInfo = fcnInfo.Outputs
  %assign canPrmArgInfo = fcnInfo.PrmArgs
  %assign baseSystemIdx = GetBaseSystemIdx()

  %% If we aren't generating the registration function, then
  %% instanceIdx must be 0 since we don't use it.
  %assert (sysFcnName == "RegistrationFcn") || (instIdx == 0)

  %assign TIDIdx = 0
  %assign RTModelIdx = 1
  %assign BlockIOIdx = 2
  %assign DWorkIdx   = 3
  %assign ContStatesIdx = 4
  %assign ContStatesDerivativeIdx = 5
  %assign ContStatesDisabledIdx   = 6
  %assign NonsampledZCIdx = 7
  %assign ZCEventIdx      = 8
  %%

  %% figure out which model block we're looking at
  %assign mdlRefIdx = -1
  %assign mSysIdx = 0
  %foreach rowIdx = SIZE(CompiledModel.ModelReferenceBlocks, 0)
    %assign mdlRefBlk = CompiledModel.ModelReferenceBlocks[rowIdx]
    %if ((BlockIdx[0] == mdlRefBlk[0]) && (BlockIdx[2] == mdlRefBlk[1]) && ...
      (instIdx == mdlRefBlk[2]))
      %assign mdlRefIdx  = rowIdx 
      %assign mdlRefInfo = CompiledModel.ModelReferenceBlocks[mdlRefIdx]
      %assign mSysIdx    = mdlRefInfo[0]
      %break
    %endif
  %endforeach

  %if LibIsDeploymentDiagram() 
      %assign timingBridgeName = "%<SLibDeploymentGetTimingBridgeName()>[%<mdlRefIdx>]"
  %endif
  
  %if (sysFcnName == "RegistrationFcn" && !IsSimstructBasedTarget())
    %if blockInterface.NeedsFirstTime
      %assign arg = "1"
      %assign args = args + "%<arg>"
    %endif
    
    %if blockInterface.NeedsErrorStatus
      %assign arg = "%<RTMGet("ErrorStatusPointer")>"
      %assign args = args + "%<arg>"
    %endif
    
    %if blockInterface.StopReqAccessed
      %if IsModelReferenceTarget()
	%assign arg = "rt_stopRequested"
      %else
        %assign arg = "%<RTMGet("StopRequestedPtr")>"
      %endif
      %assign args = args + "%<arg>"
    %endif
    
    %if TYPE(TID) == "Vector"
      %assign tid0 = TID[0]
    %else
      %assign tid0 = TID
    %endif
    %% For continuous time referenced models, pass the
    %% solverInfo to the submodel.  In the case of
    %% non-ERT top models, the solverInfo is a pointer
    %% in the rtModel, but for ERT it's not a pointer.
    %if (TYPE(tid0) == "Number" && LibIsContinuous(tid0)) || blockInterface.HasNonInlinedSfcn
      %if LibIsDeploymentDiagram()
        %% find task idx to whom is mapped TID0 of system mSysIdx
        %assign rtmIdx = SLibDeploymentGetTaskIndexForComponent(mSysIdx, 0)
      %endif
      %if IsModelReferenceTarget()
        %assign arg = "rt_solverInfo"
      %elseif SLibIsERTCodeFormat()
        %if LibIsDeploymentDiagram()
          %if !ISEQUAL(rtmIdx, -1)
            %assign rtmName = "%<SLibDeploymentGetTasksRTMVarName()>[%<rtmIdx>]" 
            %assign arg = "&(%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>)"
          %else
            %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
          %endif
        %else
          %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
        %endif
      %elseif LibIsDeploymentDiagram()
        %if !ISEQUAL(rtmIdx, -1)
          %assign rtmName = "%<SLibDeploymentGetTasksRTMVarName()>[%<rtmIdx>]" 
          %assign arg = "%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>"
        %else
          %assign arg = "%<RTMGet("RTWSolverInfo")>"
        %endif
      %else
        %assign arg = "%<RTMGet("RTWSolverInfo")>"
      %endif
      %assign args =  args + "%<arg>"
    %endif
    
    %if blockInterface.HasNonInlinedSfcn
      %if IsModelReferenceTarget()
        %assign arg = "rt_sfcnInfo"
      %elseif LibIsDeploymentDiagram()
        %assign arg = "(RTWSfcnInfo *)(%<SLibDeploymentGetTasksSfcnInfoVarName()>[%<mdlRefIdx>])"
      %else
        %assign arg = "(RTWSfcnInfo *)(%<RTMGet("RTWSfcnInfo")>)"
      %endif
      %assign args =  args + "%<arg>"
    %endif
  %endif
  %%
  %%
  %% TID
  %if fcnInfo.ArgInfo[TIDIdx] == 1
    %assert sysFcnName != "RegistrationFcn"
    %if ISEQUAL(tid,"")
      %assign arg = LibTID()
    %else
      %assign arg = %<tid>
    %endif
    %assign args = args + "%<arg>"
  %endif

  %if sysFcnName == "SetDimsFcn"
    %assign args = args + outAndRuleIdx[0]
    %assign args = args + outAndRuleIdx[1]
  %endif

  %assign FPC = []
  %if (sysFcnName == "OutputUpdateFcn") && ...
    !IsModelReferenceSimTarget()
    %assign FPC = blockInterface.FPC
  %endif
  %if !ISEMPTY(FPC)
    %assign fcnName = FPC.FunctionName
  %endif

  %if GenerateClassInterface && SLibIsLangCPPEncap(block.MdlRefTargetLang)
    %if sysFcnName == "RegistrationFcn"
      %assign fcnName = "initialize"
    %elseif sysFcnName == "InitializeFcn"
      %assign fcnName = "init"
    %elseif sysFcnName == "StartFcn"
      %assign fcnName = "start"
    %elseif sysFcnName == "TerminateFcn"
      %assign fcnName = "terminate"
    %elseif sysFcnName == "DisableFcn"
      %assign fcnName = "disable" 
    %elseif sysFcnName == "EnableFcn"
      %assign fcnName = "enable"
    %endif
    
    %assign mdlRefInstCPPVar = ...
      SLibGetCPPMdlRefObjName(System[BlockIdx[0]].SystemIdx,BlockIdx[2])
    
  %endif %% GenerateClassInterface && SLibIsLangCPPEncap(block.MdlRefTargetLang)
  
  %if ISEMPTY(FPC)
    %assign NumInputs = blockInterface.NumInputs
    %assign NumOutputs = blockInterface.NumOutputs
    %assign NumArgs = NumInputs + NumOutputs
  %else
    %assign NumArgs = SIZE(FPC.ArgSpecData,1)
  %endif
  %foreach argIdx = NumArgs
    %if ISEMPTY(FPC)
      %if argIdx < NumInputs
        %assign portIdx = argIdx
        %assign SLObjectType = "Inport"
      %else
        %assign portIdx = argIdx - NumInputs
        %assign SLObjectType = "Outport"
      %endif
    %else
      %assign portIdx = FPC.ArgSpecData[argIdx].PortNum
      %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
    %endif
    %if SLObjectType == "Inport"
      %if !ISEMPTY(FPC) || canInputInfo[portIdx] > 0
        %if sysFcnName == "RegistrationFcn"
          %assign dataPort = CompiledModel.ModelBlock[mdlRefIdx].DataInputPort[portIdx]        
          %assign id = IDNUM(dataPort.SignalSrc[0])
          %switch id[0]
            %case "y"
              %assign canOut = System[baseSystemIdx].Interface.CanonicalOutputArgDef[id[1]]
              %assign arg = LibGetRecordIdentifier(canOut)
              %<SLibAccessArgHelper(canOut,"","")>
              %if dataPort.SignalOffset[0] != 0
                %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
              %endif
              %break
            %case "u"
              %assign canIn = System[baseSystemIdx].Interface.CanonicalInputArgDef[id[1]]
              %assign arg = LibGetRecordIdentifier(canIn)
              %<SLibAccessArgHelper(canIn,"","")>
              %if dataPort.SignalOffset[0] != 0
                %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
              %endif
              %break
            %default            
              %with CompiledModel.ModelBlock[mdlRefIdx]
                %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
                %break
              %endwith
          %endswitch
          %assign args  = args + "%<arg>"
        %else
          %assign width = LibBlockInputSignalWidth(portIdx)
          %if width > 1 || (canInputInfo[portIdx] == 2) || ...
            (!ISEMPTY(FPC) && ...
             (FPC.ArgSpecData[argIdx].Category == "Pointer" || ...
              FPC.ArgSpecData[argIdx].Category == "Reference"))
              %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
            
              %assign dtypeName = LibBlockInputSignalDataTypeName(portIdx, "")

              %if !ISEMPTY(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
                %% pass by reference (C++) case
                %if width == 1
                  %% scalar signal
                  %assign arg = "*(" + arg + ")"
                %else
                  %assign arg = "(" + dtypeName + "(&)" + "[%<width>])" + "(" + "*(" + arg + ")" + ")"
                %endif                
              %endif
            
              %if !ISEMPTY(FPC) && ...
                !FcnCheckForConstConsistency(block, argIdx, portIdx, FPC)
                %if ::GenCPP
                  %if !ISEMPTY(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
                    %if !(width > 1)
                      %%%% scalar signal
                      %assign arg = "const_cast<" + dtypeName + "&>(" + arg + ")"
                    %endif
                  %else
                    %assign arg = "const_cast<" + dtypeName + "*>(" + arg + ")"
                  %endif
                %else
                  %assign arg = "(" + dtypeName + "*)" + arg
                %endif
                
                %if !SLibIsLangCPPEncap(block.MdlRefTargetLang)
                  %assign featureName = "Model step function prototype control"
                %else
                  %assign featureName = ...
                    "'I/O arguments step method' style of C++ encapsulation interface"
                %endif
              
                %assign refModelName = block.ParamSettings.ReferencedModelName
                
                %assign argName = FPC.ArgSpecData[argIdx].ArgName
                
                %assign warnstr = ...
                  "Model '" + refModelName + "' is being used as a referenced\n" + ...
                  "model through block '" + block.Name + "', and it is using the\n" + ...
                  featureName + ". The referenced\n" + ...
                  "model's root input argument '" + argName + "' does not have a 'const' qualifier,\n" + ...
                  "but its source signal in the parent model has a 'const' qualifier. To honor\n" + ...
                  "the referenced model's interface specification, a type cast has been inserted\n" + ...
                  "in the code for the parent model to discard the 'const' qualifier from the source\n" + ...
                  "signal. If this behavior is not desired, consider adding an appropriate 'const'\n" + ...
                  "qualifier to the '" + argName + "' argument of the referenced model."
                %<LibReportWarning(warnstr)>
              %endif
          %else
            %assign arg = LibBlockInputSignal(portIdx, "", "", 0)
          %endif
          %assign args  = args + "%<arg>"
        %endif
      %endif
      
      %assign args = AppendInputCanDimSizeDWForFunctionStr(portIdx, fcnInfo, sysFcnName, block, args)
    %else
      %if !ISEMPTY(FPC) || canOutputInfo[portIdx] == 1
        %assign passByPtr = ...
          ISEMPTY(FPC) || FPC.ArgSpecData[argIdx].Category == "Pointer"
        %assign passByRef = ...
          !ISEMPTY(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
    
        %if sysFcnName == "RegistrationFcn"
          %assign dataPort = CompiledModel.ModelBlock[mdlRefIdx].DataOutputPort[portIdx]
          %assign id = IDNUM(dataPort.SignalSrc[0])
          %switch (id[0])
            %case "y"
              %assign canOut = System[baseSystemIdx].Interface.CanonicalOutputArgDef[id[1]]
              %assign arg = LibGetRecordIdentifier(canOut)
              %<SLibAccessArgHelper(canOut,"","")>
              %if dataPort.SignalOffset[0] != 0
                %% must be passed as pointer arg to parent
                %assert canOut.PassByReturn == "no"
                %% if child takes as pointer ...
                %if passByPtr
                  %assign arg = "&%<arg>[%<dataPort.SignalOffset[0]>]"
                %% if child passes as return
                %else
                  %assign arg = "%<arg>[%<dataPort.SignalOffset[0]>]"
                %endif
              %endif
              %% if passed by return from parent ...
              %if canOut.PassByReturn == "yes"
                %% if child takes as pointer ...
                %if passByPtr
                  %assign arg = "&(%<arg>)"
                %% if child passes as return ...
                %else
                  %% do nothing
                %endif
              %% else passed to parent as arg ...
              %else
                %% if child takes as pointer ...
                %if passByPtr
                  %% do nothing
                %% if child passes as return ...
                %else
                  %assign arg = "*%<arg>"
                %endif
              %endif
              %break
            %case "b"
              %assign bo = BlockOutputs.GlobalBlockOutput[id[1]]
              %%
              %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
              %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
                baseSystemIdx, cross)
              %assign opW   = SLibGet1DArrayIndexer(LibGetRecordWidth(bo), "", "", dataPort.SignalOffset[0])
              %assign arg   = "%<name>%<opW>"
              %if passByPtr
                %assign arg = "&(%<arg>)"
              %endif
              %break
            %case "E"
              %if passByPtr
                %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
              %else
                %assign arg = LibBlockOutputSignal(portIdx, "", "", 0)
              %endif
              %break
          %endswitch
        %else
          %if passByPtr
            %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
          %elseif passByRef
            %% C++ pass by reference
            %assign width = LibBlockOutputSignalWidth(portIdx)
            %assign dtypeName = LibBlockOutputSignalDataTypeName(portIdx, "")
            %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
            %if width == 1
              %assign arg = "*(%<arg>)"
            %else
              %assign arg = "(" + dtypeName + "(&)" + "[%<width>])" + "(" + "*(" + arg + ")" + ")"
            %endif
          %endif
        %endif
        %if passByPtr || passByRef
          %assign args  = args + "%<arg>"
        %else
          %% If an output is not passed by pointer or ref, it is a return argument, passed by value;
          %% save the portIdx; assert that it is unassigned to this point
          %assert retArgPortIdx == -1
          %assign retArgPortIdx = portIdx
        %endif
      %endif
      %assign args = AppendOutputCanDimSizeDWForFunctionStr(portIdx, fcnInfo, sysFcnName, block, args)
    %endif
  %endforeach
  %%
  %% SimStruct and noncontinuous output array
  %if sysFcnName == "RegistrationFcn" && IsSimstructBasedTarget()
    %assign args = args + "%<tMdlRefSfcnS>"
    %if RTMIsVarStepSolver() && blockInterface.HasNonContOutput
      %assign name = block.ParamSettings.ReferencedModelName
      %assign mangleName = FcnGetNoncontMangledName(name, BlockIdx[0], ...
        BlockIdx[2], instIdx)
      %assign args = args + "mr_%<mangleName>nonContOutputArray"
    %endif
  %endif

  %% Pass the timing info to the registration function
  %% Note that we do not need to pass the timing bridge 
  %% for any simstruct based targets.  In this case the rtm 
  %% macros will automatically go through the parent 
  %% simstruct to get the timing bridge.  Note that this is
  %% called for both model reference targets, and models
  %% that contain model blocks.
  %if sysFcnName == "RegistrationFcn" && ...
      !SLibIsCPPEncapMdlRefBuild()
    %if !IsModelReferenceForASimstructBasedTarget() && ...
      SLibIsERTCodeFormat()
      %if blockInterface.NeedsGlobalTimingEngine
        %if IsModelReferenceTarget() 
          %assign args = args + "timingBridge"
        %elseif LibIsDeploymentDiagram()
          %assign args = args + "&%<timingBridgeName>"
        %else
          %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
        %endif
      %endif
    %endif
  
    %% If the block is completely constant, then just 
    %% pass 0 as the TID.  If it is inherited, pass the 
    %% TID that this instance is running at.  This will 
    %% help with data logging.
    %if blockInterface.NeedsTIDArgs
      %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
      %if TYPE(block.TID) != "Identifier"
        %if LibAsynchronousTriggeredTID(block.TID) && ...
          !ModelBlockHasAsyncInput(block.TID, block)
          %% if it is in async fcn-call subsystem, any
          %% blocks will access the base rate
          %assign args = args + "0"
        %else
          %% constant is handled in the loop
          %foreach idx = NumSampleTimes
            %assign childTID = MapParentTID2ChildTID(block, idx)
            %if childTID != -1
              %if IsModelReferenceTarget()
                %assign args = args + "mdlref_TID%<idx>"
              %else
                %if IsSimstructBasedTarget() && ...
                  LibAsynchronousTriggeredTID(idx)
                  %assign args = args + "0"
                %else
                  %assign args = args + "%<idx>"
                %endif
              %endif
            %endif
          %endforeach
        %endif
      %else
        %% There is only one TID in the model and it
        %% is constant/triggered, pass 0 if it is constant
        %% and pass -1 if it is triggered.
        %if ISEQUAL(block.TID, "triggered")
          %assign args = args + "-1"
        %else
          %assign args = args + "0"
        %endif
      %endif
    
      %if GetModelRefFcnCallTriggerTIDIsReq(block)
        %if SLibModelNeedsTriggerTIDArg()
          %assign args = args + "mdlref_TriggerTID"
        %else
          %assert ISEQUAL(block.TID, "triggered") || ...
            LibAsynchronousTriggeredTID(block.TID)
          %if LibAsynchronousTriggeredTID(block.TID)
            %assign args = args + "%<block.TID>"
          %elseif IsModelReferenceTarget()
            %assign args = args + "mdlref_TID%<block.TriggerTID>"
          %else
            %assign args = args + "%<block.TriggerTID>"
          %endif
        %endif
      %endif
    %endif
  %elseif sysFcnName == "RegistrationFcn" && SLibIsCPPEncapMdlRefBuild() && ...
          !SLibIsLangCPPEncap(block.MdlRefTargetLang)
    %% This case is the parent model is CPP Encap. 
    %% class, while the referenced
    %% model is CPP (Non-encap), and it is ModelReferenceRTWTarget. 
    %% We need to directly pass the 
    %% local global timing
    %% engine variable, which is already a pointer, to the 
    %% submodel_initialize function. The case of both parent/child 
    %% models being C++ encap. will be handled later by 
    %% setupGlobalTimingEngine 
    
    %assert IsModelReferenceRTWTarget()
    %assign args = SLibAttachTimingArgsForCPPEncap(block,blockInterface,args)
  
  %endif %% sysFcnName == "RegistrationFcn" && !SLibIsCPPEncapMdlRefBuild()

  %%
  %% RTModel
  %if fcnInfo.ArgInfo[RTModelIdx] == 1
    %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(block)
    %if sysFcnName == "RegistrationFcn"
      %assign dwRec = CompiledModel.DWorks.DWork[DWork[dworkIdx].FirstRootIdx]
      %assign varGroupIdx = FcnSysVarGroupIndex(System[BlockIdx[0]], ...
        "DWork", instIdx)
      %assign arg = SLibCGIRVarGroupPath(varGroupIdx, baseSystemIdx, ...
        System[BlockIdx[0]].CrossNoArgFcnBound)
      %assign arg = arg + LibGetRecordIdentifier(dwRec)
    %else
      %assign arg  =  LibBlockDWork(DWork[dworkIdx], "","","0")
    %endif
    %assign args = args + "&(%<arg>.rtm)"
  %endif
  %%
  %% BlockIO
  %if fcnInfo.ArgInfo[BlockIOIdx] == 1
    %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(block)
    %if sysFcnName == "RegistrationFcn"
      %assign dwRec = CompiledModel.DWorks.DWork[DWork[dworkIdx].FirstRootIdx]
      %assign varGroupIdx = FcnSysVarGroupIndex(System[BlockIdx[0]], ...
        "DWork", instIdx)
      %assign arg = SLibCGIRVarGroupPath(varGroupIdx, baseSystemIdx, ...
        System[BlockIdx[0]].CrossNoArgFcnBound)
      %assign arg = arg + LibGetRecordIdentifier(dwRec)
    %else
      %assign arg  =  LibBlockDWork(DWork[dworkIdx], "","","0")
    %endif
    %assign args = args + "&(%<arg>.rtb)"
  %endif
  
  %assign regFcn4MdlRefBlkCPPFromSubSys = ...
          sysFcnName == "RegistrationFcn" && ...
          SLibIsLangCPPEncap(block.MdlRefTargetLang) && ...
          !LibSystemIsRoot(System[BlockIdx[0]]) && ...
          !IsModelReferenceBaseSys(System[BlockIdx[0]]) &&...
          !IsModelRefScalableBuild()
        
  %%
  %% DWork
  %if fcnInfo.ArgInfo[DWorkIdx] == 1 || regFcn4MdlRefBlkCPPFromSubSys
    %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(block)
    %if sysFcnName == "RegistrationFcn"
      %assign dwRec = CompiledModel.DWorks.DWork[DWork[dworkIdx].FirstRootIdx]
      %assign varGroupIdx = FcnSysVarGroupIndex(System[BlockIdx[0]], ...
        "DWork", instIdx)
      %assign arg = SLibCGIRVarGroupPath(varGroupIdx, baseSystemIdx, ...
        System[BlockIdx[0]].CrossNoArgFcnBound)
      %if regFcn4MdlRefBlkCPPFromSubSys
        %assign mdlRefInstCPPVar = arg + mdlRefInstCPPVar
      %endif
      %assign arg = arg + LibGetRecordIdentifier(dwRec)
    %else
      %assign arg  =  LibBlockDWork(DWork[dworkIdx], "","","0")
    %endif
    %assign args = args + "&(%<arg>.rtdw)"
  %endif
  
  
  %if (sysFcnName == "RegistrationFcn") && ...
      GenerateClassInterface && SLibIsLangCPPEncap(block.MdlRefTargetLang) 
      
      %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
      
      %openfile tmp_file
        %%%% re-establish pointers for mdlref blocks in subsystems, if needed
        %if regFcn4MdlRefBlkCPPFromSubSys && ...
            CPPEncapNeedsLocalVars() && ...
            !blockInterface.IsScalableBuild
            %assign restoreCode = SLibGetCPPEncapInitCopyCode(TLC_FALSE)
            %<restoreCode>
        %endif
      

        %%%% this must be called early on
        %if blockInterface.RTMAccessed
          /* initialize real-time model for %<Type> Block: '%<Name>' */
          %<mdlRefInstCPPVar>%<dotOrArrow>initializeRTM();
        %endif

        %if blockInterface.NeedsErrorStatus
          /* Set error status pointer for %<Type> Block: '%<Name>' */
          %<mdlRefInstCPPVar>%<dotOrArrow>setErrorStatusPointer(%<RTMsGet(System[BlockIdx[0]],"ErrorStatusPointer")>);
        %endif
        %% Setup the stop requested flag
        %if blockInterface.StopReqAccessed
          /* initialize stop requested flag */
          %<mdlRefInstCPPVar>%<dotOrArrow>setStopRequestPointer(%<RTMsGet(System[BlockIdx[0]],"StopRequestedPtr")>);
        %endif
        
        %assign timingArgs = []
        
        %assign timingArgs = SLibAttachTimingArgsForCPPEncap(block,blockInterface,timingArgs)
        
        %if !ISEMPTY(timingArgs)
          %foreach idx = SIZE(timingArgs,1)
            %if idx == 0
              %assign fcnArgs = timingArgs[idx]
            %else
              %assign fcnArgs = fcnArgs + ", %<timingArgs[idx]>"
            %endif
          %endforeach
          %<mdlRefInstCPPVar>%<dotOrArrow>setupGlobalTimingEngine(%<fcnArgs>);
        %endif

        %assert block.ContStates[0] <= 0

        %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
          blockInterface.RegFcnNeedsCAPIArgs

          %if RTWCAPI == 1 && !block.ParamSettings.InsideForEachSS
            %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
            %assign fcnArgs = "%<arg1>," + "\"%<blkPath>\"," + ...
                              "%<childIdx>," + "-1"
          %else
            %assign capiArgs = []
            %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
            %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
            %assign capiArgs = capiArgs + "0"
            %assign capiArgs = capiArgs + "-1"
            
            %foreach idx = SIZE(capiArgs,1)
              %if idx == 0
                %assign fcnArgs = capiArgs[idx]
              %else
                %assign fcnArgs = fcnArgs + ", %<capiArgs[idx]>"
              %endif
            %endforeach
          %endif %% RTWCAPI == 1
        
          %<mdlRefInstCPPVar>%<dotOrArrow>setupCAPIInfo(%<fcnArgs>);
        %endif %%RegFcnNeedsCAPIArgs
        
        %<mdlRefInstCPPVar>%<dotOrArrow>initialize();
      %closefile tmp_file

      %return tmp_file
  %endif %%  (sysFcnName == "RegistrationFcn") && GenerateClassInterface && 
         %%  SLibIsLangCPPEncap(block.MdlRefTargetLang) 


  %% All the rest will be supported when ERT supports continuous states/time, we
  %% must test them when that is online.
  %%
  %% ContStates
  %if fcnInfo.ArgInfo[ContStatesIdx] == 1
    %assign cs  = CompiledModel.ContStates.ContState[ContStates[1]]
    %if sysFcnName == "RegistrationFcn"
      %assign varGroupIdx = FcnSysVarGroupIndex(System[BlockIdx[0]], ...
        "ContStates", instIdx)
      %if LibIsDeploymentDiagram() 
        %assign arg = SLibCGIRVarGroupPath(varGroupIdx, mSysIdx, ...
          System[BlockIdx[0]].CrossNoArgFcnBound)
      %else
        %assign arg = SLibCGIRVarGroupPath(varGroupIdx, baseSystemIdx, ...
          System[BlockIdx[0]].CrossNoArgFcnBound)
      %endif
      %assign arg = arg + cs.Identifier
      %assign intrf    = GetModelrefInterface(block)
      %assign optWidth = (intrf.xOptWidth > 1) ? "[0]" : ""
      %assign arg = "&(%<arg>%<optWidth>)"
    %else
      %assign arg  =  SLibContinuousStateAddr(cs, mSysIdx)
    %endif
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ContStatesDerivative
  %if fcnInfo.ArgInfo[ContStatesDerivativeIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg  =  SLibContinuousStateDerivativeAddr(mSysIdx)
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ContStatesDisabled
  %if fcnInfo.ArgInfo[ContStatesDisabledIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg = SLibContStateDisabledAddr(mSysIdx)
    %assign args = args + "%<arg>"
  %endif
  %%
  %% NonsampledZC
  %if fcnInfo.ArgInfo[NonsampledZCIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg  = SLibNonsampledZCAddr()
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ZCEvent
  %if fcnInfo.ArgInfo[ZCEventIdx] == 1
    %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(block)
    %if sysFcnName == "RegistrationFcn"
      %assign dwRec = CompiledModel.DWorks.DWork[DWork[dworkIdx].FirstRootIdx]
      %assign varGroupIdx = FcnSysVarGroupIndex(System[BlockIdx[0]], ...
        "DWork",  instIdx)
      %assign arg = SLibCGIRVarGroupPath(varGroupIdx, baseSystemIdx, ...
        System[BlockIdx[0]].CrossNoArgFcnBound)
      %assign arg = arg + LibGetRecordIdentifier(dwRec)
    %else
      %assign arg  =  LibBlockDWork(DWork[dworkIdx], "","","0")
    %endif
    %assign args = args + "&(%<arg>.rtzce)"
  %endif
  %%
  %% MassMatrix
  %if blockInterface.IsLinearlyImplicit
    %assert (CompiledModel.ModelIsLinearlyImplicit == "yes")
    %if (sysFcnName == "RegistrationFcn")
      %assign mmOffset = SLibBlockMassMatrixPrOffset("","",0)
      %if LibIsDeploymentDiagram()   
        %assign args = args + ...
          "&(%<SLibDeploymentGetTasksMassMatricesVarName()>[%<mdlRefIdx>].pr[%<mmOffset>])"
      %else
        %assign args = args + "&(%<LibGetMassMatrixGlobalPr()>[%<mmOffset>])"
      %endif
    %endif    
  %endif  
  %%
  %% Parameter Arguments
  %assign numPrmArgs = SIZE(fcnInfo.PrmArgs,1)
  %foreach argIdx=numPrmArgs
    %if canPrmArgInfo[argIdx] >= 1
      %assign param = block.Parameter[argIdx]
      %assign dtId = param.OriginalDataTypeIdx
      %%xxx Shouldn't this be cached in canPrmArgInfo?
      %if LibIsStructDataType(dtId)
	%assign arg   = LibBlockParameter(param, "", "", 0)
        %%IsModelReferenceTarget() or not same code
        %assign arg = "&%<arg>"
      %elseif canPrmArgInfo[argIdx] == 1 
	%assign arg   = LibBlockParameter(param, "", "", 0)
      %else
	%assign arg   = LibBlockParameterAddr(param, "", "", 0)
      %endif
      %assign args  = args + "%<arg>"
    %endif
  %endforeach

  %%
  %% CanDWork used for passing number of iterations of an Implicit Iterator Subsystem
  %%
  %assign args = AppendImplicitIterSubsysNumItersDWorkForFunctionStr(fcnInfo, sysFcnName, block, args)
 
  %%
  %% In the ModelReference initialization code we need to pass in the systemRan
  %% dwork pointer and the corresponding tid.  All this is already hanging off
  %% the DataMapInfo, so simply index in to the correct array(s).
  %%
  %if ((sysFcnName == "RegistrationFcn") && IsModelReferenceSimTarget())
    %assign descIdx = CompiledModel.System[BlockIdx[0]].DescSysIdx[instIdx]
    %assign contIdx = CompiledModel.SubsystemRanBC.ContextSysIdx[descIdx]
    %assign arg1 = "%<RTMGet("DataMapInfo")>.systemRan[%<contIdx>]"
    %assign arg2 = "%<RTMGet("DataMapInfo")>.systemTid[%<contIdx>]"
    %assign args =  args + "%<arg1>" + "%<arg2>"
  %endif
  
  %% For every child model, when C-API is selected we need to pass the parent 
  %% MMI structure to the child initialize function. The child MMI is cached
  %% inside the parent MMI. Also, the child model instance is assigned the 
  %% corresponding block path in the parent model. Need to pass the block path 
  %% and continous state start index (if states are logged). 
  %if (sysFcnName == "RegistrationFcn")
    %assign blockInterface = GetModelrefInterface(block)
    %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
      blockInterface.RegFcnNeedsCAPIArgs
      %if (RTWCAPI == 1) && !block.ParamSettings.InsideForEachSS
        %% The top model has C-API turned on, i.e. it defines a MMI structure.
        %% Need to pass a pointer of the parent MMI to the child model
        %if GenRTModel
          %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
        %else
          %%RSim does not use rtModel with the C-API
          %assign arg1 = "&(%<RSimRTWCAPIVarPtr>->mmi)"
        %endif
        %assign args = args + "%<arg1>" + "\"%<blkPath>\"" + "%<childIdx>"
        %if (block.ContStates[0] > 0)
          %% Search through all the global ContinuousStates to find the one that is associated
          %% with the Model block and instance to handle code reuse.
          %assign modelBlockSigSrc = [%<block.BlockIdx[0]>, %<instIdx>, %<block.BlockIdx[2]>]
          %with CompiledModel.ContStates
            %foreach csIdx = NumContStates
              %if ContState[csIdx].SigSrc == modelBlockSigSrc
                %assign csvIdx = ContState[csIdx].StartIndex
                %break
              %endif
            %endforeach
          %endwith
        %else
          %assign csvIdx = -1
        %endif
        %assign args = args + "%<csvIdx>"
      %else
        %% The top model has not defined a MMI pointer. Pass NULL pointers
        %% to the child model, if the child-model has a MMI structure
        %assign args = args + SLibGetNullDefinitionFromTfl() + SLibGetNullDefinitionFromTfl() + "0" + "-1"
      %endif %% RTWCAPI == 1
    %endif %% blockInterface.RegFcnNeedsCAPIArgs
  %endif %% Registration Functions
  
  %% Fill the return string fcnName(args, ...)
  %assign retStr = ""
  
  %if ISEMPTY(args)
    %% no input argument
    %if !GenerateClassInterface || !SLibIsLangCPPEncap(block.MdlRefTargetLang)
      %assign retStr = "%<retStr>%<fcnName>" + "()"
    %else
      %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)

      %if LibSystemIsRoot(System[BlockIdx[0]]) || ...
          IsModelReferenceBaseSys(System[BlockIdx[0]]) || ...
          sysFcnName == "RegistrationFcn" || ...
          IsModelRefScalableBuild()
        %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "()"
      %else
        %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
        %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
        %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "()"
      %endif
    %endif
  %else
    %if !GenerateClassInterface || !SLibIsLangCPPEncap(block.MdlRefTargetLang)
      %assign retStr = "%<retStr>%<fcnName>" + "("
    %else
      %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)

      %if LibSystemIsRoot(System[BlockIdx[0]]) || ...
          IsModelReferenceBaseSys(System[BlockIdx[0]]) ||...
          sysFcnName == "RegistrationFcn" ||...          
          IsModelRefScalableBuild() 
        %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "("
      %else
        %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
        %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
        %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "("
      %endif
    %endif
    
    %foreach idx = SIZE(args,1)
      %if idx == 0
        %% one input argument (no comma is needed)
        %assign retStr = retStr + args[idx]
      %else
        %assign retStr =  retStr + ", " + args[idx] 
      %endif
    %endforeach
    %assign retStr = retStr +  ")"
  %endif
  
  %if retArgPortIdx >= 0
    %assign retStr = LibBlockAssignOutputSignal(retArgPortIdx, "", "", 0, retStr)
  %elseif !WHITE_SPACE(retStr)
    %assign retStr = retStr + ";"
  %endif

  %return retStr
%endfunction


%% Function: GetFunctionStr  ==================================================
%% Abstract:
%%     The following order is used in FcnGetAdditionalArgs and
%%     FcnAddParametersAndReturn. We must use the same order:
%%           TID
%%           outputIdx (VarDims only)
%%           ruleIdx (VarDims only)
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==TRUE)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPIStates)
%%             
%function GetFunctionStr(block, sysFcn, instIdx, tid, childIdx, blkPath) 
  %assign sysFcnName = ISEQUAL(tid,"") ? ...
    "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
  %assign blockInterface = GetModelrefInterface(block)
  %assign fcnInfo = blockInterface.%<sysFcnName>

  %return SLibCallModelBlockFunction([], block, sysFcnName, blockInterface, ...
    fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetSetDimsFunctionStr(outAndRuleIdx, block, sysFcn, instIdx, tid, childIdx, blkPath) 
  %assign sysFcnName = ISEQUAL(tid,"") ? ...
    "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
  %assign blockInterface = GetModelrefInterface(block)
  %assign fcnInfo = blockInterface.%<sysFcnName>

  %return SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, blockInterface, ...
    fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetModelRefFcnCallTriggerTIDIsReq(block) void
  %assign blockInterface = GetModelrefInterface(block)
  %return blockInterface.FcnCallMdlRefTriggerTIDIsReq
%endfunction

%% Function: GetModelRefFcnNeedsTID  ===========================================
%% Abstract:
%%     Returns whether this function uses TID in the argument list, we only
%% need to check this for the update and output functions.
%function GetModelRefFcnNeedsTID(block, sysFcn)
  %assert (sysFcn == "UpdateFcn") || (sysFcn == "OutputFcn") || ...
    (sysFcn == "OutputUpdateFcn")
  %% Note that the TIDidx must match the index in GetFunctionStr above.
  %assign TIDIdx = 0
  %assign needsTID = 0

  %with block
    %assign blockInterface = GetModelrefInterface(block)
    %if ISFIELD(blockInterface, "%<sysFcn>")
      %assign needsTID = blockInterface.%<sysFcn>.ArgInfo[TIDIdx]
    %endif
  %endwith
  %return needsTID
%endfunction

%% Function: CallModelrefBlockRegFcns  =========================================
%% Abstract:
%%    Call all child model reference block registration functions.  Note
%% that the input mdlRefBlks can be empty.
%function CallModelrefBlockRegFcns(mdlRefBlks)
  %openfile modelrefBuffer
  %assign baseSysIdx = GetBaseSystemIdx()
  %if !ISEMPTY(mdlRefBlks)
    %% First determine if any of the model blocks in this
    %% model need the global timing engine.
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]
      %with System[mSysIdx].Block[bIdx]
        %assign blk = System[mSysIdx].Block[bIdx]
        %assign blockInterface = GetModelrefInterface(blk)
        %if blockInterface.NeedsGlobalTimingEngine
          %assign ::tMdlRefTimingBridgeAccessed = TLC_TRUE
          %break
        %endif
      %endwith
    %endforeach
    
    %if !LibIsDeploymentDiagram() 
    %% We only need to declare a local timing bridge
    %% for ERT based targets.  If the target is simstruct based
    %% (like RSIM), then the simstruct will already have a timing bridge.
    %if !IsModelReferenceTarget() && SLibIsERTCodeFormat() && ...
      ::tMdlRefTimingBridgeAccessed
      %assign timingVar = "rtTimingBridge %<SLibGetGlobalTimingBridge()>;"
      %<SLibCacheCodeToFile("mdl_data_defn", timingVar)>
      %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", "extern " + timingVar)>
      {
        %% Determine if any clockticks are needed.  Note that if a long clock
        %% tick is needed, then the normal clock tick is also needed since they
        %% come in pairs.
        %assign needClockTicks = TLC_FALSE
        %assign needLongClockTicks = TLC_FALSE
        %foreach idx = NumSynchronousSampleTimes
          %if ClockTickForTIDIsReqFcn(idx)
            %assign needClockTicks = TLC_TRUE
            %if LongClockTickForTIDIsReqFcn(idx)
              %assign needLongClockTicks = TLC_TRUE
              %break
            %endif
          %endif
        %endforeach
        
        %if needClockTicks
          static uint32_T *clockTickPtrs[%<NumSampleTimes>];
          %if needLongClockTicks
            static uint32_T *clockTickHPtrs[%<NumSampleTimes>];
          %endif
        %endif    
        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
          static real_T *taskTimePtrs[%<NumSampleTimes>];
        %endif
        %if CompiledModel.SingleRate != "yes" 
          %if RTMTaskCountersIsReqFcn()
            static uint32_T *taskCounterPtrs;
          %endif
          %if ERTPerTaskSampleHitsIsReqFcn()
            %assign rateTransitionSize = ...
              "(%<NumSynchronousSampleTimes> * %<NumSynchronousSampleTimes>)"
            static boolean_T *rateTransitionPtrs[%<rateTransitionSize>];
          %endif
        %endif
        
        %<SLibGetGlobalTimingBridge()>.nTasks = %<NumSampleTimes>;
        
        %if needClockTicks
          %foreach idx = NumSampleTimes
            %if ClockTickForTIDIsReqFcn(idx)
              clockTickPtrs[%<idx>] = &(%<RTMGet("ClockTick%<idx>")>);
            %else
              clockTickPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
            %endif
            %if needLongClockTicks
              %if LongClockTickForTIDIsReqFcn(idx)
                clockTickHPtrs[%<idx>] = &(%<RTMGet("ClockTickH%<idx>")>);
              %else
                clockTickHPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
              %endif
            %endif
          %endforeach
          %<SLibGetGlobalTimingBridge()>.clockTick = clockTickPtrs;
          %if needLongClockTicks
            %<SLibGetGlobalTimingBridge()>.clockTickH = clockTickHPtrs;
          %else
            %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
          %endif
        %else
          %<SLibGetGlobalTimingBridge()>.clockTick = %<SLibGetNullDefinitionFromTfl()>;
          %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
        %endif
        
        %if CompiledModel.SingleRate != "yes" 
          %if RTMTaskCountersIsReqFcn()
            %assign cTick = RTMGet("TaskCounters")
            taskCounterPtrs = ...
              &(%<cTick>.%<SLibERTMultiRateCounterField(0)>);
            %<SLibGetGlobalTimingBridge()>.taskCounter = taskCounterPtrs;
          %endif        
          %if ERTPerTaskSampleHitsIsReqFcn()
            %assign shMat = RTMGet("PerTaskSampleHits")
            %foreach i = NumSynchronousSampleTimes 
              %foreach j = NumSynchronousSampleTimes
                %if SLibGetNeedRateInteraction(i,j)
                  %if SuppressMultiTaskScheduler
                    %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                      "b_%<SLibERTMultiRateTimingField(j,i)>"
                  %else
                    %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                      "%<SLibERTMultiRateTimingField(j,i)>"
                  %endif
                  rateTransitionPtrs[%<i>*%<NumSynchronousSampleTimes> + %<j>] \ 
                  = &(%<val>);
                %endif
              %endforeach
            %endforeach
            %<SLibGetGlobalTimingBridge()>.rateTransition = rateTransitionPtrs;
          %endif
        %endif
        
        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
          %foreach idx = NumSampleTimes 
            %if SampleTime[idx].NeedFloatTime == "yes"
              taskTimePtrs[%<idx>] = &(%<LibGetTaskTime(idx)>);
            %else
              taskTimePtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
            %endif
          %endforeach
          %<SLibGetGlobalTimingBridge()>.taskTime = taskTimePtrs;
        %endif
        
        %if RTMFirstInitCondFlagIsReqFcn()
          %<SLibGetGlobalTimingBridge()>.firstInitCond = &%<RTMIs("FirstInitCond")>;
        %endif        
      }
    %endif
  %endif %% !LibIsDeploymentDiagram()
  %endif
  
  %if LibIsDeploymentDiagram() 
    %assign buf = SLibDeploymentCallModelrefBlockRegFcns(mdlRefBlks)
    %if !WHITE_SPACE(buf)
      %<buf>
    %endif
  %else
    %with System[baseSysIdx]
    %foreach rowIdx = SIZE(mdlRefBlks,0)
       %assign mdlRefInfo = mdlRefBlks[rowIdx]
       %assign mSysIdx = mdlRefInfo[0]
       %assign bIdx    = mdlRefInfo[1]
       %assign instIdx = mdlRefInfo[2]
       %with System[mSysIdx].Block[bIdx]
	 %assign blk = System[mSysIdx].Block[bIdx]
	 %assign blockInterface = GetModelrefInterface(blk)
         %assign doSSInitCacheClose = TLC_FALSE
         %if instIdx != -1
           %assign standaloneSysIdx = System[mSysIdx].StandaloneParentSysIdx[instIdx]
           %if standaloneSysIdx != -1 
             %% cache registration fcn to parent standalone initialize fcn
             %openfile stdSSBuffer
             %assign doSSInitCacheClose = TLC_TRUE
           %endif
         %endif

         %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]
         %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))
         %if ISFIELD(blockInterface, "RegistrationFcn")
           /* Model Initialize fcn for %<Type> Block: '%<Name>' */
           %<SLibMdlRefIfNetPreprocessorCondition(System[mSysIdx].Block[bIdx])>
           %assign mdlBlk = CompiledModel.ModelBlock[rowIdx]
           %if ISFIELD(mdlBlk, "ForEachSSLoopBnds")
             %assign ::NeedForEachLoopInReg = TLC_TRUE
             %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlk.ForEachSSLoopBnds,1)
             %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
             {
             %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
               %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
               %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                 int32_T %<iterVar>;
                 for (%<iterVar> = 0; %<iterVar> < %<mdlBlk.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
             %endforeach
             %assign ::ForEachLoopHierarchyLevel = 1
           %endif
           %<GetFunctionStr(System[mSysIdx].Block[bIdx], ...
             "Registration", instIdx, "", rowIdx, bpath)>
           %if ISFIELD(mdlBlk, "ForEachSSLoopBnds")
             %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                 }
             %endforeach
             }
             %assign ::NeedForEachLoopInReg = TLC_FALSE
           %endif
           %<SLibMdlRefEndIfNetPreprocessorCondition(System[mSysIdx].Block[bIdx])>
         %endif
         %if (CompiledModel.RTWStatesLogging || MatFileSignalLogging) && ...
           !IsModelReferenceTarget() && !System[mSysIdx].Block[bIdx].ParamSettings.InsideForEachSS
           %if GenRTModel
             %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
           %else
             %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
           %endif
           %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<rowIdx>)"
           { 
             /* MAT-file logging: Update full-paths stored in the MMI */
             %assign bpath_unmangled  = STRING(SLibGrBlockPath(tmpVec))
             char_T *tempStr = rtwCAPI_EncodePath("%<bpath_unmangled>");
             rtwCAPI_UpdateFullPaths((%<childMMI>), tempStr, 1);
             utFree(tempStr);
           } 
         %endif
         
         %if doSSInitCacheClose
           %closefile stdSSBuffer
           %<LibAddToSystemField(System[standaloneSysIdx],"CachedInitializeDataBody",...
             "\n" + stdSSBuffer+ "\n")>
         %endif

       %endwith
     %endforeach
     %% We need to dump again ground declarations for model reference. 
     %% This case happens when a scalar Ground signal is feeding a Reusable
     %% subsystem and the reusable subsystem contains a Model Reference
     %% Block
     %%            -------------------
     %%           |     ----------    |
     %%  Grnd sig |    |          |   |
     %%  -------->|--->|          |   |
     %%           |    |          |   |
     %%           |    |          |   |
     %%      ---->|--->|          |   |
     %%  Grnd Sig |    |          |   |
     %%           |     ----------    |
     %%           |     Model Block   |
     %%            -------------------
     %%             Reusable Subsystem
     
     %<SLibCacheCodeToFile("mdl_data_defn", LibDumpGroundDeclarations(0))>
   %endwith
  %if ((RTWCAPI == 1)  && IsModelReferenceTarget()) && !GenerateClassInterface
    %assign mmiStr = "%<RTMGetModelSS()>->DataMapInfo.mmi"
    /* Initialize Parent model MMI */
    if ((rt_ParentMMI != %<SLibGetNullDefinitionFromTfl()>) && (rt_ChildPath != %<SLibGetNullDefinitionFromTfl()>))
    {
      rtwCAPI_SetChildMMI(*rt_ParentMMI, rt_ChildMMIIdx, &(%<mmiStr>));
      rtwCAPI_SetPath(%<mmiStr>, rt_ChildPath);
      rtwCAPI_MMISetContStateStartIndex(%<mmiStr>, rt_CSTATEIdx);
    }
  %endif
   %if IsModelReferenceForASimstructBasedTarget()
     %if EXISTS(SolverResetInfo) && SolverResetInfo.NumNonContDerivSignals > 0
      %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
      %assign arrayIdx = 0
      %foreach idx =  numNoncontDerivSigs
        %assign dU = SolverResetInfo.NonContDerivSignal[idx]
        %if ISFIELD(dU,"MdlRefInfo")
          %assign mdlRefInfo = dU.MdlRefInfo
          %assign mSysIdx = mdlRefInfo[0][0]
          %assign bIdx    = mdlRefInfo[0][1]
          %assign instIdx = mdlRefInfo[0][2]
          %assign port    = mdlRefInfo[0][3]
          %assign blk = System[mSysIdx].Block[bIdx]
          %assign name = blk.ParamSettings.ReferencedModelName
          %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
            bIdx, instIdx)
          %foreach subIdx = dU.NumMdlRefNonContSigs
            %<RTMSetNonContDerivSignal(arrayIdx,...
              "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].sizeInBytes", ...
              "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].currVal")>;
            %assign arrayIdx = arrayIdx + 1
          %endforeach
        %else
          %if dU.ComplexSignal
            %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
          %else
            %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
          %endif
          %% For NonContDerivSignal inside For Each subsystem, we need to
          %% index each For Each vargroup level by right index
          %if ISFIELD(dU, "ForEachSSIterIndices")
            %assign ::UseConstantForVarGroupIdx = TLC_TRUE
            %assign ::VarGroupIndexVector = dU.ForEachSSIterIndices
            %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
            %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
          %endif
          %<RTMSetNonContDerivSignal(arrayIdx,...
            "%<dU.RegionLen>*sizeof(%<dtype>)", ...
            "%<GetNonContAddress(dU, System[baseSysIdx])>")>;
          %if ISFIELD(dU, "ForEachSSIterIndices")
            %assign ::UseConstantForVarGroupIdx = TLC_FALSE
            %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
          %endif
          %assign arrayIdx = arrayIdx + 1
        %endif
      %endforeach
    %endif
    %if EXISTS(SolverResetInfo) &&  ISFIELD(SolverResetInfo,"NonContOutputSignals")
      %foreach idx = ExternalOutputs.NumExternalOutputs
        %assign nonContOut = ...
          SolverResetInfo.NonContOutputSignals.NonContOutput[idx]
        %assign numNonContSigs = ISFIELD(nonContOut,"NonContOutputSignal") ? ...
          SIZE(nonContOut.NonContOutputSignal,1) : 0
        %assign arrayIdx = -1
        %foreach cIdx =  numNonContSigs
          %assign nonContElem = nonContOut.NonContOutputSignal[cIdx]
          %assign regLen = nonContElem.RegionLen
          %if nonContElem.ComplexSignal
            %assign dType = LibGetDataTypeComplexNameFromId(nonContElem.DataTypeIdx)
          %else
            %assign dType = LibGetDataTypeNameFromId(nonContElem.DataTypeIdx)
          %endif
          %% If this signal is coming from a submodel, then we 
          %% can't initialize it here.  We will initialize the
          %% information after we call the submodels registration function
          if (mr_nonContOutputArray[%<idx>] != %<SLibGetNullDefinitionFromTfl()>) {
            %if ISFIELD(nonContElem,"MdlRefInfo") 
              %assign mdlRefInfo = nonContElem.MdlRefInfo
              %assign mSysIdx = mdlRefInfo[0][0]
              %assign bIdx    = mdlRefInfo[0][1]
              %assign instIdx = mdlRefInfo[0][2]
              %assign port    = mdlRefInfo[0][3]
              %assign blk = System[mSysIdx].Block[bIdx]
              %assign name = blk.ParamSettings.ReferencedModelName
              %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
                bIdx, instIdx)
              %foreach mIdx = nonContElem.NumMdlRefNonContSigs
                %assign arrayIdx = arrayIdx + 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                  mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].sizeInBytes;
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = ...
                  mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].currVal;
                %% If this is the last array, set the next pointer to NULL
                %if cIdx == numNonContSigs - 1 && ...
                  mIdx == nonContElem.NumMdlRefNonContSigs -1 
                  mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
                %else
                  %assign nextIdx = arrayIdx + 1
                  mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                    &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
                %endif
              %endforeach
            %else
              %% For NonContDerivSignal inside For Each subsystem, we need to
              %% index each For Each vargroup level by right index
              %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_TRUE
                %assign ::VarGroupIndexVector = nonContElem.ForEachSSIterIndices
                %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign address = GetNonContAddress(nonContElem, ...
                CompiledModel.System[GetBaseSystemIdx()])
              %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_FALSE
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign arrayIdx = arrayIdx + 1
              mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                %<regLen>*sizeof(%<dType>);
              mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = (char_T *)%<address>;
              %if cIdx ==  numNonContSigs - 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
              %else
                %assign nextIdx = arrayIdx + 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                  &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
              %endif
            %endif
          }
        %endforeach
      %endforeach
    %endif
  %endif
  %endif
  %closefile modelrefBuffer
  %return modelrefBuffer
%endfunction %%CallModelrefBlockRegFcns

%% Function: GetNonContAddress ================================================
%% Abstract:
%%  Returns the address of the signal which is used to track a noncontinuous
%% signal feeding an integrator.
%function GetNonContAddress(du, ss)
  %assign sigSrc  = du.SigSrc
  %assign startEl = du.StartEl
  %assign regLen  = du.RegionLen
  %assign idNum = IDNUM(sigSrc)
  %%
  %switch idNum[0]
      %% Note: no need for "u" because the top model will
      %% check for the reset in this case.  
    %case "y"
      %assign opIdx        = idNum[1]
      %assign interface    = ss.Interface
      %assign canOutputArg = interface.CanonicalOutputArgDef[opIdx]
      %assign name  = LibGetRecordIdentifier(canOutputArg)
      %assign addr  = "&%<name>[%<startEl>]"
      %<SLibAccessArgHelper(canOutputArg,"",ss.CurrentTID)>
      %break
    %default
      %assign bo = BlockOutputs.GlobalBlockOutput[idNum[1]]
      %assert (bo.Invariant == "no")
      %assert (LibGetRecordWidth(bo) >= regLen + startEl)
      %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
      %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
        ss.SystemIdx, cross)
      %assign opW   = (LibGetRecordWidth(bo) == 1) ? "" : "[%<startEl>]"
      %assign addr  = "&%<name>%<opW>"
      %break
  %endswitch
  %return addr
%endfunction


%% Function: CallModelrefBlockFreeFullPaths  ===================================
%% Abstract:
%%    Call rtwCAPI_SetFreeFullPaths
%function CallModelrefBlockFreeFullPaths(mdlRefBlks)
  %openfile modelrefBuffer
  %if (CompiledModel.RTWStatesLogging || MatFileSignalLogging == 1) &&  ...
    !IsModelReferenceTarget() && HasModelReferenceBlocks()
  %assign baseSysIdx = GetBaseSystemIdx()
  %with System[baseSysIdx]
     %foreach rowIdx = SIZE(mdlRefBlks,0)
       %% This does a deep dive so we only want to do it
       %% for the top (note: the engine takes care of this in sim)
       %if GenRTModel
         %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
       %else
         %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
       %endif
       %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<rowIdx>)"
       rtwCAPI_FreeFullPaths((%<childMMI>));
     %endforeach
   %endwith
   %endif
   %closefile modelrefBuffer
   %return modelrefBuffer
%endfunction %%CallModelrefBlockFreePath


%% Function: GenModelReferenceSimTargetSFcnOutputOrUpdate =====================
%%
%function GenModelReferenceSimTargetSFcnOutputOrUpdate(sysFcn)

  %assert (IsModelReferenceSimTarget())
  %openfile tmpBuffer

  %assert(::BlockFcn == sysFcn)
  %assert(sysFcn == "Output" || sysFcn == "Update")

  %assign subsys = System[NumSystems-2]
  %openfile TimeCondBuf
  %if NumSampleTimes > 1 && LibSystemFcnNeedsTID(subsys, sysFcn)
    %<DumpTimeConditioningCode()>
  %endif
  %closefile TimeCondBuf
  %%
  %with System[NumSystems-1]
    %if !SLibSystemFcnRateGrouping(System[NumSystems-1], sysFcn)
      %if !LibSystemFcnIsEmpty(subsys, sysFcn)
	%% non-rate grouping code
	%if NumSynchronousSampleTimes > 1 && LibSystemFcnNeedsTID(subsys, sysFcn)
	  %<TimeCondBuf>
	%endif
	%<LibGenSystemFcnCall(subsys, sysFcn, 0)>
        %if !SLibModelOutputSizeDependOnlyInputSize()
          %assign cTID = subsys.CurrentTID
          %assign isRG = SLibSystemFcnRateGrouping(subsys, sysFcn)
          %<SLibGenOutportCurrentDimsWrites(sysFcn, cTID, isRG)>
        %endif
      %endif
    %else
      %<TimeCondBuf>
      %foreach tid = NumSynchronousSampleTimes
	%assign subsys.CurrentTID = (NumSynchronousSampleTimes > 1) ? tid : ""
	%if !LibSystemFcnIsEmptyForTID(subsys, sysFcn)
	  %openfile tmpBuf
	  %<LibGenSystemFcnCall(subsys, sysFcn, 0)>
          %if !SLibModelOutputSizeDependOnlyInputSize()
            %assign cTID = subsys.CurrentTID
            %assign isRG = SLibSystemFcnRateGrouping(subsys, sysFcn)
            %<SLibGenOutportCurrentDimsWrites(sysFcn, cTID, isRG)>
          %endif
	  %closefile tmpBuf
	  %if !WHITE_SPACE(tmpBuf)
	    %if sysFcn == "Output" && LibIsContinuous(tid)
	      if (ssIsSampleHit(S, %<tid>, %<CompiledModel.GlobalScope.tTID>) || ssIsMinorTimeStep(S)) {
		%<tmpBuf>
	      }
	    %else
	      if (ssIsSampleHit(S, %<tid>, %<CompiledModel.GlobalScope.tTID>)) {
		%<tmpBuf>
	      }
	    %endif
	  %endif
	%endif
      %endforeach
      %assign subsys.CurrentTID = -1
    %endif
  %endwith
  %closefile tmpBuffer
  %return(tmpBuffer)
%endfunction %% GenModelReferenceSimTargetSFcnOutputOrUpdate

%% Function: SLibGenModelRefGlobalParamReg ====================================
%% Abstract:
%%
%function SLibGenModelRefGlobalParamReg() void

  %assign s = "S"
  %assign nTunableParams = 0

  %with CompiledModel.ModelParameters
    %assert (NumInrtP == (NumParameters - NumConstPrmsWithInit - NumConstPrms))    
    %openfile regBufferBody
    %foreach prmIdx=NumInrtP
      %assign param = Parameter[prmIdx]
      %if (param.Tunable == "yes")
	%assign identi = LibGetRecordIdentifier(param)
	%assign isComplex = LibGetRecordIsComplex(param)
	%%
	%% Special handling for dimensions
	%%
	%assign dims = LibBlockParameterDimensions(param)
	%assign nDims = SIZE(dims, 1)
	%assign dimsStr = "%<dims[0]>"
	%foreach prevIdx = nDims-1
	  %assign nextDim = dims[prevIdx+1]
	  %assign dimsStr = "%<dimsStr>,%<nextDim>"
	%endforeach
	{
	  int_T locDims[%<nDims>] = {%<dimsStr>};
	  %%
	  %% Special handling for data type
	  %%
	  %assign dtStr = ""
	  %assign dtId = param.OriginalDataTypeIdx
	  %assert (dtId != -1)
	  %if LibIsBuiltInDataType(dtId)
	    %assign dtStr = LibGetDataTypeEnumFromId(dtId)
	    %%
	  %elseif LibIsEnumDataType(dtId)
	    %assign dtName = LibGetDataTypeNameFromId(dtId)
	    DTypeId dtId = INVALID_DTYPE_ID;
	    ssRegisterTypeFromNamedObject(%<s>, "%<dtName>", &dtId);
	    if(dtId == INVALID_DTYPE_ID) return;
	    %assign dtStr = "dtId"
	  %endif
	  %%
	  %if !WHITE_SPACE(dtStr)
	    ssRegModelRefGlobalParam( \
	    %<s>, \
	    %<nTunableParams>, \
	    "%<identi>", \
	    %<nDims>, \
	    locDims, \
	    %<isComplex>, \
	    %<dtStr>);
	  %elseif LibIsStructDataType(dtId) && !LibIsDataTypeFixpt(dtId)
	    %assign dtChecksum = DataTypes.DataType[dtId].StructDtChecksum
            %assign dtChecksumStr = ...
              "%<dtChecksum[0]>,%<dtChecksum[1]>,%<dtChecksum[2]>,%<dtChecksum[3]>"
            %assign dtName = LibGetDataTypeNameFromId(dtId)
            %assign isAnonymous = !SLibDataTypeIsNonAnonymousBus(dtId)
            %%
            uint32_T dtChecksum[4] = {%<dtChecksumStr>};
	    ssRegModelRefStructGlobalParam( \
	    %<s>, \
	    %<nTunableParams>, \
	    "%<identi>", \
	    %<nDims>, \
	    locDims, \
	    %<isComplex>, \
	    dtChecksum, \
            "%<dtName>", \
            %<isAnonymous>);
	  %else %% Fixed-point
	    %%
	    %assign curDT = FixPt_GetDataTypeFromIndex(dtId)
	    %%
	    %if curDT.IsFixedPoint
	      %assign dtOverride = 0
	      %if FixPt_DataTypeIsFloat(curDT)
		ssRegModelRefScaledDoubleGlobalParam( \
	      %else
		ssRegModelRefFixptGlobalParam( \
	      %endif
	      %<s>, \
	      %<nTunableParams>, \
	      "%<identi>", \
	      %<nDims>, \
	      locDims, \
	      %<isComplex>,
	      %<curDT.IsSigned>, \
	      %<curDT.RequiredBits>, \
	      %<curDT.FracSlope>, \
	      %<curDT.FixedExp>, \
	      %<curDT.Bias>, \
	      %<dtOverride>);
	    %else
	      %assign errTxt = ...
		"User-defined data types not supported for interface parameters."
	      %<LibReportFatalError(errTxt)>
	    %endif
	  %endif
	}
	%assign nTunableParams = nTunableParams+1
      %endif %% (param.Tunable == "yes")
    %endforeach %% prmIdx=NumInrtP
    %closefile regBufferBody
  %endwith %% CompiledModel.ModelParameters
  
  %openfile regBuffer
  /* ModelRef: Global parameters */
  
  %assign globalParams = CompiledModel.ModelParameters.GlobalParamsList
  %if !ISEMPTY(globalParams)
    %assign comma = ""
    %assign newline = ""
    %assign varList = ""
    %foreach idx = SIZE(globalParams,1)
      %assign varList = varList + comma + newline + "\"" + globalParams[idx] + "\"" 
      %assign comma = ", "
      %assign newline = "\n"
    %endforeach
    {
      static const char *globalVarList[] = {%<varList>};
      ssRegModelRefGlobalVarUsage(%<s>, %<SIZE(globalParams,1)>, (void *)globalVarList);
    }  
  %endif

  %if nTunableParams > 0
    if (!ssSetNumModelRefGlobalParams(S, %<nTunableParams>)) return;

    %<regBufferBody>
  %endif
  
  %closefile regBuffer

  %return regBuffer
%endfunction %% SLibGenModelRefGlobalParamReg

%% Function: SLibGenModelRefParamArgReg =======================================
%% Abstract:
%%
%function SLibGenModelRefParamArgReg(sys) void

  %assign s = "S"

  %openfile regBuffer
  %with sys.Interface
    %if NumCanonicalPrmArgDefs > 0
      /* ModelRef: Parameter arguments */
      if (!ssSetNumModelRefParamArgs(S, %<NumCanonicalPrmArgDefs>)) return;

      %foreach argIdx=NumCanonicalPrmArgDefs
	%assign canPrmDef = CanonicalPrmArgDef[argIdx]
	%assign identi = LibGetRecordIdentifier(canPrmDef)
	%assign isComplex = LibGetRecordIsComplex(canPrmDef)
	%assign isUsed = (canPrmDef.IsUsed == "yes")
	%%
	%% Special handling for dimensions
	%%
	%assign dims   = LibBlockParameterDimensions(canPrmDef)
	%assign nDims  = SIZE(dims, 1)
	%assign dimsStr = "%<dims[0]>"
	%foreach prevIdx = nDims-1
	  %assign nextDim = dims[prevIdx+1]
	  %assign dimsStr = "%<dimsStr>,%<nextDim>"
	%endforeach
	{
	  int_T locDims[%<nDims>] = {%<dimsStr>};
	  %%
	  %% Special handling for data type
	  %%
	  %assign dtStr = ""
	  %assign dtId = canPrmDef.OriginalDataTypeIdx
	  %if (dtId == -1)
	    %assert (isUsed == 0)
	    %assign dtStr = "DYNAMICALLY_TYPED"
	  %elseif LibIsBuiltInDataType(dtId)
	    %assign dtStr = LibGetDataTypeEnumFromId(dtId)
	    %%
	  %elseif LibIsEnumDataType(dtId)
	    %assign dtName = LibGetDataTypeNameFromId(dtId)
	    DTypeId dtId = INVALID_DTYPE_ID;
	    ssRegisterTypeFromNamedObject(%<s>, "%<dtName>", &dtId);
	    if(dtId == INVALID_DTYPE_ID) return;
	    %assign dtStr = "dtId"
	  %endif
	  %%
	  %if !WHITE_SPACE(dtStr)
	    ssRegModelRefParamArg( \
	    %<s>, \
	    %<argIdx>, \
	    "%<identi>", \
	    %<isUsed>, \
	    %<nDims>, \
	    locDims, \
	    %<isComplex>, \
	    %<dtStr>);
	  %elseif LibIsStructDataType(dtId) && !LibIsDataTypeFixpt(dtId)
	    %assign dtChecksum = DataTypes.DataType[dtId].StructDtChecksum
            %assign dtChecksumStr = ...
              "%<dtChecksum[0]>,%<dtChecksum[1]>,%<dtChecksum[2]>,%<dtChecksum[3]>"
            %assign dtName = LibGetDataTypeNameFromId(dtId)
            %assign isAnonymous = !SLibDataTypeIsNonAnonymousBus(dtId)
            %%
            uint32_T dtChecksum[4] = {%<dtChecksumStr>};
	    ssRegModelRefStructParamArg( \
	    %<s>, \
	    %<argIdx>, \
	    "%<identi>", \
	    %<isUsed>, \
	    %<nDims>, \
	    locDims, \
	    %<isComplex>, \
            dtChecksum, \
            "%<dtName>", \
            %<isAnonymous>);
	  %else %% Fixed-point
	    %%
	    %assign curDT = FixPt_GetDataTypeFromIndex(dtId)
	    %%
	    %if curDT.IsFixedPoint
	      %assign dtOverride = 0
	      %if FixPt_DataTypeIsFloat(curDT)
		ssRegModelRefScaledDoubleParamArg( \
	      %else
		ssRegModelRefFixptParamArg( \
	      %endif
	      %<s>, \
	      %<argIdx>, \
	      "%<identi>", \
	      %<isUsed>, \
	      %<nDims>, \
	      locDims, \
	      %<isComplex>,
	      %<curDT.IsSigned>, \
	      %<curDT.RequiredBits>, \
	      %<curDT.FracSlope>, \
	      %<curDT.FixedExp>, \
	      %<curDT.Bias>, \
	      %<dtOverride>);
	    %else
	      %assign errTxt = ...
		"User-defined data types not supported for interface parameters."
	      %<LibReportFatalError(errTxt)>
	    %endif
	  %endif
	}
      %endforeach %% argIdx=NumCanonicalInputArgDefs
    %endif %% NumCanonicalPrmArgDefs > 0
  %endwith %% sys
  %closefile regBuffer

  %return regBuffer
%endfunction %% SLibGenModelRefParamArgReg

%% =============================================================================
%%
%function ModelrefCacheVarStepSolverResetCode(ss) void
  %openfile tmpbuf
  %if SolverType == "VariableStep"
    %assign nDU = SolverResetInfo.NumNonContDerivSignals
    %if nDU > 0
      if (%<RTMIs("MajorTimeStep")>) {
	%foreach idx = nDU
	  %assign dulocal = RTMGetIdxed("NonContDerivSignal", %<idx>)
	  if (%<LibGenMemFcnCall("memcmp", "%<dulocal>.pCurrVal", ...
	    "%<dulocal>.pPrevVal", "%<dulocal>.sizeInBytes")> != 0) {
	    (void) %<LibGenMemFcnCall("memcpy", "%<dulocal>.pPrevVal", ...
	      "%<dulocal>.pCurrVal", "%<dulocal>.sizeInBytes")>;
	    %<RTMSetSolverNeedsReset()>;
	  }
	%endforeach
      }
    %endif
  %endif %% SolverType == "VariableStep"
  %closefile tmpbuf
  %return tmpbuf
%endfunction


%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%function CacheMdlRefExportedMdlInfoInBinfo() void
  %with CompiledModel
    %createrecord mdlInfoRecords {}
    
    %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
      %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
      %assign path = ""
      %if !ISEMPTY(id.BPath) && !WHITE_SPACE(id.BPath)
        %assign path =  id.BPath
      %endif
      
      %addtorecord mdlInfoRecords mdlInfo  { \
        Id     id.Id;    \
        Class  id.Class; \ 
        Alias  id.Alias; \
        Port   id.Port;  \
        Path   path      \
      }
    %endforeach
    %<CacheModelrefInterfaceInMatInfoFile(CompiledModel.Name, ...
      "addMdlInfos", mdlInfoRecords)>
  %endwith
%endfunction

%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%function SLibWriteMdlRefExportedMdlInfo() void

  %with CompiledModel
    %openfile tmpBuffer
    static RegMdlInfo rtMdlInfo_%<Name>[%<ExportedMdlInfo.NumExportedMdlInfo>] = {
    %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
      %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
      %if ISEMPTY(id.BPath) || WHITE_SPACE(id.BPath)
	{"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, %<SLibGetNullDefinitionFromTfl()>}\
      %else
	{"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, (void *) "%<STRING(id.BPath)>"}\
      %endif
      %if idIdx < (ExportedMdlInfo.NumExportedMdlInfo-1)
	,
      %endif
    %endforeach
    };
    %assign numDSM = CompiledModel.NumDataStoresGlobalDSM
    %if numDSM > 0
      
      void *%<CompiledModel.Name>_DSM[%<numDSM>];
      int  %<CompiledModel.Name>_DSMIdx[%<numDSM>];
    %endif
    %closefile tmpBuffer
    %<SLibCacheCodeToFile("mdl_data_defn", tmpBuffer)>
    
    %openfile tmpBuffer
    %if numDSM > 0
      extern void *%<CompiledModel.Name>_DSM[%<numDSM>];
      extern int  %<CompiledModel.Name>_DSMIdx[%<numDSM>];
    %endif
    %closefile tmpBuffer
    %<SLibCacheCodeToFile("mdl_fcn_decl", tmpBuffer)>

    %assign regFcnName = "mr_%<Name>_MdlInfoRegFcn"
    %createrecord ReferencedModelHash {}
    %openfile mdlInfoRegFcnBuffer
    void %<regFcnName>(SimStruct* mdlRefSfcnS, char_T *modelName, int_T *retVal)
    {
      *retVal = 0;
      %if ISFIELD(CompiledModel, "NumModelReferenceBlocks")
        {
          boolean_T regSubmodelsMdlinfo;
          ssGetRegSubmodelsMdlinfo(mdlRefSfcnS, &regSubmodelsMdlinfo);
          if (regSubmodelsMdlinfo) {
            %foreach idIdx = NumModelReferenceBlocks
              %assign blkIdx    = ModelReferenceBlocks[idIdx]
              %assign mdlBlock  = System[blkIdx[0]].Block[blkIdx[1]]
              %assign modelName = mdlBlock.ParamSettings.ReferencedModelName
              %if !ISFIELD(ReferencedModelHash, modelName)
                mr_%<modelName>_MdlInfoRegFcn(mdlRefSfcnS, "%<modelName>", retVal);
                if (*retVal == 0) return;
                *retVal = 0;
                %addtorecord ReferencedModelHash %<modelName> 1
              %endif
            %endforeach
          }
        }
      %endif
      
     %<RegisterMdlRefSFcnToWksDataTypes()>

      %assign modelName = Name
      *retVal = 0;
      ssRegModelRefMdlInfo(mdlRefSfcnS, modelName, rtMdlInfo_%<modelName>, %<ExportedMdlInfo.NumExportedMdlInfo>);
      
      *retVal = 1;
    }
    
    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_defn", mdlInfoRegFcnBuffer)>
    
    %openfile mdlInfoRegFcnBuffer
    %<LibExternInFcnDecls()>void %<regFcnName>(SimStruct* mdlRefSfcnS, char_T *modelName, int_T *retVal);
    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_prototype", mdlInfoRegFcnBuffer)>
        
    %openfile tmpBuffer
    int_T retVal = 1;
    %<regFcnName>(S, "%<Name>", &retVal);    
    if (!retVal) return;
    %closefile tmpBuffer
    
  %endwith
  
  %return tmpBuffer
%endfunction

%function SLibWriteMdlRefChildMdlsData() void
  %openfile tmpBuffer
  %with CompiledModel
    %assign endStr = "%<SLibGetNullDefinitionFromTfl()>, "
    %if ChildMdls.NumChildMdls > 0 
	MdlRefChildMdlRec %<GlobalScope.tChildModels>[%<ChildMdls.NumChildMdls>] = {
	%foreach mdlIdx = ChildMdls.NumChildMdls
	  %assign childMdlName = ChildMdls.ChildMdl[mdlIdx].MdlName  
	  %assign childMdlPath = ChildMdls.ChildMdl[mdlIdx].RefPath
	  %assign childMdlSingleInst = ChildMdls.ChildMdl[mdlIdx].IsSingleInst
          %if mdlIdx == ChildMdls.NumChildMdls - 1
            %assign endStr = "%<SLibGetNullDefinitionFromTfl()>};"
          %endif
          "%<childMdlName>","%<childMdlPath>",%<childMdlSingleInst>, %<endStr>
        %endforeach
    %endif
  %endwith
  %closefile tmpBuffer
  %return tmpBuffer
%endfunction


%function SLibWriteMdlRefChildMdlsReg() void
  %openfile tmpBuffer
  %with CompiledModel
    %if ChildMdls.NumChildMdls > 0 
	ssRegModelRefChildModel(S,%<ChildMdls.NumChildMdls>,%<GlobalScope.tChildModels>);
    %endif
  %endwith
  %closefile tmpBuffer
  %return tmpBuffer
%endfunction

%% Function: FcnInitializeModelRefGlobalTimingEngine ===========================
%% Abstract:
%%    Declare all the global variables necessary for the global timing engine
%% and initialize these variables in the registration function
%function FcnInitializeModelRefGlobalTimingEngine() Output
  %assert IsModelReferenceTarget()

  %% Write out the declaration of the global TID map.  Note that for inherited
  %% submodels, we will put the map into the rtModel.  This is because each
  %% instance the submodel could get a different TID and we need the TID
  %% for logging.
  %assign numTIDs = NumSynchronousSampleTimes
  %if CompiledModel.AllowModelRefFcnCallInputs
    %assign numTIDs = numTIDs + NumAsynchronousSampleTimes
  %endif
  %openfile cbuffer
  %if ::tMdlRefGlobalTIDMapAccessed
    %if MdlRefIsConstSampleBlock()
      int_T %<::tMdlRefGlobalTID>[1];
    %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
      int_T %<::tMdlRefGlobalTID>[%<numTIDs>];
    %endif
  %endif
  %if !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed
    %assert SLibIsERTCodeFormat()
    const rtTimingBridge *%<SLibGetGlobalTimingBridge()>;
  %endif
  %closefile cbuffer
  %<SLibCacheCodeToFile("mdl_data_defn", cbuffer)>
  
  %openfile hpbuffer
  %if ::tMdlRefGlobalTIDMapAccessed
    %if MdlRefIsConstSampleBlock()
      extern int_T %<::tMdlRefGlobalTID>[1];
    %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
      extern int_T %<::tMdlRefGlobalTID>[%<numTIDs>];
    %endif
  %endif
  %if !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed
    %assert SLibIsERTCodeFormat()
    extern const rtTimingBridge *%<SLibGetGlobalTimingBridge()>;
  %endif
  %closefile hpbuffer
  %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", hpbuffer)>

  %if !GenerateClassInterface
    %if ::tMdlRefGlobalTIDMapAccessed
      /* setup the global timing engine */
      %if !MdlRefIsConstSampleBlock()
        %foreach idx = numTIDs
          %<FcnGetMdlRefGlobalTIDMap("")>[%<idx>] = mdlref_TID%<idx>;
        %endforeach
      %else
        %<::tMdlRefGlobalTID>[0] = mdlref_TID0;
      %endif
      
      %if RTMMdlRefTriggerTIDIsReqFcn()
        %<FcnGetMdlRefTriggerTIDMap("")> = mdlref_TriggerTID;
      %endif
    %endif
    
    %if !IsModelReferenceForASimstructBasedTarget() && ...
      ::tMdlRefTimingBridgeAccessed
      %assert SLibIsERTCodeFormat()
      %<SLibGetGlobalTimingBridge()> = timingBridge;
    %endif
  %endif
%endfunction

%% Function: FcnInitializeNoncontSignals =======================================
%% Abstract:
%%   Write out the declaration and initialization of the data structures for
%% handling information on noncontinous signals coming from model reference
%% blocks.  We create an array of type ssNonContDerivSig for each model 
%% reference block, and initialize the outports that we need information for.
%function FcnInitializeNoncontSignals() Output
  %if !HasModelReferenceBlocks()
    %return
  %endif
  %% Declare all the arrays
  %assign mdlRefBlks = CompiledModel.ModelReferenceBlocks
  %openfile declbuf
  %openfile codebuf
  %foreach rowIdx = SIZE(mdlRefBlks,0)
    %assign mdlRefInfo = mdlRefBlks[rowIdx]
    %assign mSysIdx = mdlRefInfo[0]
    %assign bIdx    = mdlRefInfo[1]
    %assign instIdx = mdlRefInfo[2]
    %assign blk = System[mSysIdx].Block[bIdx]
    %assign name = blk.ParamSettings.ReferencedModelName
    %assign blockInterface = GetModelrefInterface(blk)
    %if blockInterface.HasNonContOutput
      %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, bIdx, instIdx)
      %selectfile declbuf
      %assign comma = ""
      %% This is an array of pointers  of size nOutputPorts.  If an
      %% output port has any noncontinuous signals, we'll create
      %% another array to hold all those signals below
      ssNonContDerivSigFeedingOutports *mr_%<mangleName>nonContOutputArray[%<LibBlockNumOutputPorts(blk)>] = {\
      %foreach nullIdx = LibBlockNumOutputPorts(blk)
        %<comma>%<SLibGetNullDefinitionFromTfl()>\
        %assign comma = ", "
      %endforeach
      };
      %assign nonContPorts = blockInterface.NonContOutports
      %foreach pIdx = SIZE(nonContPorts,1)
        %if nonContPorts[pIdx] > 0
          %assign intNumSigs = CAST("Number", nonContPorts[pIdx])
          %selectfile declbuf
          %% Create an array of noncont signals for this port
          ssNonContDerivSigFeedingOutports mr_%<mangleName>nonContDerivSig%<pIdx>[%<intNumSigs>];
          %selectfile codebuf
          mr_%<mangleName>nonContOutputArray[%<pIdx>] = mr_%<mangleName>nonContDerivSig%<pIdx>;
        %endif
      %endforeach
    %endif
  %endforeach
  %closefile declbuf
  %closefile codebuf
  %<declbuf>\
  
  %<codebuf>\
%endfunction

%% Function: SLibGenNoncontDerivSigStruct ======================================
%% Abstract:
%%   Write out the structure which holds the memory needed when looking
%% at noncontinuous signals feeding deriv ports.  This is for modelref
%% only, and it helps avoid using malloc.
%function SLibGenNoncontDerivSigStruct() void
  %openfile declBuf
  
  /*
   * The following structure contains memory needed to 
   * track noncontinuous signals feeding derivative ports.
   */
   struct {
     %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
     %assign arrayIdx = 0
     %foreach idx = numNoncontDerivSigs
       %assign dU = SolverResetInfo.NonContDerivSignal[idx]
       %if ISFIELD(dU,"MdlRefInfo")
         %foreach subIdx = dU.NumMdlRefNonContSigs
           %assign numBytes = dU.NonContSigSizeInBytes[subIdx]
           uint8_T mr_nonContSig%<arrayIdx>[%<numBytes>];
           %assign arrayIdx = arrayIdx + 1
         %endforeach
       %else
         %if dU.ComplexSignal
           %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
         %else
           %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
         %endif
         %<dtype> mr_nonContSig%<arrayIdx>[%<dU.RegionLen>];
         %assign arrayIdx = arrayIdx + 1
       %endif
     %endforeach
   } \
   %closefile declBuf
   %return declBuf
%endfunction


%% Function: CPPEncapNeedsLocalVars ======================================
%% Abstract:
%%  Does C++ encapsulation interface needs to introduce local variables to
%%  model regestration function?

%function CPPEncapNeedsLocalVars() void
   %assign hasDWork = ! SLibModelDWorkStructIsEmpty()
   %assign dworkZeroed = TLC_FALSE
   
   %if hasDWork && (!(ForceBlockIOInitOptimize && IsModelReferenceTarget()))
      %assign dworkZeroed = SLibZeroMemory("DWork")
   %endif
   
   %return GenerateClassInterface && ...
           ConfigSet.UseOperatorNewForModelRefRegistration && ...
           dworkZeroed
%endfunction %% CPPEncapNeedsLocalVars


%% Function: SLibGetCPPEncapInitLocalVars ================================
%% Abstract:
%%  Determine what local variables will be needed for cpp encapsulation
%%  in the model initialization function; must be guarded by 
%%  CPPEncapNeedsLocalVars

%function SLibGetCPPEncapInitLocalVars() void
  %assert CPPEncapNeedsLocalVars()
  
  %assign localVars = ""
  
  %assign mdlRefBlks = ISFIELD(CompiledModel,"ModelReferenceBlocks") ? ...
    CompiledModel.ModelReferenceBlocks : []
  
  
  %if !ISEMPTY(mdlRefBlks)
    %assign NO_PARENT        = ""
    %assign NO_QUALIFIER     = ""
    %assign ERT_MACRO_NONE   = [0, 0, 0, 0]
    
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]

      %if !SLibIsLangCPPEncap(System[mSysIdx].Block[bIdx].MdlRefTargetLang)
         %continue
      %endif
      
      %assign blkInterface = GetModelrefInterface(System[mSysIdx].Block[bIdx])
      
      %if blkInterface.IsScalableBuild || ...
          SLibIsRootSysOrMdlRefBaseSys(mSysIdx) || ...
          SLibIsRootSysOrMdlRefBaseSys(System[mSysIdx].HStructDeclSystemIdx)
          %continue
      %endif
      
      %assign locVarName = "local_" + ...
                GETFIELD(CompiledModel.CPPEncapsulationMdlRefRecord,...
                   "MdlRefInstanceVar%<rowIdx>") 

      %assign mdlBlkCompiledModel = CompiledModel.ModelBlock[rowIdx]
      %assign optDim = ""
      %if ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
          %assign tmpLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
          %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
            %assign tmpLevel = tmpLevel - 1
            %assign optDim = optDim + "[%<mdlBlkCompiledModel.ForEachSSLoopBnds[tmpLevel]>]"
          %endforeach
      %endif
                                            
      %openfile tmpBuf
         %if ISEMPTY(optDim)
           %<blkInterface.FPC.ModelClassName>_ptr %<locVarName>;
         %else
           %<blkInterface.FPC.ModelClassName>_ptr %<locVarName>%<optDim>;
         %endif
      %closefile tmpBuf

      %assign localVars = localVars + tmpBuf
    %endforeach
  %endif
  
  %return localVars
  
%endfunction %% SLibGetCPPEncapInitLocalVars


%% Function:  SLibGetCPPEncapInitCopyCode================================
%% Abstract:
%%  Determine the code needed to copy the referenced model object pointers so that
%%  later we can restore them after the DWork has been Zeroed, in the model initialization function; 
%%  It must be guarded by CPPEncapNeedsLocalVars. The argument is a boolean flag to indicate that it
%%  is a back up operation or a restore operation.
%function SLibGetCPPEncapInitCopyCode(isBackup) void
  %assert CPPEncapNeedsLocalVars()
  
  %assign copyCode = ""
  
  %assign mdlRefBlks = ISFIELD(CompiledModel,"ModelReferenceBlocks") ? ...
    CompiledModel.ModelReferenceBlocks : []
  
  
  %if !ISEMPTY(mdlRefBlks)
    %assign NO_PARENT        = ""
    %assign NO_QUALIFIER     = ""
    %assign ERT_MACRO_NONE   = [0, 0, 0, 0]
    
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]

      %if !SLibIsLangCPPEncap(System[mSysIdx].Block[bIdx].MdlRefTargetLang)
         %continue
      %endif
      
      %assign blkInterface = GetModelrefInterface(System[mSysIdx].Block[bIdx])
      
      %if blkInterface.IsScalableBuild || ...
          SLibIsRootSysOrMdlRefBaseSys(mSysIdx) || ...
          SLibIsRootSysOrMdlRefBaseSys(System[mSysIdx].HStructDeclSystemIdx)
          %continue
      %endif
      
                                            
      %assign locVarName = "local_" + ...
                GETFIELD(CompiledModel.CPPEncapsulationMdlRefRecord,...
                   "MdlRefInstanceVar%<rowIdx>") 

      %assign mdlBlkCompiledModel = CompiledModel.ModelBlock[rowIdx]


      %openfile tmpBuf
        %if !ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
          %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                                bIdx,instIdx,"Registration")
          %if isBackup
            %<locVarName> = %<cppVarPath>;
          %else
            %<cppVarPath> = %<locVarName>;
          %endif
        %else
          %assign ::NeedForEachLoopInReg = TLC_TRUE
          %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
          %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
          %assign copySrcVarForEachSS = locVarName

          {
            %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
              %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
              %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
              %assign copySrcVarForEachSS = copySrcVarForEachSS + "[%<iterVar>]" 
              int32_T %<iterVar>;
              for (%<iterVar> = 0; %<iterVar> < %<mdlBlkCompiledModel.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
            %endforeach
            %assign ::ForEachLoopHierarchyLevel = 1
            %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                                bIdx,instIdx,"Registration")
            %if isBackup
              %<copySrcVarForEachSS> = %<cppVarPath>;
            %else
              %<cppVarPath> = %<copySrcVarForEachSS>;
            %endif
            %assign ::ForEachLoopHierarchyLevel = 1
            
            %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                   }
            %endforeach
            }
            %assign ::NeedForEachLoopInReg = TLC_FALSE
        %endif
      %closefile tmpBuf

      %assign copyCode = copyCode + tmpBuf
    %endforeach
  %endif
  
  %return copyCode
  
%endfunction %% SLibGetCPPEncapInitCopyCode

%% Function: SLibCPPDotOrArrowAccessOperator ======================================
%% Abstract:
%%  Which access operator, "." or "->", to use when calling member functions on
%%  encapsulated model reference C++ objects.
%function SLibCPPDotOrArrowAccessOperator(blk, blkInterface) void
  %assert GenerateClassInterface
  %assert SLibIsLangCPPEncap(blk.MdlRefTargetLang)
  
  %assign accOperator = ((!blkInterface.IsScalableBuild) && ...
                         ConfigSet.UseOperatorNewForModelRefRegistration) ? ...
                            "->" : "."
                          
  %return accOperator
%endfunction %% SLibCPPDotOrArrowAccessOperator


%% Function RegisterMdlRefSFcnToWksDataTypes ======================================
%% Abstract:
%%   Generate the S-Function code to register enum and fixed point data types used
%%   by workspace logging in the mdlInitializeSizes function.
%%
%function RegisterMdlRefSFcnToWksDataTypes() Output

  %% ToWks logging in Dataset format is only supported currently for modelref sim
  %% targets.
  %if (!IsModelReferenceSimTarget())
    %return
  %endif

  %% See if there are any logged non-builtin types to register
  %if !EXISTS(CompiledModel.DataTypes.NonBuiltinLoggingTypes) || ...
      SIZE(CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1) < 1
    %return
  %endif

  /* Workspace Logging Data Type Registration */
  {
    DTypeId dtId = INVALID_DTYPE_ID;
  
    %foreach idx = SIZE(CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1)

      %assign dID = CompiledModel.DataTypes.NonBuiltinLoggingTypes[idx]

      %% ENUM data types
      %if LibIsEnumDataType(dID)
	    %assign dtName = LibGetDataTypeNameFromId(dID)
	    ssRegisterTypeFromNamedObject(mdlRefSfcnS, "%<dtName>", &dtId);

      %% FIXED POINT data types
      %elseif LibIsDataTypeFixpt(dID)
        %assign curDT = FixPt_GetDataTypeFromIndex(dID)

        %if FixPt_DataTypeIsFloat(curDT)
	      dtId = ssRegisterDataTypeFxpScaledDouble( \
            mdlRefSfcnS, \
	        %<curDT.IsSigned>, \
            %<curDT.RequiredBits>, \
	        (double) %<curDT.FracSlope>, \
            %<curDT.FixedExp>, \
	        (double) %<curDT.Bias>, 
            0);
        %else
          dtId = ssRegisterDataTypeFxpFSlopeFixExpBias( \
            mdlRefSfcnS, \
            %<curDT.IsSigned>, \
            %<curDT.RequiredBits>, \
            (double) %<curDT.FracSlope>, \
            %<curDT.FixedExp>, \
            (double) %<curDT.Bias>, \
            0);
        %endif
	            
      %% UNKNOWN types
      %else
        %assign errTxt = ...
          "User-defined data types not supported for model reference simulation logging."
        %<LibReportFatalError(errTxt)>
	  %endif

      if(dtId == INVALID_DTYPE_ID) {
        return;
      }

    %endforeach

  }

%endfunction %% RegisterMdlRefSFcnToWksDataTypes

                          
%% EOF modelrefsfcnlib.tlc
