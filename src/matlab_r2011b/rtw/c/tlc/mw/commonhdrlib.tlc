%% ============================================================================
%% File : commonhdrlib.tlc
%%
%% Abstract:
%%   This system TLC library file contains functions that are common
%%   between the different code generators for producing the model's
%%   header file.
%%
%% 
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%% ============================================================================
%selectfile NULL_FILE

%if EXISTS("_COMMONHDRLIB_") == 0
%assign _COMMONHDRLIB_ = 1

%function SLibGetOldStrNames() void
  %return (!((CodeFormat == "RealTime") || (SLibIsERTCodeFormat())) || isGRTMallocOnERT())
%endfunction

%function SLibGetPrmsName(oldStrNames) void
  %return oldStrNames ? tDefaultParameters : "%<LibGetParametersStruct()>"
%endfunction

%% Function: LibCacheModelStructureDefinitions =================================
%% Abstract:
%%   This function creates the guts of each model structure.  It should be
%%   called after all code is generated, and just prior to final model
%%   registration.
%%
%function LibCacheModelStructureDefinitions() void
  %<LibCacheExportedGlobalSignalsDefinition()>
  %<LibCacheImportedExternSignalsDefinition()>
  %<LibCacheImportedExternPointerSignalsDefinition()>
  %if CodeFormat != "S-Function" || Accelerator
    %<LibCacheNonAutoStorageClassDWorkDefinition()>
  %endif
  %if !SLibAutosarActive() || SLibAutosarIsServerOperation()
    %<LibCacheExternalInputsStructDefinition()>
    %<LibCacheExternalOutputsStructDefinition()>
    %<LibCacheExternalInputSizesStructDefinition()>
    %<LibCacheExternalOutputSizesStructDefinition()>
  %endif
%endfunction

%% Function: FcnGetHStructChildSystemTypedefs ==================================
%% Abstract: 
%%   This function is the same as FcnGetChildSystemTypedefs. However, it uses
%%   for loop to generate the typedef.
%%
%function FcnGetHStructChildSystemTypedefs(sysIdx, struct, typetag, hasFlatElements) void
  %assign hasUnconditionalElement = hasFlatElements
  %assign childsysTypedefs = ""
  %assign numElements = 0
  %assign res = ["", 0] %% TLC bug workaround
  %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], typetag, 0)
  %if varGroupIdx >= 0
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %% The following two variables are used to control the names of items in
    %% the code to prevent empty structure types in the case of code 
    %% variants
    %assign hasElement = varGroup.HasElement
    %assign dummyElementName = "_rt_unused"
  %else 
    %assign hasElement = ""
    %assign dummyElementName = ""
  %endif
  %with System[sysIdx]
    %assert SLibSystemHasOwnDataScope(System[sysIdx])    
    %openfile childsysTypedefs    
    %foreach childIdx = System[sysIdx].NumHStructChildSystems
      %assign chRow = System[sysIdx].HStructChildSystems[childIdx]      
      %assign ssblk = System[chRow[1]].Block[chRow[2]]
      %assign shareParamsAcrossReusedInstances = ...
        InlineParameters && struct == "Parameters"
      %if shareParamsAcrossReusedInstances && ssblk.CallSiteIdx > 0 
        %continue
      %endif
      %with ssblk
        %assign ppIf = SLibIfLocalPreprocessorCondition(ssblk)
        %assign ppFi = SLibEndIfLocalPreprocessorCondition(ssblk)
	%assign childSysIdx = ssblk.CallSiteInfo.SystemIdx
	%assign childSys    = ::CompiledModel.System[childSysIdx]
        %% If a child is a standalone subsystem, do not
        %% include it in this hierarchy.
        %if childSys.StandaloneSubsystem
          %continue
        %endif
	%assert (childSys.SystemIdx == childSysIdx)
	%%if ISFIELD(childSys, "Has%<struct>Arg") && (childSys.Has%<struct>Arg)
	%if (childSys.Has%<struct>Arg)
          %assign varGroupIdx = ...
            FcnSysVarGroupIndex(childSys, typetag, ssblk.CallSiteIdx)
          %assign structType = SLibVarGroupType(varGroupIdx, typetag)
          %assign structName = SLibVarGroupName(varGroupIdx)
          %assign comment    = "/* '%<ssblk.Name>' */"

          %if shareParamsAcrossReusedInstances
            %assign siblingCallSites = childSys.CallSites
            %assign numSiblings = SIZE(siblingCallSites,0)
            %if numSiblings > 1
              %assign unconditionalInstance = TLC_FALSE
              %assign ppCondition = ""
              %assign previousCondition = ""
              %assign siblingCallSites = childSys.CallSites
              %assign comment = SLibGetCallSitesComment(childSysIdx)
              %foreach siblingIdx = numSiblings
                %assign siblingCS = siblingCallSites[siblingIdx]
                %assign siblingSS = System[siblingCS[2]].Block[siblingCS[3]]
                %assign siblingCondition = siblingSS.LocalPreprocessorCondition
                %if WHITE_SPACE(siblingCondition)
                  %assign unconditionalInstance = TLC_TRUE
                  %break
                %endif
                %if !ISEQUAL(siblingCondition, previousCondition)
                  %assign previousCondition = siblingCondition
                  %if !ISEMPTY(ppCondition)
                    %assign ppCondition = ppCondition + " || "
                  %endif
                  %assign ppCondition = ppCondition + siblingCondition
                %endif
              %endforeach
              %if unconditionalInstance
                %assign ppFi = ""
                %assign ppIf = ""
              %else
                %assign ppFi = "#endif /* " + ppCondition + " */"
                %assign ppIf = "#if " + ppCondition
              %endif
            %endif
          %endif
          
          %<ppIf>
          %if SLibSysVarGroupUsedAsMatrix(System[childSys.SystemIdx], typetag, ssblk.CallSiteIdx)
            %assign csIdx = ssblk.CallSiteIdx
            %assign structWidth = ...
              SLibSysVarGroupWidth(System[childSys.SystemIdx], typetag, csIdx)
            %<structType> %<structName>[%<structWidth>]; %<comment>
          %else
            %<structType> %<structName>; %<comment>
          %endif
          %if ISEMPTY(ppIf)
            %assign hasUnconditionalElement = TLC_TRUE
          %else       
            # define %<hasElement>
          %endif
          %<ppFi>
          %assign numElements = numElements + 1
	%endif
      %endwith
    %endforeach
    %if !hasUnconditionalElement && (numElements > 0)
      %assert !hasFlatElements
      #ifndef %<hasElement>
      char %<dummyElementName>;
      #endif
    %endif        
    %closefile childsysTypedefs
  %endwith
  
  %if numElements > 0
    %assign res[0] = "%<childsysTypedefs>"
    %assign res[1] = %<numElements>
  %endif
  %return res
%endfunction %% FcnGetHStructChildSystemTypedefs


%% Function: FcnGetChildSystemTypedefs =========================================
%% Abstract: 
%%   Generic function called by functions that generate typedefs for the 
%%   various data structures. This creates the definitons for Child systems 
%%   that have typedef.
%%
%function FcnGetChildSystemTypedefs(sysIdx, struct, typetag) void
  %assign childsysTypedefs = ""
  %assign numElements = 0
  %assign res = ["", 0] %% TLC bug workaround
  %assign inlineFcn = "SLibGetSystem%<struct>"
  %with ::CompiledModel.System[sysIdx]
    %if NumChildSystems > 0
      %if struct == "Parameters"
	%assign childSystems = ChildPrmStructs
      %else
	%assign childSystems = ChildSystems
      %endif
      %openfile childsysTypedefs
      %foreach childIdx = NumChildSystems
	%assign chIdx = childSystems[childIdx]
	%% Is first memory instance ? And not a reduced subsystem
	%if chIdx[1] == 0 && chIdx[3] > -1
	  %assign   blk = System[chIdx[2]].Block[chIdx[3]]
	  %with blk
            %assign childSys = System[CallSiteInfo.SystemIdx]
            %% If a child is a standalone subsystem, do not
            %% include it in this hierarchy.
            %if childSys.StandaloneSubsystem
              %continue
            %endif
	    %%if ISFIELD(CallSiteInfo, "%<struct>"Arg) && childSys.Has%<struct>Arg
	    %if !SLibSystemHasOwnDataScope(childSys)
	      %assign inlRes = %<inlineFcn>(childSys.SystemIdx)
	      %assign numElements = numElements + inlRes[1]
	      %<inlRes[0]>\
	    %elseif childSys.Has%<struct>Arg
              %assign csIdx       = blk.CallSiteIdx
              %assign varGroupIdx = FcnSysVarGroupIndex(childSys, typetag, csIdx)
              %assign structType  = SLibVarGroupType(varGroupIdx, typetag)
              %assign structName  = SLibVarGroupName(varGroupIdx)
              %assign comment    = "/* '%<childSys.Name>' */"
              %<SLibIfLocalPreprocessorCondition(blk)>
              %if SLibSysVarGroupUsedAsMatrix(System[childSys.SystemIdx],typetag, csIdx)
                %assign structWidth = SLibSysVarGroupWidth(System[childSys.SystemIdx],typetag, csIdx)
                %<structType> %<structName>[%<structWidth>]; %<comment>
              %else
                %<structType> %<structName>; %<comment>
              %endif
              %<SLibEndIfLocalPreprocessorCondition(blk)>
	      %assign numElements = numElements + 1
	    %endif
	  %endwith
	%endif
      %endforeach
      %closefile childsysTypedefs
    %endif %% NumChildSystems > 0
  %endwith %% System[sysIdx]
  %if numElements > 0
    %assign res[0] = "%<childsysTypedefs>"
    %assign res[1] = %<numElements>
  %endif
  %return res
%endfunction %% FcnGetChildSystemTypedefs


%% Function: LibRegCommonIncludes ==============================================
%% Abstact:
%%   This function registers header files necessary to compile a standalone
%%   system.
%%
%function LibRegCommonIncludes(sysIdx) void
  %%
  %% Common Includes
  %%
  %<SLibAddToCommonIncludes("rtwtypes.h")>
  
  %if !GenRTModel || SLibModelHierarchyContainsNoninlinedSfcn() || ...
    IsModelReferenceForASimstructBasedTarget() || ...
    GenerateGRTWrapper
    %if (::CompiledModel.NumChildSFunctions > 0) && ...
      !Accelerator && CodeFormat != "S-Function"
      %<SLibAddToStaticSources("rt_matrx.c")>
      %<SLibAddToStaticSources("rt_printf.c")>
    %endif
    %<SLibAddToCommonIncludes("simstruc.h")>
    %<SLibAddToCommonIncludes("fixedpoint.h")>
  %elseif SLibIsERTCodeFormat()
    %if ::ExtMode == 1 
      %<SLibAddToCommonIncludes("rtw_extmode.h")>
      %<SLibAddToCommonIncludes("sysran_types.h")>
    %endif
    %if ::CompiledModel.ConfigSet.SupportContinuousTime == 1
      %<SLibAddToCommonIncludes("rtw_continuous.h")>
      %if !PurelyIntegerCode
        %<SLibAddToCommonIncludes("rtw_solver.h")>
      %endif
    %endif
  %endif

  %if isRSim %% ok ModelReference
    %if isRAccel
      %<SLibAddToCommonIncludes("raccel.h")>
      %if ISFIELD(::CompiledModel,"ModelHasParallelForEachSS") && ...
        ::CompiledModel.ModelHasParallelForEachSS
        %<SLibAddToCommonIncludes("rt_parfor.h")>
      %endif
    %else
      %<SLibAddToCommonIncludes("rsim.h")>
    %endif
  %endif
  
  %if MatFileLogging != 0
    %<SLibAddToStaticSources("rt_logging.c")>
    %<SLibAddToCommonIncludes("rt_logging.h")>
  %endif
  
  %if CreateTransitionTable == 1 
    %<SLibAddToCommonIncludes("dt_info.h")>
  %endif
  %if ExtMode == 1
    %<SLibAddToCommonIncludes("ext_work.h")>
  %endif
  %if UsingMalloc || FcnIsERTMalloc() || isRSim || isRSimWithSolverModule %% ok Model Reference
    %<SLibAddToCommonIncludes("<stdlib.h>")>
  %endif

  %if SLibAutosarActive()
    %<SLibAddToCommonIncludes("%<MainAutosarInterfaceName()>.h")>
  %endif
  
  
  %%
  %% Custom user code for adding header files which
  %% contain profiling information
  %%
  %<SLibGenProfHeaders()>

%endfunction %% LibRegCommonIncludes

%% Function: LibDumpCommonDefines ==============================================
%% Abstract:
%%    Common Defines - Does not include generic model defines.
%%    Returns macros necessary to compile a standalone system.
%%
%function LibDumpCommonDefines(sysIdx) void
  %openfile tmpDefineBuf
  
  %if UsingMalloc || isRSim
    #ifndef RTW_COMMON_DEFINES_
    # define RTW_COMMON_DEFINES_
    %<LibDeclareMemoryAllocationMacros()>\
    #endif /* RTW_COMMON_DEFINES_ */
  %endif

  %if (UsingMalloc || isRSim) && CodeFormat != "S-Function"
    %assign tmpS = Accelerator ? "" : "(S)"
    #ifdef rt_VALIDATE_MEMORY
      #undef rt_VALIDATE_MEMORY
      #define rt_VALIDATE_MEMORY(S, ptr) \
      if(!(ptr)) {%<"\\">
      %<RTMSetErrStat("RT_MEMORY_ALLOCATION_ERROR")>;%<"\\">
      %<"}">
   #endif
  %endif

  %if SLibIsERTCodeFormat() && !GenerateGRTWrapper
    %assign ertcomdef = LibDeclareERTDefines(sysIdx)
    %if !WHITE_SPACE(ertcomdef)
      #ifndef ERT_COMMON_DEFINES_
      # define ERT_COMMON_DEFINES_
      %<ertcomdef>
      #endif /* ERT_COMMON_DEFINES_ */
    %endif
  %endif
  
  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction %% LibDumpCommonDefines 

%% Function: LibDeclareERTDefines ==============================================
%% Abstract:
%%   Returns ERT specific macros necessary to compile a standalone system.
%%
%function LibDeclareERTDefines(sysIdx) void
  %openfile tmpDefineBuf
  %if MatFileLogging == 1 || GenerateGRTWrapper

    #define QUOTE1(name) #name
    #define QUOTE(name) QUOTE1(name)    /* need to expand name */
    %if MatFileLogging == 1
      #ifndef SAVEFILE
      # define MATFILE2(file) #file ".mat"
      # define MATFILE1(file) MATFILE2(file)
      # define MATFILE MATFILE1(MODEL)
      #else
      # define MATFILE QUOTE(SAVEFILE)
      #endif
    %endif
  %endif
  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction  

%% Function: LibSFcnPreSimstrucDefines =========================================
%% Abstract:
%%   Return the neccesary macros the need to be declared before the   
%%   simstruct will be included for the S-Function target and Accelerator.
%%
%function LibSFcnPreSimstrucDefines(system) void
  %assign tmpDefineBuf = ""
  
  %openfile tmpDefineBuf
  %assign tmpName = Accelerator ? "simulink_only_sfcn" : Name
  %if system.Type == "root"
    #define S_FUNCTION_NAME %<tmpName> 
  %endif
  #define S_FUNCTION_LEVEL 2
  #define RTW_GENERATED_S_FUNCTION
  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction %% LibSFcnPreSimstrucDefines

%% Function: LibSFcnPostSimstrucDefines ========================================
%% Abstract:
%%   Return the neccesary macros the need to be declared after the   
%%   simstruct is included for the S-Function target and Accelerator.
%%
%function LibSFcnPostSimstrucDefines() void
  %assign tmpDefineBuf = ""
  %if !Accelerator
    %openfile tmpDefineBuf
    #if !defined(RTW_SFUNCTION_DEFINES)
    #define RTW_SFUNCTION_DEFINES
    typedef struct {
      void *blockIO;
      void *defaultParam;
      void *nonContDerivSig;
    } LocalS;
    
    #define %<RTMSet("LocalBlockIO","io")> ...
      ((LocalS *)%<RTMGet("UserData")>)->blockIO = ((void *)(io))
    #define %<RTMGet("LocalBlockIO")> ...
      ((LocalS *)%<RTMGet("UserData")>)->blockIO
    
    #define %<RTMSet("LocalDefaultParam", "paramVector")> ...
      ((LocalS *)%<RTMGet("UserData")>)->defaultParam = (paramVector)
    #define %<RTMGet("LocalDefaultParam")> ...
      ((LocalS *)%<RTMGet("UserData")>)->defaultParam

    #define %<RTMSet("LocalNonContDerivSig", "pSig")> ...
      ((LocalS *)%<RTMGet("UserData")>)->nonContDerivSig = (pSig)
    #define %<RTMGet("LocalNonContDerivSig")> ...
      ((LocalS *)%<RTMGet("UserData")>)->nonContDerivSig
    #endif
    
    %closefile tmpDefineBuf
  %endif
  %return tmpDefineBuf
%endfunction  

%% Function: LibDeclareTrueFalse ===============================================
%% Abstract:
%%   Define TRUE/FALSE = 0/1 and also Define fcn_call_T and pointer_T.
%%   This is a  temporary fix so that external mode code can compile (these
%%   types shows up in the model_dt.c file).  Note that these types should
%%   never be accessed by RTW.  Also define action_T like fcn_call_T
%%   for the same reasons.
%% WARNING: This function will be obsoleted in next release, definition is inside
%%          rtwtypes.h.
%%
%function LibDeclareTrueFalse() void
  %warning This function will be obsoleted in next release. True/False definitions is inside rtwtypes.h.
  %openfile tmpFcnBuf

  #ifndef TRUE
  # define TRUE (1)
  #endif
  #ifndef FALSE
  # define FALSE (0)
  #endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibGenerateVariantStuff ===============================================
%% Abstract:
%%   Generate Simulink.Variant definitions and constraint checking
%%
%function SLibGenerateVariantStuff() void
  %if !(::CompiledModel.HasCodeVariants)
    %return
  %endif
  
  %% Enumerated types used by Simulink.Variant definitions
  %openfile variantEnumeratedTypes
  %<SLibDeclarePreprocessorEnums()>\
  %closefile variantEnumeratedTypes
  %<SLibCacheCodeToFile("data_simulink_variant_define", variantEnumeratedTypes)>
  %undef variantEnumeratedTypes
  
  %% Simulink.Variant definitions
  %openfile simulinkVariantObjects
  %<SLibDeclareSimulinkVariantObjects()>\
  %closefile simulinkVariantObjects
  %<SLibCacheCodeToFile("data_simulink_variant_define", simulinkVariantObjects)>
  %undef simulinkVariantObjects
  
  %% constraint checking
  %openfile preprocessorConstraints
  %<SLibDeclarePreprocessorConstraints()>\
  %closefile preprocessorConstraints
  %<SLibCacheCodeToFile("data_simulink_variant_define", ...
    preprocessorConstraints)>
  %undef preprocessorConstraints
%endfunction  

%% Function: SLibDeclarePrimitiveTypedefs ======================================
%% Abstract:
%%   Uses intrinsic types.
%%
%function SLibDeclarePrimitiveTypedefs() void
  %openfile tmpFcnBuf
  %% This is by design, do not remove this function since we will
  %% have primitive typedefs in the future.
  %if 0
    
    /* Primitive typedefs */
    #ifndef TMW_PRIMITIVE_TYPEDEFS
    #define TMW_PRIMITIVE_TYPEDEFS
    #endif
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareGenericModelDefines =====================================
%% Abstract:
%%   Declare generic model defines 
%%
%function LibDeclareGenericModelDefines() void
  %openfile tmpFcnBuf
  #define MODEL_NAME %<Name>
  #define NSAMPLE_TIMES (%<NumSampleTimes>) /* Number of sample times */
  #define NINPUTS (%<NumModelInputs>)       /* Number of model inputs */
  #define NOUTPUTS (%<NumModelOutputs>)     /* Number of model outputs */
  #define NBLOCKIO (%<BlockOutputs.NumSignalsInBlockIO>) ...
    /* Number of data output port signals */
  #define NUM_ZC_EVENTS (%<NumZCEvents>) /* Number of zero-crossing events */
  
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareNCSTATES ================================================
%% Abstract:
%%   Create the number of continous states define.
%%
%function LibDeclareNCSTATES() void
  %openfile tmpFcnBuf
  #ifndef NCSTATES
  # define NCSTATES (%<NumContStates>)   /* Number of continuous states */
  #elif NCSTATES != %<NumContStates>
  # error Invalid specification of NCSTATES defined in compiler command
  #endif
  
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibDeclareSimulinkVariantObjects ================================
%% Abstract:
%%   Create the #define for each Simulink.Variant object, which are used
%%   to select model code variants
%%
%function SLibDeclareSimulinkVariantObjects() void
  %if ::CompiledModel.HasCodeVariants && ...
      ::CompiledModel.CodeVariants.NumSimulinkVariantObjects > 0
    %with ::CompiledModel.CodeVariants
      %openfile tmpSVBuf
      
      /* Model Code Variants */
      %assign numSVIdxs = NumVariantObjectOrderedIndexs
      %foreach svIdxIdx = numSVIdxs
        %% get the index of the SV object from the table of indexes,
        %% which is in SV object dependency order
        %assign svIdx = VariantObjectOrderedIndexs[svIdxIdx]
        %with SimulinkVariantObject[svIdx]
          #ifndef %<Name>
          #define %<Name> (%<Condition>)
          #endif
        %endwith
      %endforeach
      
      %closefile tmpSVBuf
    %endwith
    %return tmpSVBuf
  %else
    %return
  %endif
%endfunction

%% Function:SlibEnumeralPreprocessorSymbol ===============================
%% Abstract:
%%   Create a unique preprocessor symbol for an enumeral of an enumerated
%%   type. The symbol consists of the type name with the enumeral name
%%   appended.
%%
%function SlibEnumeralPreprocessorSymbol(enumDataTypeId, enumIdx) void
  %assign enumTypeName = DataTypes.DataType[enumDataTypeId].Name
  %assign enumeralName = FcnGetEnumTypeString(enumDataTypeId, enumIdx)
  %return "%<enumTypeName>_%<enumeralName>"
%endfunction

%% Function: SLibDeclarePreprocessorEnums ================================
%% Abstract:
%%   Create a #define for each enumeral of all enumerated types listed
%%   in the EnumeratedTypeIds vector of the CodeVariants record
%%   to select model code variants
%%
%function SLibDeclarePreprocessorEnums() void
  %if ::CompiledModel.HasCodeVariants && ...
      ::CompiledModel.CodeVariants.NumEnumeratedTypeIds > 0
    %with ::CompiledModel.CodeVariants
      %openfile tmpEnumsBuf
      
      /* Simulink enumerals used in Code Variant condition expressions */
      %assign numEnumTypes = NumEnumeratedTypeIds
      %foreach enumTypeIdx = numEnumTypes
        %assign enumDataTypeId = EnumeratedTypeIds[enumTypeIdx]
        %% we assume the index into the DataTypes table is the same
        %% as the type ID of the type. verify that here:
        %assert LibIsEnumDataType(enumDataTypeId)
        %assert enumDataTypeId == DataTypes.DataType[enumDataTypeId].Id
        
        %assign enumTypeName = DataTypes.DataType[enumDataTypeId].Name
        #ifndef _RTW_ENUMS_%<enumTypeName>_
        #define _RTW_ENUMS_%<enumTypeName>_
        %foreach enumIdx = FcnGetEnumTypeNumEnums(enumDataTypeId)
          %assign enumeralPreprocessorSymbol = ...
            SlibEnumeralPreprocessorSymbol(enumDataTypeId, enumIdx)
          %assign enumeralValue = FcnGetEnumTypeValue(enumDataTypeId, enumIdx)
          #define %<enumeralPreprocessorSymbol> %<enumeralValue>
        %endforeach

        #endif
      %endforeach
      
      %closefile tmpEnumsBuf
    %endwith
    %return tmpEnumsBuf
  %else
    %return
  %endif
%endfunction

%% Function: SLibDeclarePreprocessorConstraints ================================
%% Abstract:
%%   Create the #error corresponding to code variant constraints
%%
%function SLibDeclarePreprocessorConstraints() void
  %if (!::CompiledModel.HasCodeVariants) || ...
       (::CompiledModel.CodeVariants.NumCodeVariantGroups == 0)
    %return 
  %endif
  
  %openfile tmpBuf
  %assign numVariants = ::CompiledModel.CodeVariants.NumCodeVariantGroups
  %foreach cIdx = numVariants
    %assign logic = ""
    %assign variant = ::CompiledModel.CodeVariants.CodeVariantGroup[cIdx]
    %assign nonExpandedGrSrc = variant.NonExpandedGrSrc
    %assign numExpandedBlocks = variant.NumExpandedBlocks
    %foreach mIdx = numExpandedBlocks
      %assign expandedBlockIdx = variant.ExpandedBlock[mIdx].FirstInstanceSrcIndex
      %assign expandedBlock = ...
        ::CompiledModel.System[expandedBlockIdx[0]].Block[expandedBlockIdx[1]]
      %switch expandedBlock.Type
          %case "SubSystem"
            %assign condition = expandedBlock.LocalPreprocessorCondition
            %break
          %case "ModelReference"
            %assign condition = SLibMdlRefLocalPreprocessorCondition(expandedBlock)
            %break
          %default
            %assign condition = "0"
            %% unexpected block type
            %assert 1
            %break
        %endswitch
      %if mIdx > 0
        %assign logic = logic + " + "
      %endif
      %assign logic = logic + "(" + condition + ")"
    %endforeach
    /* Exactly one variant for '%<SLibGrBlockName(nonExpandedGrSrc)>' should be active */
    #if %<logic> != 1
    #error Exactly one variant for '%<SLibGrBlockName(nonExpandedGrSrc)>' should be active
    #endif
  %endforeach
  
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% Function: SLibParamIsImportedMacroUsedInVariantCondition =================
%% Abstract:
%%   Checks to see if the given parameter is one of the parameters
%%   used in the condition expression of any Simulink.Variant object.
%%   The dataRec may have a flag indicating its use in variant condition
%%   expression.
%%
%function SLibParamIsImportedMacroUsedInVariantCondition(dataRec) void
  %return dataRec.IsImportedMacroUsedInVariantCondExpr
%endfunction

%% Function: SLibGetCodeVariantDataForReport ================================
%% Abstract:
%%   returns a data structure that will be passed to
%%   private/genCodeVariantReport to produce the Code Variants section of
%%   the code generation report. The data structure is a copy of the
%%   CodeVariants structure in the .RTW file with additional information added:
%%     1. the variant condition and subsystem or referenced model is added to
%%        the ExpandedBlock record of each CodeVariantGroup record.
%%     2. the block name and block path of the original (non-expanded) model
%%        block are added to each CodeVariantGroup record
%%     3. the block name and block path of each model block that uses a
%%        Simulink.Variant object is added to each SimulinkVariantObject
%%        record
%function SLibGetCodeVariantDataForReport() void
  %if ::CompiledModel.HasCodeVariants

    %assign cvData = ::CompiledModel.CodeVariants
    
    %% augment each expanded block's information with the condition
    %% that selects it and the model it references. Also replace
    %% the original block's index with the block's name
    %assign numVariantGroups = cvData.NumCodeVariantGroups
    %foreach vgIdx = numVariantGroups
      %assign nonExpandedGrSrc = cvData.CodeVariantGroup[vgIdx].NonExpandedGrSrc
      %assign numExpandedBlocks = cvData.CodeVariantGroup[vgIdx].NumExpandedBlocks
      %foreach ebIdx = numExpandedBlocks
        %assign expandedBlockIdx = ...
          cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx].FirstInstanceSrcIndex
        %assign expandedBlock = ...
          ::CompiledModel.System[expandedBlockIdx[0]].Block[expandedBlockIdx[1]]
        %switch expandedBlock.Type
          %case "SubSystem"
            %assign condition = expandedBlock.LocalPreprocessorCondition
            %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
              SubsystemBlockName LibGetBlockName(expandedBlock)
            %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
              SubsystemBlockPath LibGetBlockPath(expandedBlock)
            %break
          %case "ModelReference"
            %assign condition = SLibMdlRefLocalPreprocessorCondition(expandedBlock)
            %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
              ReferencedModel expandedBlock.ParamSettings.ReferencedModelName
            %break
          %default
            %assign condition = "0"
            %% unexpected block type
            %assert 1
            %break
        %endswitch
        %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
          VariantCondition condition
      %endforeach
      %% append the name of the block to the record
      %addtorecord cvData.CodeVariantGroup[vgIdx] ...
        NonExpandedBlockName SLibGrBlockName(nonExpandedGrSrc)
      %addtorecord cvData.CodeVariantGroup[vgIdx] ...
        NonExpandedBlockPath SLibGrBlockPath(nonExpandedGrSrc)
    %endforeach

    %% augment each Simulink.Variant object with the names and paths of
    %% the blocks that use the variant
    %assign numVariantObjects = cvData.NumSimulinkVariantObjects
    %foreach voIdx = numVariantObjects
      %% create two vectors sized by the number of rows in the
      %% ReferencedBy matrix, which is the number of referencing blocks
      %assign sizeOfReferencedByMatrix = ...
        SIZE(cvData.SimulinkVariantObject[voIdx].ReferencedBy)
      %assign numBlocks = sizeOfReferencedByMatrix[0]
      %if numBlocks > 0
        %assign blockNames = Vector(%<numBlocks>) [0:%<numBlocks-1>]
        %assign blockPaths = Vector(%<numBlocks>) [0:%<numBlocks-1>]
        
        %% put the names and paths of the referenced blocks in the vectors
        %foreach bIdx = numBlocks
          %assign refBlkGrSrc = ...
            cvData.SimulinkVariantObject[voIdx].ReferencedBy[bIdx]
          %assign blockNames[bIdx] = SLibGrBlockName(refBlkGrSrc)
          %assign blockPaths[bIdx] = SLibGrBlockPath(refBlkGrSrc)
        %endforeach
        
        %% append the vectors to the SimulinkVariantObject record
        %addtorecord cvData.SimulinkVariantObject[voIdx] ...
          ReferencedByBlockNames blockNames
        %addtorecord cvData.SimulinkVariantObject[voIdx] ...
          ReferencedByBlockPaths blockPaths
      %endif
    %endforeach
    
    %return cvData
  %else
    %return
  %endif
%endfunction

%% Function: LibCacheSystemIncludes ============================================
%% Abstract:
%%   Goes through each system, and caches the include of any child
%%   systems that will be parented by the system.
%%   Called in *wide.tlc.
%%
%function LibCacheSystemIncludes(sysIdx) void
  %% Cache necessary includes
  %assign system = System[sysIdx]
  %if (system.FileNameOwnerIdx == sysIdx)
    %openfile sysheader
    %foreach idx = SIZE(system.IncludedChildSystemIdx,1)
      %assign inChildSysIdx = system.IncludedChildSystemIdx[idx]
      %assign name = ::CompiledModel.System[inChildSysIdx].SystemFileName
      %<GetHideChildDefineSymbol("ifndef")>\
      #include "%<name>.h"
      %<GetHideChildDefineSymbol("endif")>\
    %endforeach
    %assign numMdlRefBlks = system.NumIncludedModelReference
    %foreach rowIdx = numMdlRefBlks
      %% a row matrix containing [sysIdx, bIdx]
      %assign mdlRefInfo = system.IncludedModelReference[rowIdx] 
      %assign mSysIdx = mdlRefInfo.SysIdx
      %assign bIdx    = mdlRefInfo.BlockIdx
      %assign blk     = System[mSysIdx].Block[bIdx]
      %assign blockInterface = GetModelrefInterface(blk)
      %assign name           = blockInterface.FileName
      %assign instancesWithConditions = mdlRefInfo.InstancesWithConditions
      %assign condition = ""
      %if !ISEMPTY(instancesWithConditions)
        %assign numInstances = SIZE(instancesWithConditions, 0)
        %foreach instIdx = numInstances
          %assign mSysIdx2 = instancesWithConditions[instIdx][0]
          %assign bIdx2    = instancesWithConditions[instIdx][1]
          %assign blk2     = System[mSysIdx2].Block[bIdx2]
          %if instIdx > 0
            %assign condition = condition + " || "
          %endif
          %assign condition = condition + ...
            "(" + SLibMdlRefNetPreprocessorCondition(blk2) + ")"
        %endforeach
        #if %<condition>
      %endif
      %<GetHideChildDefineSymbol("ifndef")>\
      %if blockInterface.IsScalableBuild && ...
          !SLibIsLangCPPEncap(blk.MdlRefTargetLang)
        #define %<blockInterface.HideChildDefineSymbol>
      %endif
      %if !((blockInterface.IsScalableBuild && ...
             SLibIsLangCPPEncap(blk.MdlRefTargetLang)) || ...
            (SLibIsLangCPPEncap(blk.MdlRefTargetLang) && ...
             ConfigSet.UseOperatorNewForModelRefRegistration))
            #include "%<name>.h"
      %endif
      %<GetHideChildDefineSymbol("endif")>\
      %if !ISEMPTY(condition)
        #endif /* %<condition> */
      %endif
    %endforeach
    %closefile sysheader
    %<LibAddToSystemField(system, "SystemIncludes", sysheader)>
  %endif
%endfunction %% LibCacheSystemIncludes

%% Function: LibDumpSystemIncludes =============================================
%% Abstract:
%%   Dumps headers(C)/specifications(Ada) of the systems non-inlined 
%%   children systems.  
%%
%function LibDumpSystemIncludes(system) void
  %assign systemIncludes = LibGetSystemField(system, "SystemIncludes")
  %if !WHITE_SPACE(systemIncludes)
    %openfile sysIncludeBuffer
    
    /* Child system includes */
    %<systemIncludes>
    %closefile sysIncludeBuffer
    %return sysIncludeBuffer
  %else
    %return ""
  %endif
%endfunction %% LibDumpSystemIncludes

%% Function: LibDumpSystemTypeDefs =============================================
%% Abstract:
%%   Dump systems type definitions.
%%
%function LibDumpSystemTypeDefs(system) void
  %assign systemTypeDefs = LibGetSystemField(system, "SystemTypeDefs")
  %if !WHITE_SPACE(systemTypeDefs)
    %openfile sysTypeDefBuffer
    
    /* Type definitions */
    %<systemTypeDefs>
    %closefile sysTypeDefBuffer
    %return sysTypeDefBuffer
  %else
    %return ""
  %endif
%endfunction


%% Function: LibDumpSystemFcnPrototype =========================================
%% Abstract:
%%   This function return the function prototype definition for a non-inlined
%%   system
%%
%function LibDumpSystemFcnPrototype(system) void
  %assign tmpFcnBuffer = ""
  %if !WHITE_SPACE(LibGetSystemField(system, "SystemFcnPrototype"))
    %openfile tmpFcnBuffer
    %if IsModelReferenceBaseSys(system)
      %<GetHideChildDefineSymbol("ifndef")>\
    %endif
    %<LibDumpSystemPrototype(system)>\
    %if IsModelReferenceBaseSys(system)
      %<GetHideChildDefineSymbol("endif")>\
    %endif
    %closefile tmpFcnBuffer
  %endif
  %return tmpFcnBuffer  
%endfunction %% LibDumpSystemFcnPrototype

%% Function: LibDumpSystemBanner ===============================================
%% Abstract:
%%   This function return the banner of a non-inlined system
%%
%function LibDumpSystemBanner(system) void
  %assign bannerBuf = ""
  %assign sysInfo = GetSystemNameForComments(system)
  %openfile bannerBuf
  /*
  * Code generation for system %<sysInfo>
  * For more details, see corresponding source file %<system.SystemFileName>.c 
  *
  */
  %closefile bannerBuf
  %return bannerBuf
%endfunction %% LibDumpSystemBanner

%% Function: SLibFcnPrototypeToRec ================================================
%% Abstract:
%%   Convert function declaration strings to a fcuntion record 
%%   fcnRec { Name, Params, Returns}
%%   It will be %undef at the call site
%%
%function SLibFcnPrototypeToRec(fcnDecl)
  %assign fcnRec = FEVAL("rtwprivate", "rtw_getFcnRecFromDecl", fcnDecl)
  %return fcnRec
%endfunction %% SLibFcnPrototypeToRec
  
%% Function: SLibDumpFunctionBanner ===============================================
%% Abstract:
%%   This function return the banner of a generated function
%%   Input fcnRec is a struct with at least following fields:
%%      Name: function Name
%%      Returns: function return type
%%      Params: function parameters
%%      Type: function time, e.g. Output, Update, OutputUpdate
%%
%function SLibDumpFunctionBanner(fcnRec) void
  %assign cs = ::CompiledModel.ConfigSet
  %% Do not generate any comments if GenerateComments is off 
  %if !cs.GenerateComments
    %return " "
  %endif
  %assign ModelName = LibGetModelName()
  %assign IsSharedUtility = GenUtilsSrcInSharedLocation && ...
    ISEQUAL(fcnRec.Category, "utility")
  
  %assign BlockDescription = ""
  %assign BlockDescriptionContent = ""
  %if ISFIELD(fcnRec, "BlockDescription")
    %assign BlockDescription = fcnRec.BlockDescription
    %if !ISEMPTY(BlockDescription)
      %assign BlockDescriptionContent = FEVAL("rtwprivate", ...
        "rtw_format_banner", "getBlockDescriptionContent", BlockDescription)
    %endif
  %endif
  %%
  %% Generate a default format banner if either
  %%   1. Non ERT target; or 
  %%   2. there is no function_banner_template.tlc for member functions
  %%   3. there is no function_banner_template_sharedutility.tlc for shared utility
  %%
  %if IsSharedUtility
    %if GenerateDefaultFcnBannerSharedUtil == 0
      %% Initialize GenerateDefaultFcnBannerSharedUtil cache
      %if !SLibIsERTTarget() || !FILE_EXISTS("function_banner_template_sharedutility.tlc")
        %assign ::GenerateDefaultFcnBannerSharedUtil = 1
      %else
        %assign ::GenerateDefaultFcnBannerSharedUtil = 2
      %endif
    %endif 
  %else
    %if GenerateDefaultFcnBanner == 0
      %% Initialize GenerateDefaultFcnBanner cache
      %if !SLibIsERTTarget() || !FILE_EXISTS("function_banner_template.tlc")
        %assign ::GenerateDefaultFcnBanner = 1
      %else
        %assign ::GenerateDefaultFcnBanner = 2
      %endif
    %endif
  %endif 
 
  
  %if (!IsSharedUtility && GenerateDefaultFcnBanner == 1) || ...
    (IsSharedUtility && GenerateDefaultFcnBannerSharedUtil == 1)
    %assign FunctionDescription = FEVAL("rtwprivate", "rtw_format_banner", "formatFcnDescription",...
      fcnRec.Abstract, 0, 0)
    %assign bannerBuf = FunctionDescription + "\n" + BlockDescription
    %assign bannerBuf = FEVAL("rtwprivate", "rtw_format_banner", "formatBanner", ...
      bannerBuf, "classic", 0)
    %return bannerBuf
  %endif  

  %%
  %% Generatec customized function banner
  %%
  %if ISFIELD(fcnRec, "GeneratedFor")
    %assign GeneratedFor = "%<fcnRec.GeneratedFor>"
  %else
    %assign GeneratedFor = ""
    %if ISEQUAL(fcnRec.Category, "model")
      %% note: subsystem build may report wrong <root> as a temp model is created.
      %assign GeneratedFor = "'<Root>'"
    %endif
  %endif
   
  %if TYPE(fcnRec.Params) == "Vector" && SIZE(fcnRec.Params, 1) > 1
    %assign fcnParams = ""
    %foreach idx = SIZE(fcnRec.Params, 1)
      %assign fcnParams = "%<fcnParams>%<fcnRec.Params[idx]>"
    %endforeach
    %assign fcnRec.Params = "%<fcnParams>"
  %endif
  %assign rawArguments = fcnRec.Params
  %assign rawFcnDescription = fcnRec.Abstract
  %assign rawReturnType = fcnRec.Returns
  %assign FunctionName = fcnRec.Name
  %% CPP constructor and desctructor have no return type
  %if ISEQUAL(fcnRec.Category, "cpp") && ISFIELD(fcnRec, "Type") && ...
    (ISEQUAL(fcnRec.Type, "C++ constructor") || ISEQUAL(fcnRec.Type, "C++ destructor"))    
    %assign isCppStructor = TLC_TRUE
  %else
    %assign isCppStructor = TLC_FALSE
  %endif
  %assign GeneratedBy = fcnRec.GeneratedBy  
  %if IsSharedUtility
    %include "function_banner_template_sharedutility.tlc"
  %else
    %include "function_banner_template.tlc"
  %endif
  %return bannerBuf  
%endfunction %% SLibDumpFunctionBanner

%% Function: LibDumpSystemHeader ===============================================
%% Abstract: 
%%   Dump required details in the Systems header file. (does not include 
%%   "root").
%%     - #include for children systems
%%     - Functionprototype for the system
%%   This function is called from srthdr.tlc
%%
%%   NOTE: 
%% 	   We have included the main system header file here, this has to be 
%% 	   removed once we have split the vectors (Parameters, BIO, etc) and 
%% 	   put them in corresponding system header file.
%%
%function LibDumpSystemHeader(system) void
  %if system.FileNameOwnerIdx == system.SystemIdx
    %assign fileName  = SLibGetSystemHeaderFileName(system)
    %% Subsystem prototypes
    %openfile fcnBuff
    %<LibDumpSystemFcnPrototype(system)>
    %closefile fcnBuff
    %assign rootSysFileName = GetRootSystemFileName()
    
    %assert(system.SystemFileName != rootSysFileName)
    
    %assign duplicate = LibAddToModelHeaders(fileName)
    %% Dump comments, only the first time
    %assign bannerBuf = LibDumpSystemBanner(system)
    %<LibRegCommonIncludes(system.SystemIdx)>
    %assign includeBuf = SLibDumpCommonIncludes(system)
    %<SLibCacheSystemCodeToFile("sys_hdr_ban", system, bannerBuf)>
    %if IsModelReferenceBaseSys(system) && IsModelRefScalableBuild()
      %if LibIsSystemField(system, "MRSystemFcnPrototype")
        %% Make sure the system has some non-empty functions which need a
        %% prototype. Registration (mr_mdl_initialize) function and RegMdlInfo
        %% functions are handled separately and not included in this buffer.
        %assign mrFcnBuff = LibGetSystemField(system, "MRSystemFcnPrototype")
        %if !WHITE_SPACE(mrFcnBuff) && !GenerateClassInterface
          %<SLibCacheSystemCodeToFile("sys_fcn_prototype", ...
            system, mrFcnBuff)>
        %endif
      %endif
    %endif
    %if !(IsModelReferenceBaseSys(system) && GenerateClassInterface)
      %<SLibCacheSystemCodeToFile("sys_fcn_decl", system, fcnBuff)>
    %endif
    %%if !WHITE_SPACE(includeBuf)
      %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, includeBuf)>
    %%endif
    %% Include the types header file
    %if LibSystemIsReusedLibraryFcn(system)
      %% Emit the rtP struct typedef aliases directly into the .h file
      %assign typedefBuffer = ...
		SLibGetSystemPrmBuffer(system, "SimulinkGlobal", "Typedef")
	  %if !WHITE_SPACE(typedefBuffer)
        %openfile typesIncludeBuf
        %<typedefBuffer>
        %closefile typesIncludeBuf
        %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, typesIncludeBuf)>
      %endif
    %else
      %assign mdlTypesHdrFileName = SLibGetFileNameForCode("mdl_types_hdr")
      %if !WHITE_SPACE(mdlTypesHdrFileName)
        %openfile typesIncludeBuf
        #include "%<mdlTypesHdrFileName>.h"  
        %closefile typesIncludeBuf
        %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, typesIncludeBuf)>
      %endif
    %endif   
    %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, LibDumpSystemIncludes(system))>
    %% Intrinsic types
    %% Primitive types
    %<SLibCacheSystemCodeToFile("sys_primitive_typedef", system, ...
      SLibDeclarePrimitiveTypedefs())>
  %endif
%endfunction %%  LibDumpSystemHeader
  
%% Function: LibDeclareCompoundDataTypes =======================================
%% Abstract:
%%   Reserved for compound data types.
%%
%function LibDeclareCompoundDataTypes() void
  %return ""
%endfunction


%% Function: LibDeclareMemoryAllocationMacros ==================================
%% Abstract:
%%   Place in model.h the following macros.
%%
%function LibDeclareMemoryAllocationMacros() void
  %assign nulldef = SLibGetNullDefinitionFromTfl()
  %openfile tmpFcnBuf
  %%
  %% rt_VALIDATE_MEMORY can only be used in the registration function.
  %%
  #define rt_VALIDATE_MEMORY(S, ptr) \
  if(!(ptr)) {%<"\\">
  %<RTMSetErrStat("RT_MEMORY_ALLOCATION_ERROR")>;%<"\\">
  %<"}">
  
  #if !defined(_WIN32)
  #define rt_FREE(ptr) \
  if((ptr) != %<nulldef>) {%<"\\">
  free((ptr));%<"\\">
  (ptr) = %<nulldef>;%<"\\">
  %<"}">
  #else
  /* Visual and other windows compilers delcare free without const! */
  #define rt_FREE(ptr) \
  if((ptr) != %<nulldef>) {%<"\\">
  free((void *)(ptr));%<"\\">
  (ptr) = %<nulldef>;%<"\\">
  %<"}">
  #endif

  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction



%% Function: LibCheckForValidMTaskDefine =======================================
%% Abstract:
%%   Add C directives to verify that the MULTITASKING define is correct for
%%   the way the code was generated. Prior to version 3.0 (R11), the
%%   MULTITASKING define was under user control. As of version 3.0, the
%%   define now is controlled by Simulink based upon the Solver Mode
%%   fixed step setting.
%% 
%function LibCheckForValidMTaskDefine() void
  %openfile tmpFcnBuf
  %if ::CompiledModel.SolverType == "FixedStep"
    %if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
      %assign str = "Model (%<::CompiledModel.Name>) was built \\\n" ...
	"in MultiTasking solver mode, however the MULTITASKING define \\\n" ...
	"is not present. Please verify that your template makefile is \\\n" ...
	"configured correctly."
      
      #if !defined(MULTITASKING) && !defined(NRT)
      #  error %<str>
      #endif
    %else
      %assign str = "Model (%<::CompiledModel.Name>) was built in \\\n" ...
	"SingleTasking solver mode, however the MULTITASKING define is " ...
	"\\\npresent. If you have multitasking (e.g. -DMT or " ...
	"-DMULTITASKING) \\\ndefined on the Code Generation page of Simulation " ...
	"parameter dialog, please \\\nremove it and on the Solver page, " ...
	"select solver mode \\\nMultiTasking. If the Simulation parameter " ...
	"dialog is configured \\\ncorrectly, please verify that your " ...
	"template makefile is \\\nconfigured correctly."
      
      #if defined(MULTITASKING)
      #  error %<str>
      #endif
    %endif
  %else
    %assign str = "Models using the variable step solvers cannot define " ...
      "MULTITASKING"
    
    #if defined(MULTITASKING)
    #  error %<str>
    #endif
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction %% LibCheckForValidMTaskDefine


%function LibDeclareSystemRequirements() void
  %openfile tmpFcnBuf

  %if ISFIELD(::CompiledModel, "Requirements")
      /*-
       * Requirements for '<Root>': %<Name>
      %if ISFIELD(::CompiledModel.Requirements, "Requirements")
          %<::CompiledModel.Requirements.Requirements>
      %endif
      %if ISFIELD(::CompiledModel.Requirements, "InheritedRequirements")
          %<::CompiledModel.Requirements.InheritedRequirements>
      %endif
      */
  %endif

  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareSystemHierarchy =========================================
%% Abstract:
%%   Create the system hierarchy comment.
%%
%function LibDeclareSystemHierarchy() void
  %openfile tmpFcnBuf
  
  %% see if it is a right-click (subsystem) build.
  %assign parentName = ""
  %assign srcSubsysName = ""
  %if ISFIELD(::CompiledModel, "SubsystemPathForRightClickBuild")
    %assign parentName = ::CompiledModel.SubsystemPathForRightClickBuild
    %assign srcSubsysName = ::CompiledModel.SubsystemNameForRightClickBuild
  %endif
  /*-
   * The generated code includes comments that allow you to trace directly 
   * back to the appropriate location in the model.  The basic format
   * is <system>/block_name, where system is the system number (uniquely
   * assigned by Simulink) and block_name is the name of the block.
   *
  %if ISEMPTY(parentName)
   * Use the MATLAB hilite_system command to trace the generated code back
   * to the model.  For example,
   *
   * hilite_system('<S3>')    - opens system 3
   * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3
  %else
    %%
    %% Subsystem build
    %%
    %assign srcSubsys = parentName + "/" + srcSubsysName
   * Note that this particular code originates from a subsystem build,
   * and has its own system numbers different from the parent model.
   * Refer to the system hierarchy for this subsystem below, and use the
   * MATLAB hilite_system command to trace the generated code back
   * to the parent model.  For example,
   *
   * hilite_system('%<srcSubsys>')    - opens subsystem %<srcSubsys>
   * hilite_system('%<srcSubsys>/Kp') - opens and selects block Kp
  %endif
   *
   * Here is the system hierarchy for this model
   *
  %if ISEMPTY(parentName)
    * '<Root>' : '%<Name>'
  %else
    * '<Root>' : '%<parentName>'
  %endif
  %foreach sysIdx = NumSubsystems
    %assign id   = sysIdx+1
    %if ISEMPTY(parentName)
      %assign path = LibMangledPathName(Subsystem[sysIdx].Name)
    %else
      %% Subsystem build: Skip hidden subsystems in the temporary model.
      %assign sysName = SYSNAME(Subsystem[sysIdx].Name)
      %if ISEQUAL(sysName[0], "Root") && !ISEQUAL(sysName[1], srcSubsysName)
        %continue
      %endif
      %assign path = SLibMangledSubsystemPathName(parentName,...
                                                  Subsystem[sysIdx].Name)
    %endif
    %if id < 10
      * '<S%<id>>'   : '%<path>'
    %elseif id < 100
      * '<S%<id>>'  : '%<path>'
    %else
      * '<S%<id>>' : '%<path>'
    %endif
  %endforeach
   */
   %closefile tmpFcnBuf
   %return tmpFcnBuf
%endfunction


%% Function: LibDeclareReducedBlocks ===========================================
%% Abstract:
%%   Create the reduced blocks comment.
%%
%function LibDeclareReducedBlocks() void
  %if (!ShowEliminatedStatements)
    %return
  %endif
  
  %openfile tmpFcnBuf
  %with ReducedBlocks
  %if NumReducedBlocks > 0

    /*-
     * These blocks were eliminated from the model due to optimizations:
     *
    %foreach bIdx = NumReducedBlocks
      %assign b = Block[bIdx]
     * Block '%<b.Name>' : %<b.OptimizationInfo>
    %endforeach
     */
  %endif
  %endwith
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction


%% Function: LibDumpGroundExterns ==============================================
%% Abstract:
%%   Declare external references to ground variables
%%
%function LibDumpGroundExterns() void
  %openfile tmpFcnBuf
  %with DataTypes
    %assign qualifiers = SLibGetGroundQualifiers()          
    %foreach dtIdx = NumDataTypes
      %assign dt = DataType[dtIdx]      
      %% real ground
      %if dt.GroundReqInMemory
        %openfile declaration
        %if SLibAutosarCompilerAbstractionRequired()
          extern %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dt.Name, TLC_FALSE, TLC_FALSE, dt.GroundName, "DataGlobal")>;\
        %else
          extern %<qualifiers> %<dt.Name> %<dt.GroundName>;\
        %endif
	/* %<dt.Name> ground */
        %closefile declaration
        %<SLibApplyMemSecToDataDecl(declaration, ...
            "MemSecDataConstants", dt.GroundName)>\
      %endif
      %% complex ground
      %if dt.ComplexGroundReqInMemory
        %openfile declaration
	extern %<qualifiers> %<dt.ComplexName> %<dt.ComplexGroundName>;\
	/* %<dt.Name> complex ground */
        %closefile declaration
        %<SLibApplyMemSecToDataDecl(declaration, ...
            "MemSecDataConstants", dt.ComplexGroundName)>\
      %endif
    %endforeach
  %endwith
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDumpGroundDeclarations =========================================
%% Abstract:
%%   Declares global ground variables.
%%   Arguments:
%%     declareAsStatic: declare ground local or global for 1 and 0,
%%                      respectively.  That is, use "static" keyword if
%%                      declareAsStatic == 1.
%%
%function LibDumpGroundDeclarations(declareAsStatic) void
  %assign keyword = declareAsStatic ? "static" : ""
  %openfile tmpFcnBuffer
  %with DataTypes
    %assign qualifiers = SLibGetGroundQualifiers()    
    %foreach dtIdx = NumDataTypes
      %assign dt = DataType[dtIdx]    
      %% real ground
      %if dt.GroundReqInMemory
        %if !ISFIELD(dt, "GroundAlreadyDefined")
	  %assign name = dt.GroundName

          %openfile definition
          %if SLibAutosarCompilerAbstractionRequired()
            %<keyword> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dt.Name, TLC_FALSE, TLC_FALSE, name, "DataGlobal")> = %<LibGetGroundInitFromId(dtIdx)>;\
          %else
            %<keyword> %<qualifiers> %<dt.Name> %<name> = %<LibGetGroundInitFromId(dtIdx)>;\
          %endif
          /* %<dt.Name> ground */\
          %closefile definition
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataConstants", name)>\
          %% Guard against multiple definitions
          %addtorecord dt GroundAlreadyDefined TLC_TRUE
        %endif
      %endif
      %% complex ground
      %if dt.ComplexGroundReqInMemory
        %if !ISFIELD(dt, "CmplxGroundAlreadyDefined")
          %assign name = dt.ComplexGroundName
          %openfile definition
          %if SLibAutosarCompilerAbstractionRequired()
            %<keyword> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dt.ComplexName, TLC_FALSE, TLC_FALSE, name, "DataGlobal")> = ...
              {%<dt.GroundValue>, %<dt.GroundValue>};\
          %else
            %<keyword> %<qualifiers> %<dt.ComplexName> %<name> = ...
              {%<dt.GroundValue>, %<dt.GroundValue>};\
          %endif
          /* %<dt.Name> complex ground */\
          %closefile definition
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataConstants", name)>\
          %% Guard against multiple definitions
          %addtorecord dt CmplxGroundAlreadyDefined TLC_TRUE 
        %endif
      %endif
    %endforeach
  %endwith
  %closefile tmpFcnBuffer
  %if !WHITE_SPACE(tmpFcnBuffer)
    %return ("\n" + tmpFcnBuffer)
  %else
    %return ""
  %endif
%endfunction


%% Function: FcnCommonHeaderInfo ==============================================
%% Abstract:
%%   Output the comment header for generated code.
%%
%function FcnCommonHeaderInfo() void
  %openfile tmpFcnBuf
  * Code generation for model "%<::CompiledModel.Name>.mdl".
  *
  * Model version              : %<ModelVersion>
  * Simulink Coder version : %<Version>
%if GenerateFullHeader
  * %<CorCPPForBuildLogsandComments()> source code generated on : %<TLC_TIME>
  %endif
%if ISFIELD(::CompiledModel, "CompiledWarningMsg")
  * Warning Messages           : %<CompiledWarningMsg>
%endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibCodeGenSettings ===============================================
%% Abstract:
%%   Output comment on code generation configuration
%%
%function SLibCodeGenSettings() void
  %if !GenerateFullHeader || !IncludeCodeGenSettings
    %return ""
  %endif
  %openfile tmpFcnBuf

Target selection: %<ConfigSet.SystemTargetFile>
  %if !SLibIsERTTarget()
Note: GRT includes extra infrastructure and instrumentation for prototyping
  %endif
Embedded hardware selection: %<ConfigSet.ProdHWDeviceType>
  %if !%<ConfigSet.ProdEqTarget>
    %assign emulationHWComment = SLibEmulationHWComment()
    %if !ISEMPTY(emulationHWComment)
Emulation hardware selection: %<emulationHWComment>
    %endif
  %endif
  %% Include objective priorities in the comments
  %if ISEMPTY(ConfigCheckComments)
    %assign ::ConfigCheckComments = FEVAL("rtwprivate",  ...
      "genConfigCheckReportComments", LibGetModelName())
  %endif
%<ConfigCheckComments>
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibCommonHeaderInfo ==============================================
%% Abstract:
%%   Output the comment header for generated code.
%%
%function SLibCommonHeaderInfo() void
  %assign tmpbuf = FEVAL("rtwprivate", "rtw_format_banner", "insert_comment_prefix", SLibCodeGenSettings())
  %return FcnCommonHeaderInfo() + tmpbuf
%endfunction

%% Function: SLibCommonUtilHeaderInfo() ========================================
%% Abstract:
%%   Output comment on code generation configuration if it is not in shared
%%   directory.
%%
%function SLibCommonUtilHeaderInfo() void
  %assign str = FcnCommonHeaderInfo()
  %if !GenUtilsSrcInSharedLocation
    %assign tmpbuf = FEVAL("rtwprivate", "rtw_format_banner", "insert_comment_prefix", SLibCodeGenSettings())
    %assign str = str + tmpbuf
  %endif
  %return str
%endfunction

%% Function: SLibSystemBanner ==================================================
%% Abstract:
%%   Output the banner for a generated system
%%
%function SLibSystemBanner(system) void
  %assign sysInfo = GetSystemNameForComments(system)

  %openfile tmpFcnBuf
  * Code generation for system %<sysInfo>
  *
  * Model                      : %<::CompiledModel.Name>
  * Model version              : %<ModelVersion>
  * Simulink Coder version : %<Version>
%if GenerateFullHeader
  * %<CorCPPForBuildLogsandComments()> source code generated on : %<TLC_TIME>
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction %% SLibSystemBanner


%% Function: SLibGetSystemOutputFileBaseName ===================================
%% Abstract:
%%    return base file name.
%function SLibGetSystemOutputFileBaseName(system) void
  %if (system.Type == "root")
    %return LibGetMdlSrcBaseName()
  %else
    %if (CodeFormat == "S-Function") && ...
      (system.SystemFileName == LibGetModelName())
      %return LibGetMdlSrcBaseName()
    %else
      %return system.SystemFileName
    %endif
  %endif
%endfunction

%% Function: SLibGetSystemOutputFileName =======================================
%%
%% Abstract:
%%    Convert a "base" filename to an appropriate output filename depending on
%%    the language for which we are generating code.
%%
%function SLibGetSystemOutputFileName(system) void
  %assign baseFileName = system.SystemFileName
  %assign baseFile     = baseFileName + "." + ::LangFileExt
  %return(baseFile)
%endfunction %% SLibGetSystemOutputFileName

%% Function: SLibGetSystemHeaderFileName =======================================
%%
%% Abstract:
%%    Convert a "base" filename to an appropriate header filename depending on
%%    the language for which we are generating code.
%%
%function SLibGetSystemHeaderFileName(system) void
  %assign baseFileName = system.SystemFileName
  %return("%<baseFileName>.h")
%endfunction %% SLibGetSystemHeaderFileName


%% Function: LibAddToModelHeaders ==============================================
%% Abstract:
%%      Add a file name to the list of headers needed to build this model
%%      Returns 1 if the filename passed in was a duplicate (i.e. it was
%%      already in the headers list) and 0 if it was not a duplicate.
%%
%function LibAddToModelHeaders(newFile) void
  %assign duplicate = 0
  %% scan for duplicates
  %if ::CompiledModel.NumHeaders > 0
    %foreach idx = ::CompiledModel.NumHeaders
      %if (::CompiledModel.Headers[idx] == "%<newFile>")
	%assign duplicate = 1
	%break
      %endif
    %endforeach
    %if (!duplicate)
      %assign ::CompiledModel.Headers = ::CompiledModel.Headers + "%<newFile>"
      %assign ::CompiledModel.NumHeaders = ::CompiledModel.NumHeaders + 1
    %endif
  %else
    %assign ::CompiledModel.Headers    = ::CompiledModel.Headers + "%<newFile>"
    %assign ::CompiledModel.NumHeaders = 1
  %endif
  %return (duplicate)
%endfunction %% LibAddToModelHeaders

%% Function: SLibIncludeRTWGeneratedChildSysExportFile =========================
%% Abstract:
%%   Include child s-function export files to model export file.
%%
%function SLibIncludeRTWGeneratedChildSysExportFile() void
  %if ISFIELD(::CompiledModel, "RTWGeneratedChildSfcnExportFiles")
    %openfile includesBuf
    %assign expFiles = ::CompiledModel.RTWGeneratedChildSfcnExportFiles
    %<expFiles>          
    %if CodeFormat == "S-Function"
      %assign tmpName = Accelerator ? "simulink_only_sfcn" : Name
      #undef S_FUNCTION_NAME
      
      #define S_FUNCTION_NAME %<tmpName>
    %endif
    %closefile includesBuf
    %<SLibCacheCodeToFile("mdl_src_incl", includesBuf)>
  %endif
%endfunction %% SLibIncludeRTWGeneratedChildSysExportFile

%% Function: SLibDumpStructDefWithAlignment =========================
%% Abstract:
%%   Dump the defition of a struct type with alignment directive, if 
%% applicable.
%%
%function SLibDumpStructDefWithAlignment(idTag, id, align, memBuf) void
  %openfile structdef
  
  %assign aSyntax = "" 
  %if structDAFlag.supported && align > 0
    %assign aSyntax = SLibGetAlignmentSyntax(::CompiledModel.Name, id, "", ...
                                             align, "DATA_ALIGNMENT_WHOLE_STRUCT")
  %endif
  
  %if !ISEMPTY(aSyntax) %% start of struct definition
    %if structDAFlag.position == "DATA_ALIGNMENT_PREDIRECTIVE"
      typedef %<aSyntax> struct %<idTag> {
    %elseif structDAFlag.position == "DATA_ALIGNMENT_PRECEDING_STATEMENT"
      %<aSyntax>
      typedef struct %<idTag> {
    %else
      typedef struct %<idTag> {
    %endif
  %else
     typedef struct %<idTag> {
  %endif
  
  %<memBuf>            %% struct memebers
  
  %if !ISEMPTY(aSyntax) 
     %if structDAFlag.position == "DATA_ALIGNMENT_POSTDIRECTIVE" 
        } %<id> %<aSyntax>;
     %elseif structDAFlag.position == "DATA_ALIGNMENT_FOLLOWING_STATEMENT"
        } %<id>;
        %<aSyntax>
     %else 
        } %<id>;
     %endif
  %else
    } %<id>;
  %endif              %% end of struct definition
  
  %closefile structdef
  
  %return structdef
%endfunction


%endif %% _COMMONHDRLIB_

%% [EOF] commonhdrlib.tlc
