%% ============================================================================
%% File : commonprmlib.tlc
%%
%% Abstract:
%%   This system file produces the structure instances.
%%
%% 
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%% ============================================================================
%selectfile NULL_FILE

%if EXISTS("_COMMONPRMLIB_") == 0
%assign _COMMONPRMLIB_ = 1

%realformat "CONCISE"

%% ============================================================================
%% Create global cache variables to hold each structure instance
%% ============================================================================

%<LibAddToCompiledModel("BlockIOInstance", 0)>
%<LibAddToCompiledModel("ConstBlockIOInstance", 0)>
%<LibAddToCompiledModel("ExportedGlobalSignalsInstance", 0)>
%<LibAddToCompiledModel("ExportedGlobalDWorkInstance", 0)>
%<LibAddToCompiledModel("ContStatesInstance", 0)>

%<LibAddToCompiledModel("MassMatricesGlobalInstance", 0)>

%<LibAddToCompiledModel("DWorkInstance", 0)>
%<LibAddToCompiledModel("PrevZCStatesInstance", 0)>
%<LibAddToCompiledModel("ExternalInputsInstance", 0)>
%<LibAddToCompiledModel("ExternalOutputsInstance", 0)>
%<LibAddToCompiledModel("ExternalInputSizesInstance", 0)>
%<LibAddToCompiledModel("ExternalOutputSizesInstance", 0)>

%% Function: SLibPragmaIdentifierRegexp  =======================================
%% Abstract:
%%  This function does a regular expression search and replace.
%%  It substitutes "\%<identifier>" with whatever is passed
%%  in as the identifier argument
%%
%function SLibPragmaIdentifierRegexp(pragmastring, identifier)
  %if ISEMPTY(pragmastring)
    %return pragmastring
  %endif
  %return FEVAL("regexprep", pragmastring, "\%<identifier>", identifier)
%endfunction


%% Function: SLibApplyMemSecToDataDecl ================================
%% This function is called for model level data.
%% MemSecPackage won't be a field unless it's an ERT target so we
%% don't worry about the pragmas unless it exists.
%function SLibApplyMemSecToDataDecl(declaration, mstype, identifier)
  %return SLibApplyMemSecToDataDeclForSystem(...
      declaration, mstype, identifier, ::CompiledModel.ConfigSet, TLC_TRUE)
%endfunction


%% Function: SLibApplyMemSecToDataDeclForSystem ================================
%% Abstract:
%%   This function creates a data declartion.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.
%%
%function SLibApplyMemSecToDataDeclForSystem(declaration, mstype, identifier, system, isModelData)

  %% Check if Pragma is set to add on Decl
  %if (!SLibIsPragmaOnDecls())
     %return declaration
  %endif
  
  %return SLibApplyMemSecToDataDefnForSystem(declaration, mstype, identifier, system, isModelData)
%endfunction


%% Function: SLibApplyMemSecToDataDefn  ========================================
%% Abstract:
%%   This function returns memory section definition for model level data.
%%
%function SLibApplyMemSecToDataDefn(definition, mstype, identifier)
  %return SLibApplyMemSecToDataDefnForSystem(...
      definition, mstype, identifier, ::CompiledModel.ConfigSet, TLC_TRUE)
%endfunction


%% Function: SLibApplyMemSecToDataDefnForSystem ================================
%% Abstract:
%%   This function creates a data definition.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.
%%
%function SLibApplyMemSecToDataDefnForSystem(definition, mstype, identifier, system, isModelData)

  %assign msDefn = ""
  %assign applyPragma = (SLibIsERTTarget() && ...
                         !FcnIsERTMalloc() && ...
                         !IsModelReferenceSimTarget() && ...
                         SLibAreInternalMemorySectionsDefined())
  
  %if (applyPragma)
    %switch mstype
      %case "MemSecDataConstants"
        %assign memsecname = system.MemSecDataConstants
        %break
      %case "MemSecDataInternal"
        %assign memsecname = system.MemSecDataInternal
        %break
      %case "MemSecDataIO"
        %assign memsecname = system.MemSecDataIO
        %break
      %case "MemSecDataParameters"
        %assign memsecname = system.MemSecDataParameters
        %break
      %default
        %<LibReportFatalError(...
          "Invalid mstype in function: SLibApplyMemSecToDataDefn")>
    %endswitch
    
    %if !ISEMPTY(memsecname) && (memsecname != "Default")
      %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname)
    %endif
  %endif
  
  %openfile buffer
  %% Believe it or not, "system" can actually be the configset, in which
  %% case we are dealing with model data and we skip the net preprocessor 
  %% condition stuff.
  %if !isModelData
    %<SLibIfNetPreprocessorCondition(system)>
  %endif
  %<SLibCreateDefinitionStatement(definition, msDefn, identifier)>
  %if !isModelData
    %<SLibEndIfNetPreprocessorCondition(system)>
  %endif
  %closefile buffer
  %return buffer
%endfunction



%% This function is called for model level functions.
%% MemSecPackage won't be a field unless it's an ERT target so we
%% don't worry about the pragmas unless it exists.
%function SLibGetFcnMemSecPragmaOnDecl(identifier, mstype, preorpost)
  %return SLibGetFcnMemSecPragmaForSystemOnDecl(...
      identifier, mstype, preorpost, ::CompiledModel.ConfigSet)
%endfunction

%% Function: SLibGetFcnMemSecPragmaForSystemOnDecl ===================================
%% Abstract:
%%   This function returns a pragma string.  Depending upon the
%%   arguments, it creates a pre or post pragma.  It also does
%%   %<identifier> substitution within the pragma.
%%
%function SLibGetFcnMemSecPragmaForSystemOnDecl(identifier, mstype, preorpost, system)

  %if !SLibIsPragmaOnDecls()
    %return ""
  %endif

  %return SLibGetFcnMemSecPragmaForSystem(identifier, mstype, preorpost, system)

%endfunction

%% Function: SLibApplyMemSecToDataDefn  ========================================
%% Abstract:
%%   This function returns pragmas for model level functions.
%%
%function SLibGetFcnMemSecPragma(identifier, mstype, preorpost)
  %return SLibGetFcnMemSecPragmaForSystem(...
      identifier, mstype, preorpost, ::CompiledModel.ConfigSet)
%endfunction


%% Function: SLibGetFcnMemSecPragmaForSystem ===================================
%% Abstract:
%%   This function returns a pragma string.  Depending upon the
%%   arguments, it creates a pre or post pragma.  It also does
%%   %<identifier> substitution within the pragma.
%%
%function SLibGetFcnMemSecPragmaForSystem(identifier, mstype, preorpost, system)

  %assign msDefn = ""

  %% Don't add pragmas for a model reference target
  %% Only add pragmas if we're using an ert target
  %% if the mstype doesnt exist in system, we should be inside
  %% the <root> system instead of a subsystem.

  %assign applyPragma = (SLibIsERTTarget() && ...
                         !IsModelReferenceSimTarget() && ...
                         SLibAreInternalMemorySectionsDefined())
  
  %if(!applyPragma)
    %return ""
  %endif

  %switch mstype
    %case "MemSecFuncInitTerm"
      %assign memsecname = system.MemSecFuncInitTerm
      %break
    %case "MemSecFuncExecute"
      %assign memsecname = system.MemSecFuncExecute
      %break
    %case "MemSecFuncSharedUtil"
      %assign memsecname = system.MemSecFuncSharedUtil
      %break
    %default
      %<LibReportFatalError(...
        "SLibGetFcnMemSecPragmaForSystem: Invalid mstype: " + mstype)>
  %endswitch
  
  %if !ISEMPTY(memsecname) && (memsecname != "Default")
    %% The MemSecPackage is always in the ConfigSet.
    %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname)
    %switch preorpost
      %case "Pre"
        %openfile pragma
        %if !WHITE_SPACE(msDefn.Comment)
          %<msDefn.Comment>
        %endif
        %if !WHITE_SPACE(msDefn.PrePragma)
          %<SLibPragmaIdentifierRegexp(msDefn.PrePragma,  identifier)>
        %endif
        %closefile pragma
        %break
      %case "Post"
        %openfile pragma
        %if !WHITE_SPACE(msDefn.PostPragma)
          %<SLibPragmaIdentifierRegexp(msDefn.PostPragma, identifier)>
        %endif
        %closefile pragma
        %break
      %default
        %<LibReportFatalError(...
          "Invalid preorpost in function: SLibGetFcnMemSecPragmaForSystem")>
    %endswitch
    %return pragma
  %endif
  %return ""
%endfunction
  

%% Function: SLibCreateDefinitionStatement
%% Abstract: Create a definition statement that places pragmas above
%%           and below if msDefn is defined
%%
%function SLibCreateDefinitionStatement(definition, msDefn, identifier)
  %if ISEMPTY(msDefn)
    %if ISEMPTY(definition)
      %return definition
    %endif
    %return definition + "\n"
    
  %else
    %%No qualifiers allowed for internal data for now.
    %assign prepragma =  ...
      SLibPragmaIdentifierRegexp(msDefn.PrePragma,  identifier)
    %assign postpragma = ...
      SLibPragmaIdentifierRegexp(msDefn.PostPragma, identifier)

    %openfile buffer
    %if !WHITE_SPACE(msDefn.Comment)
      %<msDefn.Comment>
    %endif    
    %if !WHITE_SPACE(prepragma)
      %<prepragma>
    %endif
    %<definition>
    %if !WHITE_SPACE(postpragma)
      %<postpragma>
    %endif
    %closefile buffer
    
    %return buffer
  %endif
%endfunction

%% Function: FcnGetMemorySectionAttribute ======================================
%% Abstract:
%%   Helper function for checking attributes of memory section for data group
%%   (such as "IsConst" and "IsVolatile".
%%
%% Interpretation of system:
%%   -1:        Root-level system (use memory sections from the ConfigSet)
%%   Otherwise: Standalone subsystem using data
%%
%function FcnGetMemorySectionAttribute(system, memSecGroup, attribute) void
  
  %if TYPE(system) != "Scope"
    %assert(system == -1)
    %assign system = ::CompiledModel.ConfigSet
  %endif
    
  %if SLibAreInternalMemorySectionsDefined()
    %assign memsecname = system.%<memSecGroup>
    %if !ISEMPTY(memsecname) && (memsecname != "Default")    
      %assign msDefn = SLibGetInternalMemorySectionDefForName(memsecname)
      %return msDefn.%<attribute>
    %endif
  %endif
  
  %return TLC_FALSE
%endfunction

%% Function: SLibGetGlobalConstantMemorySectionHasVolatile =====================
%% Abstract:
%%   This function returns true if memory sections are available for this build
%%   and the MemSecDataConstants property has the volatile qualifier selected.
%%
%function SLibGetGlobalConstantMemorySectionHasVolatile() void
  %return FcnGetMemorySectionAttribute(-1, "MemSecDataConstants", "IsVolatile")
%endfunction

%% Function: FcnGetQualifiersForData ===========================================
%% Abstract:
%%   Return the qualifiers for general data structures (e.g., Block I/O)
%%   based on memory section specified in Configuration Parameters dialog.
%%
%% Interpretation of system:
%%   -1:        Root-level system (use memory sections from the ConfigSet)
%%   Otherwise: Standalone subsystem using data
%%
%% Interpretation of canBeConst:
%%   0: Cannot be const
%%   1: Can be const (but not required)
%%   2: Must be const
%%
%function FcnGetQualifiersForData(system, name, mstype, canBeConst) void
  %assign qualifiers = ""

  %if (canBeConst == 2) %% MUST BE CONST
    %assign qualifiers = "const "
    
  %elseif FcnGetMemorySectionAttribute(system, mstype, "IsConst")
    %% Memory section specifies that data should be constant

    %if (canBeConst == 1) %% CAN BE CONST
      %assign qualifiers = "const "

    %else %% CANNOT BE CONST
      %assign warnMessage = "Cannot add const qualifier to %<name>."
      %<LibReportWarning(warnMessage)>
    %endif
  %endif
  
  %if FcnGetMemorySectionAttribute(system, mstype, "IsVolatile")
    %assign qualifiers = qualifiers + "volatile "
  %endif
  
  %return qualifiers
%endfunction

%% Function: FcnGetQualifiersForConstantData ==================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForData for constants.
%%
%function FcnGetQualifiersForConstantData(system, name) void
  %return FcnGetQualifiersForData(system, name, "MemSecDataConstants", 2)
%endfunction

%% Function: SLibGetGroundQualifiers ===========================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForConstantData for data type grounds.
%%
%function SLibGetGroundQualifiers() void
  %return FcnGetQualifiersForConstantData(-1, "data type ground values")
%endfunction

%% Function: SLibGetConstParamQualifiers =======================================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForConstantData for ConstP structure.
%%
%function SLibGetConstParamQualifiers() void
  %return FcnGetQualifiersForConstantData(-1, tConstParamStruct)
%endfunction

%% Function: SLibGetConstParamWithInitQualifiers ===============================
%% Abstract:
%%   Wrapper around FcnGetQualifiersForData for ConstParamWithInit.
%%
%function SLibGetConstParamWithInitQualifiers() void
  %return FcnGetQualifiersForData(-1, tConstParamWithInitStruct, "MemSecDataConstants", 0)
%endfunction

%% Function: SLibGetConstBlockIOQualifiers =====================================
%% Abstract:
%%   Return the qualifiers for ConstBlockIO structure.
%%
%% NOTE: If ConstBlockIO contains non-finite data then it cannot be const.
%%
%function SLibGetConstBlockIOQualifiers() void
  %if SLibCanConstBlockIOBeConst()
    %return FcnGetQualifiersForConstantData(-1, tInvariantSignals)
  %else
    %return FcnGetQualifiersForData(-1, tInvariantSignals, "MemSecDataConstants", 0)
  %endif
%endfunction

%% Function: SLibGetConstBlockIOForSystemQualifiers ============================
%% Abstract:
%%   Return the qualifiers for ConstBlockIO structure of standalone subsystem.
%%
%% NOTE: If ConstBlockIO contains non-finite data then it cannot be const.
%%
%function SLibGetConstBlockIOForSystemQualifiers(system) void
  %if SLibCanConstBlockIOForSystemBeConst(system)
    %return FcnGetQualifiersForConstantData(system, tInvariantSignals)
  %else
    %return FcnGetQualifiersForData(system, tInvariantSignals, "MemSecDataConstants", 0)
  %endif
%endfunction

%% Function: SLibCanConstBlockIOBeConst ========================================
%% Abstract:
%%   Return true if we can put the const qualifier on ConstBlockIO structure.
%%   We cannot do this if there is any non-finite initialization.
%%
%function SLibCanConstBlockIOBeConst() void
  %return ISEMPTY(::CompiledModel.NonFiniteBlockIOAssignmentsCache)  
%endfunction

%% Function: SLibCanConstBlockIOForSystemBeConst ===============================
%% Abstract:
%%   Return true if we can put the const qualifier on ConstBlockIO structure
%%   for standalone subsystem.
%%   We cannot do this if there is any non-finite initialization.
%%
%function SLibCanConstBlockIOForSystemBeConst(system) void
  %return ISEMPTY(LibGetSystemField(system, "CachedNonFiniteBlockIOAssignments"))
%endfunction

%% Function: LibCacheModelStructureInstance ===================================
%% Abstract:
%%   This function creates the guts of each structure instance.  It should
%%   be called after all code is generated, and just prior to final model
%%   registration.
%%
%function LibCacheModelStructureInstance() void
  %<LibCacheBlockIOInstance()>
  %<LibCacheConstBlockIOInstance()>
  %<LibCacheExportedGlobalSignalsInstance()>
  %<LibCacheExportedGlobalDWorkInstance()>
  %<LibCacheContStatesInstance()>     %% may not be used
  %<LibCacheMassMatricesInstance()>     %% may not be used
  %if CodeFormat != "S-Function" || Accelerator
    %<LibCacheDWorkInstance()>
  %endif
  %<LibCachePrevZCStatesInstance()>
  %if !SLibAutosarActive() || SLibAutosarIsServerOperation()
    %<LibCacheExternalInputsInstance()>
    %<LibCacheExternalOutputsInstance()>
    %<LibCacheExternalInputSizesInstance()>
    %<LibCacheExternalOutputSizesInstance()>
  %endif
%endfunction


%% Function FcnGenerateNonFiniteParamValue =====================================
%% Abstract:
%%   Generates the string for a non-finite parameter element initialization
%%   and places it in the non-finite assignment buffer.
%%
%%   Notes:
%%     Assumes block is in scope
%%
%function FcnGenerateNonFiniteParamValue(mdlParam, lvalue, ridx, cidx) void
  %assign dTypeId   = LibGetRecordDataTypeId(mdlParam)
  %assign complex   = LibGetRecordIsComplex(mdlParam)

  %% Real Part
  %%
  %% parameter has already been included in rtP so we don't need
  %% to worry about that part of LibBlockMatrixParameter;  Also, that implies
  %% that the parameter must have storage class auto so we don't need to worry
  %% about that.
  %assign rval = ...
    SLibParameterValue(lvalue, dTypeId, complex, ridx,"%<tRealPart>%<cidx>")
  %assign nRows = SIZE(lvalue, 0)
  %assign nCols = SIZE(lvalue, 1)
  %assign indexStr = SLibGet2DArrayIndexer(0, nRows, "", "", ridx, ...
    nCols, "", "", cidx)

  %if (complex)
    %assign accessor = ".%<tRealPart>"
  %else
    %assign accessor = ""
  %endif
  %if mdlParam.StorageClass == "Custom"
    %openfile tmpStr
    %if mdlParam.CustomStorageClassVersion > 1
      %<LibAccessCustomData(mdlParam, "set", indexStr, accessor, rval)>
    %else
      %assign lhs = LibCustomData(mdlParam, "contents", indexStr, accessor)
      %<lhs> = %<rval>;
    %endif
    %closefile tmpStr
  %else      
    %assign lhs = FcnAccessModelParameter(mdlParam, indexStr)
    %assign tmpStr = "%<lhs>%<accessor> = %<rval>;\n"
  %endif
  %assign ppStuff = SLibDataPreprocessorStuff(mdlParam)
  %assign ppIf = ppStuff[0]
  %assign ppEndIf = ppStuff[1]
  %assign tmpStr = ppIf + "\n" + tmpStr + "\n" + ppEndIf + "\n"
  
  %<SLibCacheNonFiniteParamAssignment(mdlParam, tmpStr)>
  
  %% Imaginary Part
  
  %if complex
    
    %% parameter has already been included in rtP so we don't need
    %% to worry about that part of LibBlockMatrixParameter;  Also, that implies
    %% that the parameter must have storage class auto so we don't need to worry
    %% about that.
    %if mdlParam.StorageClass == "Custom"
      %openfile tmpStr
      %if mdlParam.CustomStorageClassVersion > 1
        %<LibAccessCustomData(mdlParam, "set", indexStr, tImagPart, ival)>
      %else
        %assign lhs = LibCustomData(mdlParam, "contents", indexStr, tImagPart)
        %<lhs> = %<ival>;
      %endif
      %closefile tmpStr
    %else      
      %assign ival = ...
        SLibParameterValue(lvalue, dTypeId, complex, ridx,"%<tImagPart>%<cidx>")
      %assign tmpStr = "%<lhs>.%<tImagPart> = %<ival>;\n"
    %endif
    %<SLibCacheNonFiniteParamAssignment(mdlParam, tmpStr)>

  %endif

  %return 1
%endfunction %% FcnGenerateNonFiniteParamValue


%% Function: SLibGenMacroStrForModelPrm ========================================
%% Abstract:
%%   Generate the macro string for an Model Parameter
%%
%function SLibGenMacroStrForModelPrm(mdlParam, indices, complex, reim, ...
  accessType) void
  
  %assign value    = mdlParam.Value
  %assign isScalar = (SIZE(value, 0) == 1) && (SIZE(value, 1) == 1)
  
  %assign macroStr = ""
  %if complex
    %if reim == tRealPart
      %assign macroStr = "_RE"
    %elseif reim == tImagPart
      %assign macroStr = "_IM"
    %else
      %assign errTxt = "Unhandled case in SLibGenMacroStrForModelPrm"
      %<LibBlockReportFatalError([], errTxt)>
    %endif
  %else
    %assign macroStr = ""
  %endif
  
  %if !isScalar
    %if accessType == "Vector"
      %assign pIdx   = indices[0]
      %assign macroStr = "_EL_%<pIdx>%<macroStr>"
    %else
      %assign rIdx = indices[0]
      %assign cIdx = indices[1]
      %assign macroStr = "_R_%<rIdx>_C_%<cIdx>%<macroStr>"
    %endif
  %endif
  %assign macroStr = "%<tConstPrms>_%<LibGetRecordIdentifier(mdlParam)>%<macroStr>"
  
  %return macroStr
%endfunction %% SLibGenMacroStrForModelPrm



%% Function: FcnGetModelVectPrmVal =============================================
%% Abstract:
%%   Get the indexed value of the specified vector model parameter
%%
%function FcnGetModelVectPrmVal(mdlParam, sigIndexer, pIdx, complex, reim)
  %return FcnGetVectPrmValueCore(mdlParam, sigIndexer, pIdx, complex, reim, 0)
%endfunction



%% Function: FcnGetModelMatrixPrmVal ===========================================
%% Abstract:
%%   Get the indexed value of the specified matrix model parameter
%%
%function FcnGetModelMatrixPrmVal(mdlParam, ridx, cidx, complex, reim) 
  %assign value  = mdlParam.Value
  %assign dtype = LibGetRecordDataTypeId(mdlParam)
  %return FcnGetMatrixPrmValueCore(value, dtype, ridx, cidx, complex, reim, 0)
%endfunction



%% Function: SLibGenModelConstPrmMacroAccess ===================================
%% Abstract:
%%   Generate an access based on the fact that a macro will be generated for 
%%   the given model parameter
%%
%function SLibGenModelConstPrmMacroAccess(mdlParam, sigIndexer, indices, complex, reim, ...
  accessType) void
  
  %assign macroStr = SLibGenMacroStrForModelPrm(mdlParam, indices, complex, ...
    reim, accessType)
  
  %% Get the value to inform code gen of non-finites. Throw away value for now
  %if accessType == "Matrix"
    %assign theVal = FcnGetModelMatrixPrmVal(mdlParam, indices[0], ...
      indices[1], complex, reim)
  %else
    %assign theVal = FcnGetModelVectPrmVal(mdlParam, sigIndexer, indices[0], complex, reim)
  %endif
  
  %if SLibGenMacroForPrm(mdlParam)
    %if accessType == "Matrix" && !ISFIELD(mdlParam, "MacroAccessAsMatrix")
      %addtorecord mdlParam MacroAccessAsMatrix 1
    %endif
    
    %if accessType == "Vector" && !ISFIELD(mdlParam, "MacroAccessAsVector")
      %addtorecord mdlParam MacroAccessAsVector 1
    %endif
    %return macroStr  
  %else
    %return theVal
  %endif
%endfunction %% SLibGenModelConstPrmMacroAccess


%% Function: SLibGenConstRTPForPrm ============================================
%% Abstract:
%%   Tells if a model parameter should be a const RTP
%%
%function SLibGenConstRTPForPrm(mdlParam) void
  %if mdlParam.InConstSection
    %assert (mdlParam.Tunable == "no")
    %assert (!mdlParam.InConstWithInitSection)
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function: SLibGenConstPrmWithInit ==========================================
%% Abstract:
%%   Tells if a model parameter should be a const RTP
%%
%function SLibGenConstPrmWithInit(mdlParam) void
  %if mdlParam.InConstWithInitSection
    %assert (mdlParam.Tunable == "no")
    %assert (!mdlParam.InConstSection)
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function: SLibGenMacroForPrm ================================================
%% Abstract:
%%   Tells if a model parameter should have an associated macro
%%
%function SLibGenMacroForPrm(mdlParam) void
  %assign retVal = (SLibGenConstRTPForPrm(mdlParam) && ...
                    InlinedPrmAccess == "Macros")
  %return retVal
%endfunction


%% Function: SLibChildScopeValues ===============================================
%% Abstract:
%%    This functions inlines or scopes initialization values of systems
%%    hierarchical child systems. It is called by a function that generates
%%    the initialization values for the parent system.
%%
%% Arguments:
%%       sysIdx - parent system index
%%    structPtr - index into the Model%<StructType> vector, that points
%%                to the first element of a system instance parameter
%%                vector (simliar to first-instance index but also for
%%                second and greater instance of a system)
%%       struct - structure type (eg. "Parameters")
%%      typetag - vargroup type (eg. "Parameter")
%% hasUnconditionalElement - if structure is already known to have one
%%
%function SLibChildScopeValues(sysIdx, structPtr, struct, typetag, hasFlatElements)
  %assign hasUnconditionalElement = hasFlatElements
  %assign childSystemValues = ""
  %assign numElements = 0
  %% Initialize res: no typedefs, no elements, no advancement of structPtr
  %assign res = ["", 0, %<structPtr>]
  %assign varGroupIdx = FcnSysVarGroupIndex(System[sysIdx], typetag, 0)
  %if varGroupIdx >= 0
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %% The following variable is used to control the names of items in
    %% the code to prevent empty structure types in the case of code 
    %% variants
    %assign hasElement = varGroup.HasElement
  %else
    %assign hasElement = ""
  %endif
  %assign comma = ""
  %assert SLibSystemHasOwnDataScope(System[sysIdx])
  %openfile childSystemValues
  %assign ppIf = ""
  %assign ppFi = ""
  %foreach childIdx = System[sysIdx].NumHStructChildSystems
    %assign chIdx = System[sysIdx].HStructChildSystems[childIdx]      
    %assign blk = System[chIdx[1]].Block[chIdx[2]]
    %if struct == "Parameters" && blk.CallSiteIdx > 0 && InlineParameters
      %continue
    %endif
    %assign childSys = System[blk.CallSiteInfo.SystemIdx]
    %assign ppIf     = SLibIfNetPreprocessorCondition(childSys)
    %if !ISEMPTY(ppIf)
      %assign ppIf = "\n" + ppIf + "\n"
    %endif
    %assign inlRes   = FcnScope%<struct>(childSys.SystemIdx, structPtr)
    %% If the childSys is a standalone subsystem then 
    %% don't dump it out, cache it with the system. Note that
    %% all standalone systems are single instance.
    %if childSys.StandaloneSubsystem
      %assign inlRes[1] = 0
      %<LibSetSystemField(childSys, "Standalone%<struct>Init", inlRes[0])>
    %endif
    %assign blkName  = LibGetBlockName(blk)
    %if inlRes[1] > 0
      %assert childSys.Has%<struct>Arg
      %<comma>
      %<ppFi>\
      %<ppIf>\
      /* Start of '%<blkName>' */ {
        %<inlRes[0]> 
      }
      /* End of '%<blkName>' */ \
      %assign comma = ","
      %assign ppFi = SLibEndIfNetPreprocessorCondition(childSys)
      %if !ISEMPTY(ppFi)
        %assign ppFi = "\n" + ppFi + "\n"
      %endif
      %assign numElements = numElements + inlRes[1]
      %if ISEMPTY(ppIf)
        %assign hasUnconditionalElement = TLC_TRUE
      %endif
    %endif
    %assign structPtr = inlRes[2]
  %endforeach
  %if hasUnconditionalElement
    %<ppFi>
  %elseif (numElements > 0)
    %assert !hasFlatElements
    ,
    %<ppFi>
    #ifndef %<hasElement>
    0
    #endif
  %endif        
  %closefile childSystemValues
  
  %if numElements > 0
    %assign res[0] = "%<childSystemValues>"
    %assign res[1] = %<numElements>
  %endif
  %assign res[2] = %<structPtr>
  %return res
%endfunction %% SLibChildScopeValues


%% Function: SlibOmitParameter ==================================================
%% Abstract:
%%    For an Embedded-Code optimization, omit unaccessed parameters when
%%    not generating an s-function, and parameters are inlined (don't do
%%    when not inlined since we only access the parameters of the first
%%    instance of a reused subsystem
%%
%function SLibOmitParameter(prm) void
  %return InlineParameters && SLibIsERTTarget() && ...
    !GenerateErtSFunction && !IsModelReferenceSimTarget() && ...
    !prm.WasAccessedAsVariable
%endfunction


%% Function: SLibGetFormattedPrmValue =============================================
%% Abstract:
%%      Returns the formatted initialization value with an optional comment
%%      for a given model parameter record
%%
%function SLibGetFormattedPrmValue(mdlParam, vectorComment) void
  %openfile valueString
  %%
  %% generate parameters using built-in function
  %% for [1x1] or (1), use scalar
  %% for [1xn] or [nx1], use (n)
  %% perform fixups for boolean params
  %%
  %assign prmVal  = LibPrepParameter(mdlParam)
  %assign dTypeId = LibGetRecordDataTypeId(mdlParam)
  %% dataref parameter are handled internally by tlc compiler
  %if LibIsBuiltInDataType(LibGetDataTypeStorageIdFromId(dTypeId)) || ISSLDATAREF(mdlParam.Value)
    %assign prmNonFiniteIndices = GENERATE_FORMATTED_VALUE(prmVal, vectorComment)
    %if prmNonFiniteIndices[0][0] >= 0
      %%
      %% Handle nonfinites:
      %%   defined only for Real or Real32
      %foreach idx = SIZE(prmNonFiniteIndices,0)
        %% Note that prmNonFiniteIndices is calculated on the prepped prmVal.  This
        %% prmVal may have a dimension stripped, e.g. if mdlParam.Value is 4x1 then
        %% prmVal is 1x4.  Thus down inside FcnGenerateNonFiniteParamValue we need to
        %% work with the prepped prmVal, or the indices in prmNonFiniteIndices may
        %% be invalid.  However, we still need to pass mdlParam to the function
        %% since we access other info in it, e.g. storage class.
        %assign ret = FcnGenerateNonFiniteParamValue(mdlParam, prmVal, ...
	  prmNonFiniteIndices[idx][0], prmNonFiniteIndices[idx][1])
      %endforeach
    %endif
  %else
    %if !ISEMPTY(vectorComment)
      %assign vectorComment = " /* %<vectorComment> */\n"
    %endif
    %assign width = LibGetRecordWidth(mdlParam)
    %%
    %if width == 1 
      %if LibIsNonBuiltInTypeNeededForFixpt(dTypeId)
        %if LibGetRecordIsComplex(mdlParam)
          {%<FcnGetNonBuiltInRe(prmVal)>, %<FcnGetNonBuiltInIm(prmVal)>}
        %else
          %% Fixpt biglong word(33+) is a string
          %<SLibGetFormattedValueFromId(dTypeId, prmVal)>%<vectorComment>\
        %endif
      %elseif LibIsEnumDataType(dTypeId)
        %<SLibGetEnumTypeStringFromValue(dTypeId, prmVal)>%<vectorComment>\
      %else
        %% User-defined (custom) data type
        %% ==> Always initialize using ground value
        %<LibGetGroundInitFromId(dTypeId)>%<vectorComment>\
      %endif
    %else
      %% For vector/matrix parameters, comment goes before initial values
      %assign nRows = SIZE(mdlParam.Value, 0)
      %assign nCols = SIZE(mdlParam.Value, 1)
      %<vectorComment>
      {\
      %% col major
      %foreach col = nCols
        %foreach row = nRows
          %if col > 0 || row > 0
            , \
          %endif
          %if LibIsEnumDataType(dTypeId)
            %<SLibGetEnumTypeStringFromValue(dTypeId, mdlParam.Value[col])>\
          %elseif LibIsNonBuiltInTypeNeededForFixpt(dTypeId)
            %% any non-built-in type has 33+ bits represented by string
            %% its corresponding complex is represented by discreted vector
            %if LibGetRecordIsComplex(mdlParam)
              {\
              %% get both real and imag 
              %if TYPE(mdlParam.Value) == "Matrix"
                %<FcnGetNonBuiltInRe(mdlParam.Value[row][col])>\  
              %else
                %<FcnGetNonBuiltInRe(mdlParam.Value[col])>\ 
              %endif
              , \
              %if TYPE(mdlParam.Value) == "Matrix"
                %<FcnGetNonBuiltInIm(mdlParam.Value[row][col])>\  
              %else
                %<FcnGetNonBuiltInIm(mdlParam.Value[col])>\  
              %endif
              }\
            %else
              %if TYPE(mdlParam.Value) == "Matrix"
                %<mdlParam.Value[row][col]>\  
              %else
                %<mdlParam.Value[col]>\  
              %endif
            %endif
          %else
            %<LibGetGroundInitFromId(dTypeId)>\
          %endif
        %endforeach  %%row
      %endforeach    %%col
      }\
    %endif
  %endif
  %closefile valueString
  %return valueString
%endfunction %% SLibGetFormattedPrmValue

%% Function: LibParameterInstanceInitStr ======================================
%% Abstract:
%%   Generates the initialization string for a parameter instance
%%
%function LibParameterInstanceInitStr(mdlParam) void
  
  %assign comment = ""
  %assign initStr = SLibGetFormattedPrmValue(mdlParam, comment)
  %return initStr
%endfunction

%% Function: SLibCommentParameterInstances =====================================
%% Abstract:
%%   Return whether or not to generate comments for parameter instances
%%
%function SLibCommentParameterInstances() void
  %assign comments = 0
  %if ::CompiledModel.ForceParamTrailComments || ...
    ::CompiledModel.NumBlockParams < 1000
    %assign comments = 1
  %endif
  %return comments
%endfunction

%% Function: LibCacheBlockIOInstance ==========================================
%% Abstract:
%%   Caches the BlockIO instance.
%%
%function LibCacheBlockIOInstance() void
  %if !IsModelReferenceTarget() && !LibBlockIOStructIsEmpty()
    %% there's definitely something in the BlockIO structure so instantiate it.
    %if SLibAutosarCompilerAbstractionRequired()
      %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tBlockIOType, TLC_FALSE, TLC_FALSE, LibGetBlockIOStruct(), "DataGlobal")>;"
    %else
      %assign definition = "%<tBlockIOType> %<LibGetBlockIOStruct()>;"
    %endif    
    
    %openfile buffer
    %<SLibAddPreStructDeclarePragma(LibGetBlockIOStruct())>\
    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetBlockIOStruct()>")>\
    %<SLibAddPostStructDeclarePragma(LibGetBlockIOStruct())>\
    %closefile buffer

    %assign ::CompiledModel.BlockIOInstance = buffer
  %else
    %assign ::CompiledModel.BlockIOInstance = ""
  %endif
%endfunction  %% LibCacheBlockIOInstance


%% Function: SLibWriteOutInstForSignalRec =====================================
%% Abstract:
%%   Determine whether to write out instantiation code for a specific signal. 
%%
%% For model reference, we do not write out instantiation code for
%% root-level inputs/outputs (they are instantiated by the top model).
%%
%function SLibWriteOutInstForSignalRec(record) void
  %assign retVal = TLC_FALSE
  
  %% Check assumptions
  %assign rootSystem = ::CompiledModel.System[NumSystems-1]
  %assign reqInsts = LibGetSystemField(rootSystem,"ReqRootPrmHdrDataInsts")
  %assert(reqInsts.ExpGlobalSigsInst)
  %assert ((record.RecordType == "BlockOutput") || ...
           (record.RecordType == "ExternalInput"))

  %% For model reference target, we do not write out instantiation code for
  %% root-level inputs/outputs (they are instantiated by the top model).
  %if (IsModelReferenceTarget())
    %if ((record.RecordType == "BlockOutput") && ...
         (record.DrivesModelRefRootOutport == "no"))
      %assign retVal = TLC_TRUE
    %endif
  %else
    %assign retVal = TLC_TRUE
  %endif
  
  %return retVal
  
%endfunction

%% Function: LibGlobalDefinitionWithAlignment ====================================
%% Abstract:
%%   Generate a definition with alignment directive positioned at the right place.
%function LibGlobalDefinitionWithAlignment(plainDef, comment, align) void
  %openfile buf
  %switch(globalDAFlag.position)
    %case "DATA_ALIGNMENT_PRECEDING_STATEMENT"
      %<align>
      %<plainDef> %<comment>
      %break
    %case "DATA_ALIGNMENT_FOLLOWING_STATEMENT"
      %<plainDef> %<comment>
      %<align>
      %break
    %case "DATA_ALIGNMENT_PREDIRECTIVE"
      %<align> %<plainDef> %<comment>
      %break
    %case "DATA_ALIGNMENT_POSTDIRECTIVE"
      %<plainDef> %<align> %<comment>
      %break
    %default
      %assert TLC_FALSE  %% unhandled case
      %break
  %endswitch
  %closefile buf
 %return buf
%endfunction

%% Function: LibCacheExportedGlobalSignalsInstance =============================
%% Abstract:
%%   Caches the exported global signals.
%%
%function LibCacheExportedGlobalSignalsInstance() void
  %if ::CompiledModel.NumExportedGlobalSignals > 0
    %openfile buffer
    %% root inports
    %if (ExternalInputs.NumExportedGlobalSignals > 0)
      %foreach idx = ExternalInputs.NumExternalInputs
	%assign ei = ExternalInputs.ExternalInput[idx]
	%if ((ei.StorageClass == "ExportedGlobal") && ...
              (SLibWriteOutInstForSignalRec(ei)))
            %assign descStr = SLibGetDescriptionForData(ei)
            %assign descStr = ISEMPTY(descStr) ? "" : "\n* " + descStr + "\n"
            %%
            %assign comment  = "/* '%<ei.BlockName>'%<descStr> */"
            %assign dataType = SLibGetRecordDataTypeName(ei, "")
            %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(ei))
            %assign id = LibGetRecordIdentifier(ei)

            %if SLibAutosarCompilerAbstractionRequired()
              %assign definition = ...
                "%<ei.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>;"
            %else
              %assign definition = ...
                "%<ei.StorageTypeQualifier> %<dataType> %<id>%<optWidth>;"
            %endif            
            %if(ei.Alignment > 0)
               %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                                                      ei.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
               %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
            %else
               %<definition> %<comment>
            %endif
	%endif
      %endforeach
    %endif    
    %% block io
    %if BlockOutputs.NumExportedGlobalSignals > 0
      %foreach boIdx = BlockOutputs.NumExternalBlockOutputs
	%assign bo = BlockOutputs.ExternalBlockOutput[boIdx]
	%% - Write out instantiation lines for ExportedGlobal signals.
	%% - Exclude those signals that drive model reference root outports
	%%   because memory for these will be allocated by the top model.
	%if ((bo.StorageClass == "ExportedGlobal") && ...
          (SLibWriteOutInstForSignalRec(bo)))
          %assign id = LibGetRecordIdentifier(bo)
	  %with bo
	    %if !ISEMPTY(SigSrc)
              %assign blkName = SLibGrBlockName(GrSrc)
            %else
	      %assign blkName = "Multiple Blocks"
	    %endif
            %%
            %assign descStr = SLibGetDescriptionForData(bo)
            %assign descStr = ISEMPTY(descStr) ? "" : "\n* " + descStr + "\n"
            %%
	    %assign comment  = "/* '%<blkName>'%<descStr> */"
	    %assign dataType = SLibGetRecordDataTypeName(bo, "")
	    %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(bo))

            %if SLibAutosarCompilerAbstractionRequired()
              %assign definition = ...
                " %<bo.StorageTypeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>;"
            %else
              %assign definition = ...
                "%<bo.StorageTypeQualifier> %<dataType> %<id>%<optWidth>;"
            %endif
                        
            %assign ppStuff = SLibDataPreprocessorStuff(bo)
            %assign ppIf = ppStuff[0]
            %assign ppFi = ppStuff[1]
            %<ppIf>
            %if(bo.Alignment > 0)
               %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, bo.Identifier, dataType, ...
                                                      bo.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
               %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
            %else
               %<definition> %<comment>
            %endif   
            %<ppFi>
	  %endwith
	%endif
      %endforeach
    %endif
    %closefile buffer
    %assign ::CompiledModel.ExportedGlobalSignalsInstance = buffer
  %else
    %assign ::CompiledModel.ExportedGlobalSignalsInstance = ""
  %endif
%endfunction  %% LibCacheExportedGlobalSignalsInstance


%% Function: FcnGenerateBlockDWorkExternalDeclaration =======================
%% Abstract:
%%   Generate the declaration of an external dwork for a block
%%
%function FcnGenerateBlockDWorkExternalDeclaration(dwRec) Output
  %with dwRec
    %%
    %assign descStr = SLibGetDescriptionForData(dwRec)
    %assign descStr = ISEMPTY(descStr) ? "" : "\n* " + descStr + "\n"
    %%
    %assign comment = "/* " + LibBlockDWorkOwnerComment(dwRec) + descStr + " */"
    %if LibHasCustomStorage(dwRec)
      %<LibReportError("Custom dwork should be defined elsewhere")>
    %else
      %assign dataType = SLibGetRecordDataTypeName(dwRec, "")
      %assign star = (dwRec.StorageClass == "ImportedExternPointer") ? ...
	"*" : ""
      %assign optWidth = (dwRec.StorageClass == "ImportedExternPointer") ? ...
	"" : LibOptionalVectorWidth(SLibDWorkWidth(dwRec))
      %assign typeQualifier = dwRec.StorageTypeQualifier
      %assign id = LibGetRecordIdentifier(dwRec)
      %if SLibAutosarCompilerAbstractionRequired()
        %assign definition = ...
          "%<typeQualifier> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, (dwRec.StorageClass == "ImportedExternPointer"), TLC_FALSE, "%<id>%<optWidth>", "DataGlobal")>; "
      %else
        %assign definition = ...
          "%<typeQualifier> %<dataType> %<star>%<id>%<optWidth>; "
      %endif
      %assign ppStuff = SLibDataPreprocessorStuff(dwRec)
      %assign ppIf = ppStuff[0]
      %assign ppFi = ppStuff[1]
      %<ppIf>
      %if dwRec.Alignment > 0
         %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, id, dataType, ...
                                                dwRec.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
         %<LibGlobalDefinitionWithAlignment(definition, comment, align)>
      %else
         %<definition> %<comment>
      %endif
      
      %<ppFi>
    %endif
  %endwith
%endfunction


%% Function: LibCacheExportedGlobalDWorkInstance ===============================
%% Abstract:
%%   Caches the exported global DWork.
%%
%function LibCacheExportedGlobalDWorkInstance() void
  %if ::CompiledModel.NumExportedGlobalDWork > 0
    %assign numDWorks = ::CompiledModel.DWorks.NumDWorks
    %%
    %openfile buffer
    %foreach dwIdx = numDWorks
      %selectfile buffer
      %assign dwRec = ::CompiledModel.DWorks.DWork[dwIdx]
      %% For model reference target, we do not write out instantiation code for
      %% global DSM and dwork size of VarDims root outport.
      %if dwRec.StorageClass == "ExportedGlobal" && ...
	(!IsModelReferenceTarget() || (!dwRec.GlobalDSM && ...
        !dwRec.DrivesModelRefRootOutportSize && ...
        !dwRec.ModelRefRootInportSize))
	%<FcnGenerateBlockDWorkExternalDeclaration(dwRec)>\
      %endif
    %endforeach
    %closefile buffer
    %assign ::CompiledModel.ExportedGlobalDWorkInstance = buffer
  %else
    %assign ::CompiledModel.ExportedGlobalDWorkInstance = ""
  %endif
%endfunction  %% LibCacheExportedGlobalDWorkInstance

%% Function: LocalFcnGetNonFiniteFcnCall =============================
%% Abstract:
%%   Get the function call to return the value corresponding to the
%%   given nonFinite value.
%%
%function LocalFcnGetNonFiniteFcnCall(nonFiniteVal,bo)
  %assert !ISFINITE(nonFiniteVal)
  %assign dTypeId    = SLibGetRecordDataTypeId(bo)
  %assign dtId       = LibGetDataTypeIdAliasedThruToFromId(dTypeId)
  %assign isSingle   = (DataTypes.DataType[dtId].DTName == "single")
  
  %if ISNAN(nonFiniteVal)
    %if !isSingle
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID,tSS_DOUBLE,"")
    %else
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getNaN",tSS_VOID,tSS_SINGLE,"")
    %endif  
  %elseif ISINF(nonFiniteVal) && nonFiniteVal > 0
    %if !isSingle
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID,tSS_DOUBLE,"")
    %else
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getInf",tSS_VOID,tSS_SINGLE,"")
    %endif
  %elseif ISINF(nonFiniteVal) && nonFiniteVal < 0
    %if !isSingle
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID,tSS_DOUBLE,"")
    %else
      %assign callInfo = SLibGenOneInputOneOutputFcnCallInfo("getMinusInf",tSS_VOID,tSS_SINGLE,"")
    %endif
  %else
    %assert TLC_FALSE
  %endif
  
  %return callInfo.Expr
  
%endfunction %% LocalFcnGetNonFiniteFcnCall


%% Function: FcnGetCPPConstBlockIOInitValues =============================
%% Abstract:
%%   Special handling is needed for creating initial values for non-finite
%%   numbers when the target langauge is C++.
%%
%function FcnGetCPPConstBlockIOInitValues(bo,initValues)
  %assert ::GenCPP
  %assign sigWidth = LibGetRecordWidth(bo)
  %assign complex = SLibGetRecordIsComplex(bo)
  %assign numEles = SIZE(initValues,1)
  %assign comma = ","
  %openfile initBuf
  %if sigWidth > 1
    {
  %endif
  
  %foreach ind = numEles
    %assign ele = initValues[ind]
    %if TYPE(ele) == "String" || ISFINITE(ele)
      %if TYPE(ele) != "String"
        %assign dummyVal = GENERATE_FORMATTED_VALUE(ele,"")
      %else
        %<ele>
      %endif
      %if sigWidth > 1 && ind < (numEles-1)
        %<comma>
      %endif
    %else
      %% Is Non-finite number
      
      %if complex 
        {
        %assign rval = REAL(ele)
        %assign ival = IMAG(ele)
        
        %if TYPE(rval) != "String" && !ISFINITE(rval)
          %assign rinitval = LocalFcnGetNonFiniteFcnCall(rval,bo)
          %<rinitval>,
        %else
          %if TYPE(rval) != "String"
            %assign dummyVal = GENERATE_FORMATTED_VALUE(rval,"")
          %else
            %<ele>
          %endif
          %<comma>
        %endif
        
        %if TYPE(ival) != "String" && !ISFINITE(ival)
          %assign iinitval = LocalFcnGetNonFiniteFcnCall(ival,bo)
          %<iinitval>
        %else
          %if TYPE(ival) != "String"
            %assign dummyVal = GENERATE_FORMATTED_VALUE(ival,"")
          %else
            %<ival>
          %endif
           
        %endif
        }
      %else
        %assign initval = LocalFcnGetNonFiniteFcnCall(ele,bo)
        %<initval>
      %endif
      
      %if sigWidth > 1 && ind < (numEles-1)
        %<comma>
      %endif
    %endif
  %endforeach
    
  %if sigWidth > 1
    }
  %endif
  %closefile initBuf
  
  %return initBuf
  
%endfunction %% FcnGetCPPConstBlockIOInitValues


%% Function: FcnGenerateNonFiniteConstBlockIOValue =============================
%% Abstract:
%%   Generates the string for a non-finite Const Block IO element initialization
%%   and places it in the non-finite assignment buffer.
%%
%function FcnGenerateNonFiniteConstBlockIOValue(sysIdx, bo, rowidx, colidx) void
  %assign value = bo.InitialValue
  %assign nCols = SIZE(value, 1)
  %assign complex = SLibGetRecordIsComplex(bo)

  %if bo.DoNotConstify == 0
    %assign bo.DoNotConstify = 1
  %endif
  
  %if (TYPE(value) == "Vector" && nCols > 1)
    %assign value = value[colidx]
  %elseif (TYPE(value) == "Vector")
    %assign value = value[0]
  %else
    %% Scalar or Matrix type for initial values are not supported
    %assert TLC_FALSE
  %endif
  
  %assign dTypeId    = SLibGetRecordDataTypeId(bo)
  %assign baseSysIdx = GetBaseSystemIdx()
  %assign varGroupIdx  = bo.VarGroupIdx[0]    
  %assign varGroup    = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
  %assign sysIdx      = varGroup.SysIdx    
  %assign instanceIdx = varGroup.InstanceIdx
  %assign identiPath =  SLibCGIRVarGroupPath(varGroupIdx,baseSysIdx,TLC_FALSE)

  %if LibGetRecordWidth(bo) > 1
    %assign sigIndexer = ...
      SLibGet1DArrayIndexer(LibGetRecordWidth(bo), "", "",  colidx)
  %else
    %assign sigIndexer = ""
  %endif
  
  %if complex
    %assign rval        = REAL(value)
    %assign ival        = IMAG(value)
    %if !ISFINITE(rval)
      %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer + "." + tRealPart
      %assign str = str + " = %<rval>;\n"
      %if !::GenCPP
        %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
      %endif
      %<LibNeedRealNonFinite(rval)>\
    %endif
    %if !ISFINITE(ival)
      %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer + "." + tImagPart
      %assign str = str + " = %<ival>;\n"
      %if !::GenCPP
        %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
      %endif
      %<LibNeedRealNonFinite(ival)>\
    %endif
  %else
    %assign str = identiPath + LibGetRecordIdentifier(bo) + sigIndexer
    %assign str = str + " = %<value>;\n"
    %if !::GenCPP
      %<SLibCacheNonFiniteConstBIOAssignment(sysIdx, instanceIdx, str)>\
    %endif
    %<LibNeedRealNonFinite(value)>\
  %endif
%endfunction %% FcnGenerateNonFiniteConstBlockIOValue


%% Function: FcnScopeConstBlockOutputs =========================================
%% Abstract:
%%    This function generates a systems const Block IO initialization.
%%    This function also calls SLibChildScopeValues to inline any child-system
%%    structure initialization.
%%
%% Arguments:
%%        sysIdx - index for the system to generate initialization
%%     mdlPrmPtr - index into the ModelParametes vector, that points
%%                 to the first element of a system instance parameter
%%                 vector (simliar to first-instance index but also for
%%                 second and greater instance of a system)
%%
%function FcnScopeConstBlockIO(sysIdx, mdlBoPtr) void
  %assign      boBuff = ""
  %assign       boArg = System[sysIdx].Interface.ConstBlockIOArgDef
  %assign numElements = 0
  %assign       comma = ""
  %assign     comment = ""
  %assign         res = ["", 0, 0]
  
  %openfile boBuff
  %if boArg.NumFlatFields > 0
    %with ::CompiledModel.BlockOutputs
      %%
      %foreach boIdx = boArg.NumFlatFields
	%assign bo = ConstBlockOutput[mdlBoPtr+boIdx]
	%%
	%% If padder is active, all fields are forced to be in the
	%% const prm structure. This is because the padding 
	%% has already been computed in Simulink assuming that all 
	%% fields are going to be in the structure.
	%%
	%if bo.RequiredInConstBlockIO == 1 || ...
	  ::CompiledModel.PadderActive
	  %assign    sigWidth = LibGetRecordWidth(bo)
	  %assign numElements = numElements + sigWidth
	  %with bo
	    %if GenerateComments
	      %assign comment = "/* '%<SLibGrBlockName(GrSrc)>' */"
	    %endif
	    %assign initValues = ISEMPTY(InitialValue)?CustomInitialValue:InitialValue
	    %assign initWidth = SIZE(initValues,1)
            %assign dtypeIdx = LibCGTypeToSLType(CGTypeIdx)
	    %%
	    %if sigWidth > 1
	      %<comma> \
              %% built-in function GENERATE_FORMATTED_VALUE had been extended to support 33+ fixpt types
	      %if !ISSLDATAREF(initValues) && ISEQUAL(TYPE(initValues[0]),"String")
		{ \
		%% Handle strings outside of GENERATE_FORMATTED_VALUE:
		%%   o Scalar expansion of initValues is supported
		%%   o Nonfinite initialization is not supported
		%foreach idx = sigWidth
                    %assign suffix = (idx == sigWidth-1) ? "" : ","
                    %assign initIdx = (initWidth == 1) ? 0 : idx
                    %% multiword complex 1+2i is in the format of " {0x1UL, 0x0UL} + {0x2UL, 0x0UL} i"
                    %assign initRe = FcnGetNonBuiltInRe(initValues[initIdx])
                    %assign initIm = FcnGetNonBuiltInIm(initValues[initIdx])
                    %if !ISEMPTY(FEVAL("regexp",initValues[initIdx],"i")) && LibGetRecordIsComplex(bo)
                      %assign initValue = "{%<initRe>, %<initIm>}"
                    %else
                      %assign initValue = initRe
                    %endif
                    %<initValue>%<suffix> \
                %endforeach
	        } \
              %elseif LibIsEnumDataType(dtypeIdx)
                %% For enumerated data, write out name of enumerated value
                { \
		%foreach idx = sigWidth
                  %assign suffix = (idx == sigWidth-1) ? "" : ","
                  %<SLibGetEnumTypeStringFromValue(dtypeIdx, initValues[idx])>%<suffix> \
                %endforeach
                } \
              %elseif SupportTunableStructParam && LibDataTypeIsBus(dtypeIdx)
                { \
		%foreach idx = sigWidth
                  %assign suffix = (idx == sigWidth-1) ? "" : ","
                  %assign initStr = "{%<initValues[idx]>}"
                  %<initStr>%<suffix> \
                %endforeach
                } \
	      %else
		%% Support SigWidth == initWidth (scalar expanding not supported)
		%assert initWidth > 1
                %openfile tempBuf
                  %assign cBIONonFiniteIndices = GENERATE_FORMATTED_VALUE(initValues,"")
                %closefile tempBuf
                %if !::GenCPP 
                  %<tempBuf>
                  %undef tempBuf
                %else
                  %%Speical handling of nonFinite number initialization for C++ target
                  %%language
                  %assign initCPP = FcnGetCPPConstBlockIOInitValues(bo, initValues)
                  %<initCPP>
                %endif
		%if cBIONonFiniteIndices[0][0] >= 0
		  %% Handle nonfinites for Real or Real32
		  %foreach idx = SIZE(cBIONonFiniteIndices,0)
		    %<FcnGenerateNonFiniteConstBlockIOValue(sysIdx,bo,...
		      cBIONonFiniteIndices[idx][0],cBIONonFiniteIndices[idx][1])> \
		  %endforeach
		%endif
	      %endif
	    %else
	      %% Single element Vector
	      %<comma> \
              %if !ISSLDATAREF(initValues) && ISEQUAL(TYPE(initValues[0]),"String")
                %assign initValue = initValues[0]
                %% multiword complex 1+2i is in the format of " {0x1UL, 0x0UL} + {0x2UL, 0x0UL} i"
                %assign initRe = FcnGetNonBuiltInRe(initValue)
                %assign initIm = FcnGetNonBuiltInIm(initValue)
                %if !ISEMPTY(FEVAL("regexp",initValue,"i")) && LibGetRecordIsComplex(bo)
                  %assign initStr = "{%<initRe>, %<initIm>}"
                %else
                  %assign initStr = initRe
                %endif
                %<initStr> \
	      %elseif LibIsEnumDataType(dtypeIdx)
                %% For enumerated data, write out name of enumerated value
                %<SLibGetEnumTypeStringFromValue(dtypeIdx, initValues[0])> \
              %elseif SupportTunableStructParam && LibDataTypeIsBus(dtypeIdx)
                %assign initStr = "{%<initValues[0]>}"
                %<initStr> \
              %else
                %openfile tempBuf
                  %assign cBIONonFiniteIndices = GENERATE_FORMATTED_VALUE(initValues[0],"")
                %closefile tempBuf
                %if !::GenCPP
                  %<tempBuf>
                  %undef tempBuf
                %else
                  %%Speical handling of nonFinite number initialization for C++ target
                  %%language
                  %assign initCPP = FcnGetCPPConstBlockIOInitValues(bo, initValues)
                  %<initCPP>
                %endif
		%if cBIONonFiniteIndices[0][0] >= 0
		  %% Handle nonfinites for Real or Real32
		  %<FcnGenerateNonFiniteConstBlockIOValue(sysIdx,bo,...
		    cBIONonFiniteIndices[0][0],cBIONonFiniteIndices[0][1])> \
		%endif
	      %endif
	    %endif
	    %assign comma = ", %<comment>\n"
            %if bo.Padding != 0 
              %if bo.Padding == 1
                %<comma> 'a' \
              %else
                %assign padInit = "{"
                %foreach loopIdx = bo.Padding
                  %assign padInit = padInit + "'a'"
                  %if loopIdx != bo.Padding-1
                    %assign padInit = padInit +","
                  %endif
                %endforeach
                %assign padInit = padInit +"}"
                %<comma> %<padInit> \
              %endif
            %endif
          %endwith %% bo
        %endif %% bo.RequiredInConstBlockIO
      %endforeach 
    %endwith
  %endif
  %assign childValues = SLibChildScopeValues(sysIdx, ...
    mdlBoPtr+boArg.NumFlatFields, "ConstBlockIO", ...
    "ConstBlockIO", numElements > 0)
  %assign numElements = numElements + childValues[1]
  %if childValues[1] > 0
    %<comma>%<childValues[0]> \
  %else
    %<comment> \
  %endif
  %closefile boBuff
  
  %if numElements > 0
    %assign res[0] = "%<boBuff>"
    %assign res[1] = numElements
  %endif
  %assign res[2] = childValues[2]
  %return res
%endfunction  %% FcnScopeConstBlockOutputs


%% Function: LibCacheConstBlockIOInstance ======================================
%% Abstract:
%%   Caches the ConstBlockIO instance, and since all its fields are invariant
%%   it is initialized at this time.
%%
%function LibCacheConstBlockIOInstance() void
  %if BlockOutputs.NumConstBlockOutputs > 0
    %assign rootSys = GetBaseSystemIdx()
    %assign res = FcnScopeConstBlockIO(rootSys, 0)
    %assign ::CompiledModel.ConstBlockIOInstance = res[0]
  %else
    %assign ::CompiledModel.ConstBlockIOInstance = ""
  %endif
%endfunction  %% LibConstCacheBlockIOInstance


%% Function: LibCacheContStatesInstance =======================================
%% Abstract:
%%   Caches the continuous States instance.
%%
%function LibCacheContStatesInstance() void
  %if NumContStates > 0 && !LibIsDeploymentDiagram()
    %if SLibAutosarCompilerAbstractionRequired()
      %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tContStateType, TLC_FALSE, TLC_FALSE, LibGetContinuousStateStruct(), "DataGlobal")>;"
    %else
      %assign definition = "%<tContStateType> %<LibGetContinuousStateStruct()>;"
    %endif
    %assign ::CompiledModel.ContStatesInstance = ...
      SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetContinuousStateStruct()>")
  %else
    %assign ::CompiledModel.ContStatesInstance = ""
  %endif
%endfunction  %% LibCacheContStatesInstance


%% Function: LibCacheMassMatricesInstance =======================================
%% Abstract:
%%   Caches the Mass Matrices (local) Ir, Jc, Pr structures instance, as well as
%%   global Ir,Jc,Pr.
%%
%function LibCacheMassMatricesInstance() void
  %if ModelIsLinearlyImplicit == "yes" && !LibIsDeploymentDiagram()

    %if SLibAutosarCompilerAbstractionRequired()
      %assign definitionGlobal = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tMassMatrixGlobalType, TLC_FALSE, TLC_FALSE, LibGetMassMatrixGlobal(), "DataGlobal")>;"
    %else
      %assign definitionGlobal = "%<tMassMatrixGlobalType> %<LibGetMassMatrixGlobal()>;"
    %endif
    %assign ::CompiledModel.MassMatricesGlobalInstance = ...
      SLibApplyMemSecToDataDefn(definitionGlobal, "MemSecDataInternal", "%<LibGetMassMatrixGlobal()>")
    
  %else
    %assign ::CompiledModel.MassMatricesGlobalInstance = ""
  %endif
%endfunction  %% LibCacheMassMatricesInstance

%% Function: LibCacheDWorkInstance ============================================
%% Abstract:
%%   Caches the States instance.
%%
%function LibCacheDWorkInstance() void
  %if !LibDWorkStructIsEmpty()
    %if SLibAutosarCompilerAbstractionRequired()
      %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tDWorkType, TLC_FALSE, TLC_FALSE, LibGetDWorkStruct(), "DataGlobal")>;"
    %else
      %assign definition = "%<tDWorkType> %<LibGetDWorkStruct()>;"
    %endif    

    %openfile buffer
    %<SLibAddPreStructDeclarePragma(LibGetDWorkStruct())>\
    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetDWorkStruct()>")>\
    %<SLibAddPostStructDeclarePragma(LibGetDWorkStruct())>\
    %closefile buffer

    %assign ::CompiledModel.DWorkInstance = buffer
  %else
    %assign ::CompiledModel.DWorkInstance = ""
  %endif
%endfunction  %% LibCacheDWorkInstance


%% Function: LibCachePrevZCStatesInstance =====================================
%% Abstract:
%%   Caches the States instance.
%%
%function LibCachePrevZCStatesInstance() void
  %if NumZCEvents > 0 && !LibPrevZCStatesStructIsEmpty()
    %if SLibAutosarCompilerAbstractionRequired()
      %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tPrevZCStateType, TLC_FALSE, TLC_FALSE, LibGetPreviousZCStruct(), "DataGlobal")>;"
    %else
      %assign definition = "%<tPrevZCStateType> %<LibGetPreviousZCStruct()>;"
    %endif
    %assign ::CompiledModel.PrevZCStatesInstance = ...
      SLibApplyMemSecToDataDefn(definition, "MemSecDataInternal", "%<LibGetPreviousZCStruct()>")
  %else
    %assign ::CompiledModel.PrevZCStatesInstance = ""
  %endif
%endfunction  %% LibCachePrevZCStatesInstance


%% Function: LibCacheExternalInputsInstance ===================================
%% Abstract:
%%   Caches the external inputs instance.
%%
%function LibCacheExternalInputsInstance() void
  %if ExternalInputs.NumAutoSignals > 0
    %assign modelInputsInRootInportVector = 0
    %foreach idx = ExternalInputs.NumExternalInputs
      %assign extIn = ExternalInputs.ExternalInput[idx]
      %if !SLibFcnProtoCtrlActive() || extIn.RequiresGlobalAccess == "yes"
        %assign modelInputsInRootInportVector = ...
	  modelInputsInRootInportVector + 1
      %endif
    %endforeach
    %if modelInputsInRootInportVector > 0
      %if SLibAutosarCompilerAbstractionRequired()
        %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tInputType, TLC_FALSE, TLC_FALSE, LibGetExternalInputStruct(), "DataGlobal")>;"
      %else
        %assign definition = "%<tInputType> %<LibGetExternalInputStruct()>;"
      %endif

      %openfile buffer
      %<SLibAddPreStructDeclarePragma(LibGetExternalInputStruct())>\
      %<SLibApplyMemSecToDataDefn(definition, "MemSecDataIO", "%<LibGetExternalInputStruct()>")>\
      %<SLibAddPostStructDeclarePragma(LibGetExternalInputStruct())>\
      %closefile buffer
      
      %assign ::CompiledModel.ExternalInputsInstance = buffer
    %else
      %assign ::CompiledModel.ExternalInputsInstance = ""
    %endif
  %else
    %assign ::CompiledModel.ExternalInputsInstance = ""
  %endif
%endfunction  %% LibCacheExternalInputsInstance


%% Function: LibCacheExternalOutputsInstance ==================================
%% Abstract:
%%   Caches the external outputs instance.
%%
%function LibCacheExternalOutputsInstance() void
  %if NumModelOutputs > 0
    %assign modelOutputsInRootOutportVector = 0
    %foreach idx = ExternalOutputs.NumExternalOutputs
      %assign extOut       = ExternalOutputs.ExternalOutput[idx]
      %assign sysIdx       = extOut.Block[0]
      %assign blkIdx       = extOut.Block[1]
      %assign outportBlock = System[sysIdx].Block[blkIdx]
      %if !SLibExternalOutputIsVirtual(outportBlock) && ...
        (!SLibFcnProtoCtrlActive() || extOut.RequiresGlobalAccess == "yes")
        %assign modelOutputsInRootOutportVector = ...
	  modelOutputsInRootOutportVector + 1
      %endif
    %endforeach
    %if modelOutputsInRootOutportVector > 0
      %if SLibAutosarCompilerAbstractionRequired()
        %assign definition = "%<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, tOutputType, TLC_FALSE, TLC_FALSE, LibGetExternalOutputStruct(), "DataGlobal")>;"
      %else
        %assign definition = "%<tOutputType> %<LibGetExternalOutputStruct()>;"
      %endif

      %openfile buffer
      %<SLibAddPreStructDeclarePragma(LibGetExternalOutputStruct())>\
      %<SLibApplyMemSecToDataDefn(definition, "MemSecDataIO", "%<LibGetExternalOutputStruct()>")>\
      %<SLibAddPostStructDeclarePragma(LibGetExternalOutputStruct())>\
      %closefile buffer
      
      %assign ::CompiledModel.ExternalOutputsInstance = buffer

    %else
      %assign ::CompiledModel.ExternalOutputsInstance = ""
    %endif
  %else
    %assign ::CompiledModel.ExternalOutputsInstance = ""
  %endif
%endfunction  %% LibCacheExternalOutputsInstance

%% this one is much simpler than external input instance
%% generation because we are only supporting normal
%% build.
%function LibCacheExternalInputSizesInstance() void
  %assign modelInputsInRootInportSizeVector = 0
  %if ExternalInputs.NumAutoSignals > 0
    %foreach idx = ExternalInputs.NumExternalInputs
      %assign extIn = ExternalInputs.ExternalInput[idx]
      %if ISFIELD(extIn, "SizeVarGroupIdx")
        %assign modelInputsInRootInportSizeVector = ...
          modelInputsInRootInportSizeVector + 1
      %endif
    %endforeach
  %endif
  %if modelInputsInRootInportSizeVector > 0
    %assign definition = "%<tInputSizeType> %<tInputSize>;"

    %openfile buffer
    %<SLibAddPreStructDeclarePragma(tInputSize)> \
    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataIO", tInputSize)> \
    %<SLibAddPostStructDeclarePragma(tInputSize)> \
    %closefile buffer
      
    %assign ::CompiledModel.ExternalInputSizesInstance = buffer
  %else
    %assign ::CompiledModel.ExternalInputSizesInstance = ""
  %endif
%endfunction

%function LibCacheExternalOutputSizesInstance() void
  %assign modelOutputsInRootOutportSizeVector = 0
  %if NumModelOutputs > 0
    %foreach idx = ExternalOutputs.NumExternalOutputs
      %assign extOut       = ExternalOutputs.ExternalOutput[idx]
      %assign sysIdx       = extOut.Block[0]
      %assign blkIdx       = extOut.Block[1]
      %assign outportBlock = System[sysIdx].Block[blkIdx]
      %if !SLibExternalOutputIsVirtual(outportBlock) && ...
        ISFIELD(extOut, "HasVarDims")
        %assign modelOutputsInRootOutportSizeVector = ...
          modelOutputsInRootOutportSizeVector + 1
      %endif
    %endforeach
  %endif
  
  %if modelOutputsInRootOutportSizeVector > 0
    %assign definition = "%<tOutputSizeType> %<tOutputSize>;"

    %openfile buffer
    %<SLibAddPreStructDeclarePragma(LibGetExternalOutputStruct())>\
    %<SLibApplyMemSecToDataDefn(definition, "MemSecDataIO", "%<LibGetExternalOutputStruct()>")>\
    %<SLibAddPostStructDeclarePragma(LibGetExternalOutputStruct())>\
    %closefile buffer
    
    %assign ::CompiledModel.ExternalOutputSizesInstance = buffer
  %else
    %assign ::CompiledModel.ExternalOutputSizesInstance = ""
  %endif
%endfunction %%LibCacheExternalOutputSizesInstance
  
%% Function: SLibGenModelPrmDefnComment ========================================
%% Abstract:
%%   Generate the comment for a model parameter.
%%
%function SLibGenModelPrmDefnComment(mdlParam) void
  %assign pName = LibGetRecordIdentifier(mdlParam)
  
  %assign customStr = ""
  %assign typeStr = ""

  %if ISEMPTY(mdlParam.WorkspaceVarName)
    %assign nRefBlkPrms = SIZE(mdlParam.ReferencedBy, 0)
    
    %if nRefBlkPrms > 1
      %% Pooled model parameter
      %% (not a workspace variable but used by multiple block parameters)
      %assert (mdlParam.Tunable == "no")
      
      %foreach refByIdx = nRefBlkPrms
        %assign sysIdx = mdlParam.ReferencedBy[refByIdx][0]
        %assign blkIdx = mdlParam.ReferencedBy[refByIdx][2]
        %assign prmIdx = mdlParam.ReferencedBy[refByIdx][3]
        %assign block  = System[sysIdx].Block[blkIdx]
        
        %if (block.Type == "SubSystem")
          %% We don't have separate expressions for mask parameters
          %assign typeStr = "Pooled Parameter (Mixed Expressions)\n"
          %break
        %endif
          
        %assign blkPrm = block.Parameter[prmIdx]
        %% Parameter could be a run-time parameter or collapsed expression.
        %switch blkPrm.StringType
          %case "Expression"
            %assign instanceStr = blkPrm.String
            %break
          %case "Computed"
            %assign instanceStr = blkPrm.StringTransformed
            %break
          %default
            %% Should never get here.
            %assert TLC_FALSE
        %endswitch
        
        %if (refByIdx == 0)
          %assign exprStr = instanceStr
          %assign typeStr = "Pooled Parameter (Expression: %<exprStr>)\n"
        %elseif (instanceStr != exprStr)
          %% Expressions are not all the same
          %assign typeStr = "Pooled Parameter (Mixed Expressions)\n"
          %break
        %endif
      %endforeach
        
    %else
      %% Model parameter used by only one block parameter
      %assign sysIdx = mdlParam.ReferencedBy[0][0]
      %assign blkIdx = mdlParam.ReferencedBy[0][2]
      %assign prmIdx = mdlParam.ReferencedBy[0][3]
      %assign block  = System[sysIdx].Block[blkIdx]
      
      %if block.Type != "SubSystem"
        %assign blkPrm = block.Parameter[prmIdx]
        
        %% Parameter could be a run-time parameter or collapsed expression.
        %switch blkPrm.StringType
          %case "Expression"
            %assign typeStr = "Expression: %<blkPrm.String>\n"
            %break
          %case "Computed"
            %assign typeStr = "Computed Parameter: %<pName>\n"
            %break
          %default
            %% Should never get here.
            %assert TLC_FALSE
        %endswitch
        
        %if ISFIELD(blkPrm,"DefSideComment")
          %assign customStr = "* Comment: %<blkPrm.DefSideComment>\n"
        %endif
      %else
        %% Mask Parameter
        %assign typeStr = "Mask Parameter: %<pName>\n"
      %endif
    %endif
  %else
    %% Parameter corresponds to a workspace variable.
    %% ==> Use the WorkspaceVarName in comment because the parameter may have
    %%     an alias name or the identifier may be mangled (if not tunable).
    %assert((mdlParam.WorkspaceVarName == LibGetRecordIdentifier(mdlParam)) || ...
            (mdlParam.WorkspaceVarName == mdlParam.OrigIdentifier) || ...
            (mdlParam.Tunable == "no"))
    
    %assign typeStr = "Variable: %<mdlParam.WorkspaceVarName>\n"
  %endif

  %assign numBlocks = SIZE(mdlParam.GraphicalRef, 0)
  %assert (numBlocks > 0)
  
  %if numBlocks == 1
    %assign blkName = SLibGrBlockName(mdlParam.GraphicalRef[0])
    %assign referencedByStr = "* Referenced by: '%<blkName>'\n"
  %else  
    %assign referencedByStr = "* Referenced by:\n"
    %foreach idx = numBlocks
      %assign blkName = SLibGrBlockName(mdlParam.GraphicalRef[idx])
      %assign referencedByStr = referencedByStr + "*   '%<blkName>'\n"
    %endforeach
  %endif

  %assign descStr = SLibGetDescriptionForData(mdlParam)
  %assign descStr = ISEMPTY(descStr) ? "" : "* " + descStr + "\n"

  %assign comment = ...
    " %<typeStr> " ...
    " %<customStr> " ...
    " %<referencedByStr> " ...
    " %<descStr> "

  %return comment
%endfunction %% SLibGenModelPrmDefnComment


%% Function: SLibGenModelParamDecl ============================================
%% Abstract:
%%   Generates a parameter declaration for placement in model parameter
%%   structure, rtP.  Also works for declaration of imported, exported, or
%%   custom parameters.
%%   
%%   The function uses all information from the ModelParameters table
%%   instead of referencing back to the block parameter.
%%
%%   Arguments:
%%        mdlParam - A Parameter record from the ModelParameters table
%%        applyPragma - TLC_TURE/TLC_FALSE to indicate whether to add pragma
%%
%%   Returns:
%%        A string declaring the given parameter e.g.
%%        real_T a;                /* Comments */
%%        int8_T myGain_Gain[10];  /* Comments */
%%
%function SLibGenModelParamDecl(mdlParam, applyPragma) void
  %% parameter name
  %assign pName = LibGetRecordIdentifier(mdlParam)
  %assign ppStuff = SLibDataPreprocessorStuff(mdlParam)
  %assign ppIf = ppStuff[0]
  %assign ppEndIf = ppStuff[1]


  %% ignore empty parameters
  %assign value = mdlParam.Value
  %if ISEMPTY(value)
    %return ""
  %endif
  
  %% size
  %assign nRows = SIZE(value, 0)
  %assign nCols = SIZE(value, 1)
  %% Safely ignore matrices of the form [[]; [];]
  %if nRows < 1 || nCols < 1
    %return ""
  %endif
    
  %if nRows > 1 && nCols > 1  
    %assign optWidth = "[%<nRows*nCols>]"
  %elseif nRows > 1                  %% Column Vector
    %assign optWidth = "[%<nRows>]"
  %elseif nCols > 1                  %% Row Vector
    %assign optWidth = "[%<nCols>]"
  %else                              %% Scalar
    %assign optWidth = ""
  %endif
  
  %if LibHasCustomStorage(mdlParam)
    %assign ppStuff = SLibDataPreprocessorStuff(mdlParam)
    %assign ppIf = ppStuff[0]
    %assign ppFi = ppStuff[1]
    %openfile buffer
    %<ppIf>
    %<LibCustomData(mdlParam,"declare",optWidth,"")>
    %<ppFi>
    %closefile buffer
    %return buffer
  %endif

  %% data type
  %assign dataType = SLibGetRecordDataTypeName(mdlParam, "")

  %% side comment
  %assign comment = SLibGenModelPrmDefnComment(mdlParam)
  
  %% storage class
  %switch mdlParam.StorageClass
    %case "Auto"
    %case "Auto_SFCN"
      %if SLibIsParamUnstructured(mdlParam)
	%assign pName     = FcnGetAutoParamIdentifier(mdlParam)
	%assign externStr = "extern"
      %else
	%assign externStr = ""
      %endif
      %assign star = ""
      %break
    %case "ExportedGlobal"
    %case "ImportedExtern"
      %assign externStr = "extern"
      %assign star = ""
      %break
    %case "ImportedExternPointer"
      %assign externStr = "extern"
      %assign star = "*"
      %assign optWidth = ""
      %break
    %case "Custom"
      %assign errTxt = "Should not get here; should have exited local fcn above"
      %<LibReportFatalError(errTxt)>
    %default
      %assign errTxt = "Unknown storage class: %<mdlParam.StorageClass>"
      %<LibReportFatalError(errTxt)>
  %endswitch
  
  %% type qualifier
  %assign tq = mdlParam.TypeQualifier
  
  %% declaration string
  %if (mdlParam.DefinedInLegacyCode == 0)
    %if SLibAutosarCompilerAbstractionRequired()
      %assign declaration = ...
        "%<externStr> %<tq> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, (mdlParam.StorageClass == "ImportedExternPointer"), TLC_FALSE, "%<pName>%<optWidth>", "DataGlobal")>; /*%<comment>*/"
    %else
      %assign declaration = ...
        "%<externStr> %<tq> %<dataType> %<star>%<pName>%<optWidth>; /*%<comment>*/\n"
    %endif
  %else
    %assign declaration = ""
  %endif

  %assign declaration = ppIf + "\n" + declaration + "\n" + ppEndIf + "\n"

  %if (applyPragma == TLC_TRUE)
    %return SLibApplyMemSecToDataDecl(declaration, "MemSecDataParameters", "%<pName>")
  %else
    %return declaration
  %endif
%endfunction %% SLibGenModelParamDecl


%% Function: SLibGenUnstrModelParamInstance ===================================
%% Abstract:
%%   Generates the code for instantiating exported unstructured parameters.
%%   
%%   The function uses all information from the ModelParameters table
%%   instead of referencing back to the block parameter.
%%
%%   Arguments:
%%        mdlParam - A Parameter record from the ModelParameters table
%%        applyPragma - TLC_TURE/TLC_FALSE to indicate whether to add pragma
%%
%%   Returns:
%%        A string instantiating the given parameter e.g.
%%        real_T Kp = 5.0;          /* Comments */
%%
%function SLibGenUnstrModelParamInstance(mdlParam, applyPragma) void
  %assign ppStuff = SLibDataPreprocessorStuff(mdlParam)
  %assign ppIf = ppStuff[0]
  %assign ppEndIf = ppStuff[1]

  %if (mdlParam.StorageClass == "ExportedGlobal")
    %assign pName = LibGetRecordIdentifier(mdlParam)
  %elseif ((mdlParam.StorageClass == "Auto") && ...
    SLibIsParamUnstructured(mdlParam))
    %assign pName = FcnGetAutoParamIdentifier(mdlParam)
  %else
    %assign errTxt = "SLibGenUnstrModelParamInstance only supports " + ...
      "exported unstructured parameters."
    %<LibReportFatalError(errTxt)>
  %endif
  
  %if ISEMPTY(mdlParam.Value)
    %return ""
  %endif
    
  %% Initialization string
  %assign initStr = LibParameterInstanceInitStr(mdlParam)

  %if !WHITE_SPACE(initStr)
    %% Size
    %assign nRows    = SIZE(mdlParam.Value, 0)
    %assign nCols    = SIZE(mdlParam.Value, 1)
    %assign optWidth = LibOptionalMatrixWidth(nRows, nCols)
    
    %% Data type
    %assign complex = LibGetRecordIsComplex(mdlParam)
    %if (complex)
      %assign dataType = LibGetDataTypeComplexNameFromId(LibGetRecordDataTypeId(mdlParam))
    %else
      %assign dataType = LibGetDataTypeNameFromId(LibGetRecordDataTypeId(mdlParam))
    %endif
    
    %% type qualifier
    %assign tq = mdlParam.TypeQualifier
    
    %% alignment
    %assign slDT = ::CompiledModel.DataTypes.DataType[mdlParam.OriginalDataTypeIdx]
    %assign align = ""
    %if mdlParam.Alignment > 0 && !slDT.IsBus
      %assign align = SLibGetAlignmentSyntax(::CompiledModel.Name, pName, dataType, ...
                                             mdlParam.Alignment, "DATA_ALIGNMENT_GLOBAL_VAR")
    %endif
    
    %% side comment
    %assign comment = SLibGenModelPrmDefnComment(mdlParam)
    %if SLibAutosarCompilerAbstractionRequired()
      %assign definition = ...
        "%<align> %<tq> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, dataType, TLC_FALSE, TLC_FALSE, "%<pName>%<optWidth>", "DataGlobal")> = %<initStr>; /*%<comment>*/" 
    %else
      %assign definition = ...
        "%<align> %<tq> %<dataType> %<pName>%<optWidth> = %<initStr>; /*%<comment>*/\n" 
    %endif

    %assign definition = ppIf + "\n" + definition  + "\n" + ppEndIf + "\n"

    %if (applyPragma == TLC_TRUE)
      %return SLibApplyMemSecToDataDefn(definition, "MemSecDataParameters", "%<pName>")
    %else
      %return definition
    %endif
  %else
    %return ""
  %endif
%endfunction %% FcnGenUnstrModelParamInstance

%% Function: SLibIsModelParamConst ============================================
%% Abstract:
%%   Returns true if the ModelParameter is:
%%   - StorageClass "Custom", and has "const" in its CSC/MemSec qualifier
%%   - or, has "const" in its TypeQualifier
%%   
%function SLibIsModelParamConst(mdlPrm) void
  %if mdlPrm.StorageClass == "Custom"
    %assign msDefn = SLibGetMemorySectionDefForData(mdlPrm)
    %assert !ISEMPTY(msDefn)
    %assign qualifier = SLibGetQualifier(msDefn)
  %else
    %assign qualifier = mdlPrm.TypeQualifier
  %endif

  %if !WHITE_SPACE(qualifier)
    %if !ISEMPTY(FEVAL("strfind", qualifier, "const"))
      %return TLC_TRUE
    %endif
  %endif

  %return TLC_FALSE
%endfunction

%% Function: SLibIsModelParamMacro ============================================
%% Abstract:
%%   Returns true if the ModelParameter is #define macro
%%   
%function SLibIsModelParamMacro(mdlPrm) void
  %if mdlPrm.StorageClass == "Custom"
    %assign cscDefn = mdlPrm.CSCDefn
    %assign dataInit = SLibGetDataInitForData(cscDefn, mdlPrm)
    %return dataInit == "Macro"
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: SLibIsModelParamFileOrAutoScope ===================================
%% Abstract:
%%   Returns true if the ModelParameter DataScope is "File" or "Auto"
%%   
%function SLibIsModelParamFileOrAutoScope(mdlPrm) void
  %if mdlPrm.StorageClass == "Custom"
    %assign cscDefn = mdlPrm.CSCDefn
    %assign dataScope = SLibGetDataScope(cscDefn, mdlPrm)
    %return (dataScope == "File" || dataScope == "Auto")
  %else
    %return TLC_FALSE
  %endif
%endfunction

%% Function: LibDWorkInstanceIsEmpty ==========================================
%% Abstract:
%%   Determine if the DWork instance cache is empty
%%
%function LibDWorkInstanceIsEmpty() void
  %<LibTrapCacheAssert(DWorkInstance)>
  %return WHITE_SPACE(DWorkInstance)
%endfunction


%% Function: LibDumpDWorkInstance =============================================
%% Abstract:
%%   Place the DWork instance cache in the output stream.
%%
%function LibDumpDWorkInstance() Output
  %<LibTrapCacheAssert(DWorkInstance)>\
  %<DWorkInstance>\
  %<SLibResetTLCGlobal("DWorkInstance")>\
%endfunction


%% Function: LibPrevZCStatesInstanceIsEmpty ===================================
%% Abstract:
%%   Determine if the previous zc states instance cache is empty
%%
%function LibPrevZCStatesInstanceIsEmpty() void
  %<LibTrapCacheAssert(PrevZCStatesInstance)>
  %return WHITE_SPACE(PrevZCStatesInstance)
%endfunction


%% Function: LibDumpPrevZCStatesInstance ======================================
%% Abstract:
%%   Place the ZCStates instance cache in the output stream.
%%
%function LibDumpPrevZCStatesInstance() Output
  %<LibTrapCacheAssert(PrevZCStatesInstance)>\
  %<PrevZCStatesInstance>\
  %<SLibResetTLCGlobal("PrevZCStatesInstance")>\
%endfunction


%% Function: LibExternalInputsInstanceIsEmpty =================================
%% Abstract:
%%   Determine if the external inputs instance cache is empty
%%
%function LibExternalInputsInstanceIsEmpty() void
  %if SLibAutosarActive() && !SLibAutosarIsServerOperation()
    %return TLC_TRUE
  %else
    %<LibTrapCacheAssert(ExternalInputsInstance)>
    %return WHITE_SPACE(ExternalInputsInstance)
  %endif
%endfunction


%% Function: LibDumpExternalInputsInstance ====================================
%% Abstract:
%%   Place the external inputs instance cache in the output stream.
%%
%function LibDumpExternalInputsInstance() Output
  %<LibTrapCacheAssert(ExternalInputsInstance)>\
  %<ExternalInputsInstance>\
  %<SLibResetTLCGlobal("ExternalInputsInstance")>\
%endfunction

%% Function: LibExternalInputSizesInstanceIsEmpty =================================
%% Abstract:
%%   Determine if the external input sizes instance cache is empty
%%
%function LibExternalInputSizesInstanceIsEmpty() void
  %if SLibAutosarActive() && !SLibAutosarIsServerOperation()
    %return TLC_TRUE
  %else
    %<LibTrapCacheAssert(ExternalInputSizesInstance)>
    %return WHITE_SPACE(ExternalInputSizesInstance)
  %endif
%endfunction


%% Function: LibDumpExternalInputSizesInstance ====================================
%% Abstract:
%%   Place the external input sizes instance cache in the output stream.
%%
%function LibDumpExternalInputSizesInstance() Output
  %<LibTrapCacheAssert(ExternalInputSizesInstance)>\
  %<ExternalInputSizesInstance>\
  %<SLibResetTLCGlobal("ExternalInputSizesInstance")>\
%endfunction

%% Function: LibExternalOutputsInstanceIsEmpty ================================
%% Abstract:
%%   Determine if the external outputs instance cache is empty
%%
%function LibExternalOutputsInstanceIsEmpty() void
  %if SLibAutosarActive() && !SLibAutosarIsServerOperation()
    %return TLC_TRUE
  %else
    %<LibTrapCacheAssert(ExternalOutputsInstance)>
    %return WHITE_SPACE(ExternalOutputsInstance)
  %endif
%endfunction


%% Function: LibDumpExternalOutputsInstance ===================================
%% Abstract:
%%   Place the external outputs instance cache in the output stream.
%%
%function LibDumpExternalOutputsInstance() Output
  %<LibTrapCacheAssert(ExternalOutputsInstance)>\
  %<ExternalOutputsInstance>\
  %<SLibResetTLCGlobal("ExternalOutputsInstance")>\
%endfunction

%function LibExternalOutputSizesInstanceIsEmpty() void
  %if SLibAutosarActive() && !SLibAutosarIsServerOperation()
    %return TLC_TRUE
  %else
    %<LibTrapCacheAssert(ExternalOutputSizesInstance)>
    %return WHITE_SPACE(ExternalOutputSizesInstance)
  %endif
%endfunction

%function LibDumpExternalOutputSizesInstance() Output
  %<LibTrapCacheAssert(ExternalOutputSizesInstance)>\
  %<ExternalOutputSizesInstance>\
  %<SLibResetTLCGlobal("ExternalOutputSizesInstance")>\
%endfunction

%% Function: LibContStatesInstanceIsEmpty =====================================
%% Abstract:
%%   Determine if the continuous states instance cache is empty
%%
%function LibContStatesInstanceIsEmpty() void
  %<LibTrapCacheAssert(ContStatesInstance)>
  %return WHITE_SPACE(ContStatesInstance)
%endfunction


%% Function: LibDumpContStatesInstance ========================================
%% Abstract:
%%   Place the continuous states instance cache in the output stream.
%%
%function LibDumpContStatesInstance() Output
  %<LibTrapCacheAssert(ContStatesInstance)>\
  %<ContStatesInstance>\
  %<SLibResetTLCGlobal("ContStatesInstance")>\
%endfunction


%% Function: LibMassMatricesLocalInstanceIsEmpty =================================
%% Abstract:
%%   Determine if any of the mass matrices instance caches is empty
%%
%function LibMassMatricesInstanceIsEmpty() void
  
  %<LibTrapCacheAssert(MassMatricesGlobalInstance)>  
  %return ( WHITE_SPACE(MassMatricesGlobalInstance) )

%endfunction


%% Function: LibDumpMassMatricesInstance ====================================
%% Abstract:
%%   Place the mass matrices instance caches in the output stream.
%%
%function LibDumpMassMatricesInstance() Output
  
  %<LibTrapCacheAssert(MassMatricesGlobalInstance)>\
  %<MassMatricesGlobalInstance>\
  %<SLibResetTLCGlobal("MassMatricesGlobalInstance")>\

%endfunction

%% Function: LibBlockIOInstanceIsEmpty ========================================
%% Abstract:
%%   Determine if the block I/O instance instance cache is empty
%%
%function LibBlockIOInstanceIsEmpty() void
  %<LibTrapCacheAssert(BlockIOInstance)>
  %return LibBlockIOStructIsEmpty()
%endfunction


%% Function: LibDumpBlockIOInstance ===========================================
%% Abstract:
%%   Place the block I/O instance cache in the output stream.
%%
%function LibDumpBlockIOInstance() Output
  %<LibTrapCacheAssert(BlockIOInstance)>\
  %<BlockIOInstance>\
  %<SLibResetTLCGlobal("BlockIOInstance")>\
%endfunction


%% Function: LibConstBlockIOInstanceIsEmpty ====================================
%% Abstract:
%%   Determine if the const block I/O instance instance cache is empty
%%
%function LibConstBlockIOInstanceIsEmpty() void
  %<LibTrapCacheAssert(ConstBlockIOInstance)>
  %return WHITE_SPACE(ConstBlockIOInstance)
%endfunction


%% Function: LibDumpConstBlockIOInstance =======================================
%% Abstract:
%%   Place the const block I/O instance cache in the output stream.
%%
%function LibDumpConstBlockIOInstance() Output
  %<LibTrapCacheAssert(ConstBlockIOInstance)>\
  %<ConstBlockIOInstance>\
  %<SLibResetTLCGlobal("ConstBlockIOInstance")>\
%endfunction


%% Function: LibExportedGlobalSignalsInstanceIsEmpty ===========================
%% Abstract:
%%   Determine if the exported global signals instance instance cache is empty
%%
%function LibExportedGlobalSignalsInstanceIsEmpty() void
  %<LibTrapCacheAssert(ExportedGlobalSignalsInstance)>
  %return WHITE_SPACE(ExportedGlobalSignalsInstance)
%endfunction


%% Function: LibDumpExportedGlobalSignalsInstance ==============================
%% Abstract:
%%   Place the exported global signals instance cache in the output stream.
%%
%function LibDumpExportedGlobalSignalsInstance() Output
  %<LibTrapCacheAssert(ExportedGlobalSignalsInstance)>\
  %<ExportedGlobalSignalsInstance>\

  %<SLibResetTLCGlobal("ExportedGlobalSignalsInstance")>\
%endfunction


%% Function: LibExportedGlobalDWorkInstanceIsEmpty ===========================
%% Abstract:
%%   Determine if the exported global dwork instance instance cache is empty
%%
%function LibExportedGlobalDWorkInstanceIsEmpty() void
  %<LibTrapCacheAssert(ExportedGlobalDWorkInstance)>
  %return WHITE_SPACE(ExportedGlobalDWorkInstance)
%endfunction


%% Function: LibDumpExportedGlobalDWorkInstance ==============================
%% Abstract:
%%   Place the exported global dwork instance cache in the output stream.
%%
%function LibDumpExportedGlobalDWorkInstance() Output
  %<LibTrapCacheAssert(ExportedGlobalDWorkInstance)>\
  %<ExportedGlobalDWorkInstance>\

  %<SLibResetTLCGlobal("ExportedGlobalDWorkInstance")>\
%endfunction

%% Function: SLibSetupModelParameters ==============================
%% Abstract:
%% Mark each parameter in the const section
%% - ConstRTPWithInit = InConstWithInitSection
%% - ConstRTP         = InConstSection
%%
%function SLibSetupModelParameters() void
  %with ::CompiledModel.ModelParameters
    %foreach i = NumParameters
      %addtorecord Parameter[i] InConstSection 0
      %addtorecord Parameter[i] InConstWithInitSection 0
      %addtorecord Parameter[i] WasAccessedAsVariable 0
      %addtorecord Parameter[i] InModelRefGlobalSection 0
    %endforeach
    %assign startIdx = NumInrtP
    %foreach i = NumConstPrmsWithInit
      %assign Parameter[startIdx + i].InConstWithInitSection = 1
    %endforeach
    %assign startIdx = startIdx+NumConstPrmsWithInit
    %foreach i = NumConstPrms
      %assign Parameter[startIdx + i].InConstSection = 1
    %endforeach
    %assign startIdx = startIdx+NumConstPrms+NumExportedGlobal+...
      NumImportedExtern+NumImportedExternPointer+NumCustomStorageClass
    %foreach i = NumInMdlRefGlobal
      %assign Parameter[startIdx + i].InModelRefGlobalSection = 1
    %endforeach
    
  %endwith
%endfunction


%% Function: FcnGetPreprocessorStuffForFlatModelParam ===================
%% Abstract:
%%   Return ppIf and ppFi for a const param or non-auto param
%%
%function FcnGetPreprocessorStuffForFlatModelParam(mdlParam) void
  %assign result = ["", ""]
  %assign ppIf = ""
  %assign ppEndIf = ""
  
  %% Don't go off the owner system.  Go off the graphical references
  %assign referencedBy = mdlParam.GraphicalRef
  %foreach refIdx = SIZE(referencedBy, 0)
    %assign grParentIdx = referencedBy[refIdx][0]
    %% synthesized; bail out for now.  odds are that its the temporary
    %% top subsystem for a model reference target anyway, in which case
    %% no optimization lost by returning empty ppIf and ppFi
    %if grParentIdx < 0
      %return result %% return empty
    %endif
    %assign grParent = ...
      CompiledModel.BlockHierarchyMap.Subsystem[grParentIdx]
    %assign sysIdx = grParent.NVOwnerSysIdx
    %assign sysIf = SLibIfNetPreprocessorCondition(::CompiledModel.System[sysIdx])
    %assign sysEndIf = SLibEndIfNetPreprocessorCondition(::CompiledModel.System[sysIdx])
    %if WHITE_SPACE(sysIf)
      %return result %% return empty
    %endif
    
    %if WHITE_SPACE(ppIf)
      %assign ppIf = sysIf
      %assign ppEndIf = sysEndIf
    %elseif !ISEQUAL(ppIf, sysIf)
      %return result %% return empty
    %endif
    
  %endforeach
  %assign result[0] = ppIf
  %assign result[1] = ppEndIf
  %return result
%endfunction

%endif %% _COMMONPRMLIB_

%% [EOF] commonprmlib.tlc
