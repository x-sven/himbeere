%% $RCSfile: fixptlib.tlc,v $
%% $Revision: 1.10.4.60 $
%% $Date: 2011/04/01 21:10:16 $
%%
%% Copyright 1994-2011 The MathWorks, Inc.
%%
%% Abstract: This TLC library file contains library routines in support
%%           of the Fixed-Point Blockset.

%%
%% create variable to indicate that this file has already been loaded
%%
%if EXISTS("_FIXPTLIB_") == 0
%assign _FIXPTLIB_ = 1

%include "fixpt_version.tlc"

%addtorecord ::CompiledModel IncludeFloatDotH 0

%if EXISTS("FixPtLookup_opt_pow2") == 0
  %%
  %% Unless overridden, evenly spaced lookup tables will be
  %% optimized for the case when the spacing is a power of
  %% 2.  The math is much simpler, smaller, and faster for
  %% this case.  However, if minimum code size is the goal
  %% then a user may prefer not to optimize this case.
  %%   If the users model also contains other evenly spaced
  %% lookup tables, especially ones that are not power of
  %% 2 spacing, then a few general functions can handle
  %% all the cases and thereby reduce overall code size
  %% (but decrease overall speed)
  %%
  %assign FixPtLookup_opt_pow2 = 1
%endif

%% This variable must be defined for TLC to work properly
%% with fixed point blocks.  Eventually, this should be
%% automatically defined by the core TLC files, but for now
%% it must be defined here.
%%
%assign SupportDataTypes = 1

%%
%% include target specific info
%%
%include "fixpttarget.tlc"


%function LibCacheFixptOddSizeTypedefs(buffer) void
  %if !ISFIELD(::CompiledModel, "FixptOddSizeTypedefs")
    %addtorecord ::CompiledModel FixptOddSizeTypedefs ""
  %endif
  %assign ::CompiledModel.FixptOddSizeTypedefs = ::CompiledModel.FixptOddSizeTypedefs + buffer
%endfunction


%assign PreDefinedIntegerType = [8,16,32]

%function FixPt_RegisterLongAsBuiltInType( ) void
  %% set up the new  target defined oversized(>32) long type
  %assign ::CompiledModel.tSS_LONG = ::CompiledModel.DataTypes.NumDataTypes
   %assign ::CompiledModel.tSS_ULONG = ::CompiledModel.DataTypes.NumDataTypes + 1
   %assign ::CompiledModel.DataTypes.NumDataTypes = ::CompiledModel.DataTypes.NumDataTypes + 2
   
   %% register signed long
   %assign newDTName = "int%<IntegerSizes.LongNumBits>_T"
   %assign newCDTName = "cint%<IntegerSizes.LongNumBits>_T"
   %assign newEnuName = "SS_LONG"
   %assign dtSize = IntegerSizes.LongNumBits / IntegerSizes.CharNumBits
   %addtorecord ::CompiledModel.DataTypes                                     \
   DataType {                                                               \ 
     ActualBits                    %<IntegerSizes.LongNumBits>              \
     Bias 0                                                                 \
     ComplexGroundName             ""                                       \
     ComplexGroundReqInMemory      0                                        \
     ComplexName                   newCDTName                               \
     ConvertBetweenTLCFcnFile      ""                                       \
     ConvertBetweenTLCFcnName      "SLibConvertBetweenBuiltin"              \
     DTName                        newDTName                                \
     DataTypeName                  newDTName                                \
     Enum                          newEnuName                               \
     FixedExp                      0                                        \
     FracSlope                     1                                        \
     GroundHasNonZero              0                                        \
     GroundInit                    ""                                       \
     GroundName                    ""                                       \
     GroundReqInMemory             0                                        \
     GroundValue                   0                                        \
     HasObject                     0                                        \
     HeaderFile                    ""                                       \
     Id                            %<::CompiledModel.tSS_LONG>                \
     IdAliasedThruTo               %<::CompiledModel.tSS_LONG>                \
     IdAliasedTo                   -10                                      \
     IsBus                         0                                        \
     IsEnumType                    0                                        \
     IsFixedPoint                  0                                        \
     IsPositiveTLCFcnFile          ""                                       \
     IsPositiveTLCFcnName          "SLibIsPositiveBuiltin"                  \
     IsSigned                      1                                        \
     Name                          newDTName                                \
     NativeType                    newDTName                                \
     NumElements                   0                                        \
     RequiredBits                  %<IntegerSizes.LongNumBits>              \
     SignTLCFcnFile                ""                                       \
     SignTLCFcnName                "SLibSignBuiltin"                        \
     Size                          %<dtSize>                                \
     StorageId                     %<::CompiledModel.tSS_LONG>                \
   }
   
   %% register unsigned long
   %assign newDTName = "uint%<IntegerSizes.LongNumBits>_T"
   %assign newCDTName = "cuint%<IntegerSizes.LongNumBits>_T"
   %assign newEnuName = "SS_ULONG"
   %addtorecord ::CompiledModel.DataTypes                                     \
   DataType {                                                               \ 
     ActualBits                    %<IntegerSizes.LongNumBits>              \
     Bias 0                                                                 \
     ComplexGroundName             ""                                       \
     ComplexGroundReqInMemory      0                                        \
     ComplexName                   newCDTName                               \
     ConvertBetweenTLCFcnFile      ""                                       \
     ConvertBetweenTLCFcnName      "SLibConvertBetweenBuiltin"              \
     DTName                        newDTName                                \
     DataTypeName                  newDTName                                \
     Enum                          newEnuName                               \
     FixedExp                      0                                        \
     FracSlope                     1                                        \
     GroundHasNonZero              0                                        \
     GroundInit                    ""                                       \
     GroundName                    ""                                       \
     GroundReqInMemory             0                                        \
     GroundValue                   0U                                       \
     HasObject                     0                                        \
     HeaderFile                    ""                                       \
     Id                            %<::CompiledModel.tSS_ULONG>               \
     IdAliasedThruTo               %<::CompiledModel.tSS_ULONG>               \
     IdAliasedTo                   -10                                      \
     IsBus                         0                                        \
     IsEnumType                    0                                        \
     IsFixedPoint                  0                                        \
     IsPositiveTLCFcnFile          ""                                       \
     IsPositiveTLCFcnName          "SLibIsPositiveBuiltin"                  \
     IsSigned                      0                                        \
     Name                          newDTName                                \
     NativeType                    newDTName                                \
     NumElements                   0                                        \
     RequiredBits                  %<IntegerSizes.LongNumBits>              \
     SignTLCFcnFile                ""                                       \
     SignTLCFcnName                "SLibSignBuiltin"                        \
     Size                          %<dtSize>                                \
     StorageId                     %<::CompiledModel.tSS_ULONG>               \
   }
    %openfile utilityDef
    #ifndef SS_LONG
    #define SS_LONG  %<::CompiledModel.tSS_LONG>
    #endif
    #ifndef SS_ULONG
    #define SS_ULONG  %<::CompiledModel.tSS_ULONG>  
    #endif
    %closefile utilityDef
    %<LibCacheFixptOddSizeTypedefs(utilityDef)>\
    %undef utilityDef
   %assign ::PreDefinedIntegerType = FEVAL("union",::PreDefinedIntegerType, IntegerSizes.LongNumBits)
 %endfunction
   
  
 
 %assign GeneratedMultiWordTypes = [8,16,32]
 %%
 %function FixPt_RegisterMultiWordTypes(nChunks, chunkType) void
   %assign nBits = nChunks*IntegerSizes.LongNumBits
   %% if the target long type is not registerd yet, it is time to add it to the type table
   %assign definedInt = FEVAL("intersect",::GeneratedMultiWordTypes,nBits)
   %if !ISEMPTY(definedInt)
     %return
   %endif
  %% set up the new  target defined oversized(>32) long type
   %assign tSS_TYPE  = ::CompiledModel.DataTypes.NumDataTypes
   %assign tSS_UTYPE = ::CompiledModel.DataTypes.NumDataTypes + 1
   %assign ::CompiledModel.DataTypes.NumDataTypes = ::CompiledModel.DataTypes.NumDataTypes + 2
   
   %% register signed long
   %assign newDTName = "int%<nBits>m_T"
   %assign newCDTName = "cint%<nBits>m_T"
   %assign newEnuName = "SS_LONG"
   %assign dtSize = nBits / IntegerSizes.CharNumBits
   %addtorecord ::CompiledModel.DataTypes                                     \
   DataType {                                                               \ 
     ActualBits                    %<nBits>                                 \
     Bias 0                                                                 \
     ComplexGroundName             ""                                       \
     ComplexGroundReqInMemory      0                                        \
     ComplexName                   newCDTName                               \
     ConvertBetweenTLCFcnFile      ""                                       \
     ConvertBetweenTLCFcnName      "SLibConvertBetweenBuiltin"              \
     DTName                        newDTName                                \
     DataTypeName                  newDTName                                \
     Enum                          newEnuName                               \
     FixedExp                      0                                        \
     FracSlope                     1                                        \
     GroundHasNonZero              0                                        \
     GroundInit                    ""                                       \
     GroundName                    ""                                       \
     GroundReqInMemory             0                                        \
     GroundValue                   0                                        \
     HasObject                     0                                        \
     HeaderFile                    ""                                       \
     Id                            %<tSS_TYPE>                              \
     IdAliasedThruTo               %<tSS_TYPE>                              \
     IdAliasedTo                   -10                                      \
     IsBus                         0                                        \
     IsEnumType                    0                                        \
     IsFixedPoint                  1                                        \
     IsPositiveTLCFcnFile          ""                                       \
     IsPositiveTLCFcnName          "SLibIsPositiveBuiltin"                  \
     IsSigned                      1                                        \
     Name                          newDTName                                \
     NativeType                    newDTName                                \
     NumElements                   0                                        \
     RequiredBits                  %<nBits>                                 \
     SignTLCFcnFile                ""                                       \
     SignTLCFcnName                "SLibSignBuiltin"                        \
     Size                          %<dtSize>                                \
     StorageId                     %<tSS_TYPE>                              \
   }
   
   %addtorecord ::CompiledModel.DataTypes.DataType[tSS_TYPE]                  \
     Elements {                                                             \
       Name             "chunks"                                            \
       NumDimensions    1                                                   \
       Dimensions       %<nChunks>                                          \
       DataTypeId       %<chunkType>                                        \
       Padding          0                                                   \
       IsComplex        0                                                   \
       IsFixedPoint     0                                                   \
       Width            %<nChunks>                                          \
       Offset           0                                                   \
     }
   %assign ::CompiledModel.DataTypes.DataType[tSS_TYPE] .NumElements = 1
   
   %% register unsigned long
   %assign newDTName = "uint%<nBits>m_T"
   %assign newCDTName = "cuint%<nBits>m_T"
   %assign newEnuName = "SS_ULONG"
   %addtorecord ::CompiledModel.DataTypes                                     \
   DataType {                                                               \ 
     ActualBits                    %<nBits>                                 \
     Bias 0                                                                 \
     ComplexGroundName             ""                                       \
     ComplexGroundReqInMemory      0                                        \
     ComplexName                   newCDTName                               \
     ConvertBetweenTLCFcnFile      ""                                       \
     ConvertBetweenTLCFcnName      "SLibConvertBetweenBuiltin"              \
     DTName                        newDTName                                \
     DataTypeName                  newDTName                                \
     Enum                          newEnuName                               \
     FixedExp                      0                                        \
     FracSlope                     1                                        \
     GroundHasNonZero              0                                        \
     GroundInit                    ""                                       \
     GroundName                    ""                                       \
     GroundReqInMemory             0                                        \
     GroundValue                   0U                                       \
     HasObject                     0                                        \
     HeaderFile                    ""                                       \
     Id                            %<tSS_UTYPE>                             \
     IdAliasedThruTo               %<tSS_UTYPE>                             \
     IdAliasedTo                   -10                                      \
     IsBus                         0                                        \
     IsEnumType                    0                                        \
     IsFixedPoint                  1                                        \
     IsPositiveTLCFcnFile          ""                                       \
     IsPositiveTLCFcnName          "SLibIsPositiveBuiltin"                  \
     IsSigned                      0                                        \
     Name                          newDTName                                \
     NativeType                    newDTName                                \
     NumElements                   0                                        \
     RequiredBits                  %<nBits>                                 \
     SignTLCFcnFile                ""                                       \
     SignTLCFcnName                "SLibSignBuiltin"                        \
     Size                          %<dtSize>                                \
     StorageId                     %<tSS_UTYPE>                             \
   }
   
   %addtorecord ::CompiledModel.DataTypes.DataType[tSS_UTYPE]                 \
     Elements {                                                             \
       Name             "chunks"                                            \
       NumDimensions    1                                                   \
       Dimensions       %<nChunks>                                          \
       DataTypeId       %<chunkType>                                        \
       Padding          0                                                   \
       IsComplex        0                                                   \
       IsFixedPoint     0                                                   \
       Width            %<nChunks>                                          \
       Offset           0                                                   \       
     }
   %assign ::CompiledModel.DataTypes.DataType[tSS_UTYPE] .NumElements = 1  
   %%assign ::PreDefinedIntegerType = FEVAL("union",::GeneratedMultiWordTypes, nBits)
   %assign ::GeneratedMultiWordTypes = FEVAL("union",::GeneratedMultiWordTypes, nBits)
 %endfunction
 
 
%function FixPt_PoundDefineOverSizedDataType( dataTypeRec ) void
  %% change the oversized fixed point type to a struct type,
  %% so that a #define could be generated in model_types.h,
  %% but need to surpress "external reference ground value" for the struct type
  %assign curBits = FixPt_RequiredBits_2_ActualBits(dataTypeRec.RequiredBits)
  
  %if curBits >= IntegerSizes.LongNumBits
    %% if the target long type is not registerd yet, it is time to add it to the type table
    %assign definedInt = FEVAL("intersect",::PreDefinedIntegerType,IntegerSizes.LongNumBits)
    %if ISEMPTY(definedInt) || (tSS_LONG == INT32MIN && curBits > IntegerSizes.LongNumBits)
      %<FixPt_RegisterLongAsBuiltInType()>
    %endif
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% change the oversized fixed point type to a struct type
    %if curBits > IntegerSizes.LongNumBits
      %%
      %if !LibIsBuiltInWordSize(IntegerSizes.LongNumBits) 
        %% not a predefined type such as uint40, uint64
        %assign chunkType = ::CompiledModel.tSS_ULONG
      %else
        %switch IntegerSizes.LongNumBits
          %case 32
            %assign chunkType = ::CompiledModel.tSS_UINT32
            %break
          %case 16
            %assign chunkType = ::CompiledModel.tSS_UINT16
            %break
          %case 8
            %assign chunkType = ::CompiledModel.tSS_UINT8
            %break 
          %default
            %break
        %endswitch
      %endif
      %%
      %% make the original type a real struct type, used to generate struct typedef
      %% element type is always unsigned 
      %% only one chunk array of varient sizes
      %%
      %assign curNumChunks = FixPt_NumChunks(curBits)
      %assign dataTypeRec.NumElements = 1
      %addtorecord dataTypeRec                              \
        Elements {                                          \
          Name             "chunks"                         \
          NumDimensions    1                                \
          Dimensions       %<curNumChunks>                  \
          DataTypeId       %<chunkType>                     \
          Padding          0                                \
          IsComplex        0                                \
          IsFixedPoint     0                                \
          Width            %<curNumChunks>                  \ 
          Offset           0                                \         
        }
      %assign maxChunks = FixPt_NumChunks(::CompiledModel.LargestMultiwordBits)
      %%
      %foreach chunkStep = (maxChunks - 1)
          %assign nChunks = chunkStep + 2
          %% register fixpt arithmetics intermediate types
          %<FixPt_RegisterMultiWordTypes(nChunks, chunkType)>
      %endforeach
    %endif
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% alias the fixed type to the long type to support inline
    %if curBits == IntegerSizes.LongNumBits ...
      && !LibIsBuiltInWordSize(IntegerSizes.LongNumBits) %% not a predefined long type
      %if dataTypeRec.IsSigned
        %assign dataTypeRec.IdAliasedTo = ::CompiledModel.tSS_LONG
      %else
        %assign dataTypeRec.IdAliasedTo = ::CompiledModel.tSS_ULONG
      %endif
    %endif
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %% multiword logging enum name
    %% curBits >= IntegerSizes.LongNumBits
    %if !LibIsBuiltInWordSize(IntegerSizes.LongNumBits)
      %if dataTypeRec.IsSigned
        %assign dataTypeRec.Enum = ::CompiledModel.DataTypes.DataType[::CompiledModel.tSS_LONG].Enum
      %else
        %assign dataTypeRec.Enum = ::CompiledModel.DataTypes.DataType[::CompiledModel.tSS_ULONG].Enum
      %endif
    %elseif dataTypeRec.Enum == ""
      %if(curBits <= 8)
        %if dataTypeRec.IsSigned
          %assign dataTypeRec.Enum = "SS_INT8"
        %else          
          %assign dataTypeRec.Enum = "SS_UINT8"
        %endif
      %elseif(curBits <= 16)
        %if dataTypeRec.IsSigned
          %assign dataTypeRec.Enum = "SS_INT16"
        %else          
          %assign dataTypeRec.Enum = "SS_UINT16"
        %endif
      %else
        %if dataTypeRec.IsSigned
          %assign dataTypeRec.Enum = "SS_INT32"
        %else          
          %assign dataTypeRec.Enum = "SS_UINT32"
        %endif
      %endif
    %endif
  %endif
  %%
%endfunction

%%
%% Some parts of the generated code should just use native C integer types
%% like "int", "unsigned int", "long", "unsigned long", etc.  For example,
%% temporary variables that are indices to vectors should just be "int".  
%% Unless an extremely long vector is being indexed (or some other
%% anomalous case), "int" is fast, efficient, and has no portability
%% issues.  However, Simulink signals and parameters often use typedefs
%% like "uint32_T", "int16_T", etc. to indicate that these containers
%% are defined in a portable manner.  The portable lables like
%% "int16_T" in close proximity to local index declared "int" sometimes
%% gives the false impression that there is a bug or at least lack of 
%% portability.  To avoid this impression, the goal will be to used "portable" 
%% typedefs like "int16_T" even for things (such as indicies) where
%% direct use of "int" is equally portable and more efficient.
%%   The purpose of the following global variables is to provide
%% fast access to typedef replacements for "int", "long", etc.
%%
%assign FixPt_int_label   =  "int%<IntegerSizes.IntNumBits>_T"
%assign FixPt_uint_label  = "uint%<IntegerSizes.IntNumBits>_T"
%assign FixPt_long_label  =  "int%<IntegerSizes.LongNumBits>_T"
%assign FixPt_ulong_label = "uint%<IntegerSizes.LongNumBits>_T"
%assign FixPt_double_label = "real_T"
%assign FixPt_single_label = "real32_T"

%%
%% central definition of THE STANDARD fixed point data type fields
%%    this is useful for having things like copy operations automatically
%%    include new fields or exclude obsolete fields
%%
%assign standardFixPointFields = [ ...
    "DataTypeName", ...
    "IsSigned", ...
    "RequiredBits", ...
    "ActualBits", ...
    "FixedExp", ...
    "FracSlope", ...
    "Bias", ...
    "NativeType" ...
    ]

%%
%% Create the vector NativeWordSizes
%%   for backward compatibility
%%
%%   For example:  [ 8, 16, 32 ]
%%
%if IntegerSizes.CharNumBits < IntegerSizes.ShortNumBits
    %assign NativeWordSizes = []
    %assign NativeWordSizes = NativeWordSizes + IntegerSizes.CharNumBits
    %assign NativeWordSizes = NativeWordSizes + IntegerSizes.ShortNumBits
%else
    %assign NativeWordSizes = []
    %assign NativeWordSizes = NativeWordSizes + IntegerSizes.ShortNumBits
%endif
%%
%if IntegerSizes.IntNumBits > IntegerSizes.ShortNumBits
    %assign NativeWordSizes = NativeWordSizes + IntegerSizes.IntNumBits
%endif
%%
%if IntegerSizes.LongNumBits > IntegerSizes.IntNumBits
    %assign NativeWordSizes = NativeWordSizes + IntegerSizes.LongNumBits
%endif

%%
%% Check that native word sizes
%%   are multiples of 8
%%
%foreach idx =  SIZE(NativeWordSizes, 1)
  %if (  NativeWordSizes[idx] % 8 )
    %%
    %assign errTxt = "Simulink Coder only supports word sizes that are " ...
      "a multiple of 8.  Illegal word size: "+STRING(NativeWordSizes[idx])
    %exit Simulink Coder Fatal: %<errTxt>
  %endif
%endforeach

%%
%% Define how word sizes are to be promoted
%%
%if !ISFIELD(CTargetSpecific,"TypeEmulationWarnSuppressLevel")
  %addtorecord CTargetSpecific TypeEmulationWarnSuppressLevel 0
%endif

%%
%% Keep track of which Fixed Point Utils have
%% already been defined (and code generated)
%%
%assign errTxt = ""
%if !EXISTS("FixPtUtils")
  %createrecord FixPtUtils { ...
  NothingMacro 1}
%else
    %exit Simulink Coder Fatal: FixPtUtils already exists.
%endif


%% Function: FLib_ReImIdx ==================================
%%
%function FLib_ReImIdx(sigIdx,iCase) void
    %%
    %if iCase == 0
        %%
        %assign riSigIdx = tRealPart + STRING(sigIdx)
        %%
    %elseif iCase == 1
        %%
        %assign riSigIdx = tImagPart + STRING(sigIdx)
        %%
    %else
        %%
        %assign riSigIdx = sigIdx
        %%
    %endif
    %%
    %return riSigIdx
%endfunction  %% FLib_ReImIdx



%% Function: FixPt_DataTypesSame ==================================
%%
%% Abstract:  Determine if two data types are the same
%%            Emulated data are treated as different from the storage container
%%            Boolean treated as different from uint8
%%
%function FixPt_DataTypesSame(aDT,bDT)
    %%
    %if !FixPt_SpecifiedContainerSame(aDT,bDT) || ...
        aDT.FixedExp     != bDT.FixedExp       || ...
        aDT.FracSlope    != bDT.FracSlope      || ...
        aDT.Bias         != bDT.Bias
        %%
        %return 0
    %else
        %return 1
    %endif        
    %%
%endfunction  %% FixPt_DataTypesSame


%% Function: FixPt_SpecifiedContainerSame ==================================
%%
%% Abstract:  Determine if two data types have the same specified containers 
%%            Scaling is ignored
%%            Emulated data are treated as different from the storage container
%%            Boolean is not treated the same as uint8
%%
%function FixPt_SpecifiedContainerSame(aDT,bDT)
    %%
    %if aDT.NativeType   != bDT.NativeType   || ...
        aDT.RequiredBits != bDT.RequiredBits || ...
        aDT.IsSigned     != bDT.IsSigned     || ...
        FixPt_DataTypeIsBoolean(aDT) != FixPt_DataTypeIsBoolean(bDT)
        %%
        %return 0
    %else
        %return 1
    %endif        
    %%
%endfunction  %% FixPt_SpecifiedContainerSame


%% Function: FixPt_FracSlopesSame ==================================
%%
%% Abstract:  Determine if two data types are the same
%%
%function FixPt_FracSlopesSame(aFracSlope,bFracSlope)
    %%
    %if aFracSlope == bFracSlope 
        %%
        %return 1
        %%
    %endif
    %%
    %if aFracSlope > bFracSlope
        %%
        %assign ferror = ( aFracSlope - bFracSlope )
        %%
    %else
        %%
        %assign ferror = ( bFracSlope - aFracSlope )
        %%
    %endif
    %%
    %% 2^-33 = 1.164153218269348e-010
    %%
    %return  ( ferror < 1.164153218269348e-010 )
    %%
%endfunction  %% FixPt_FracSlopesSame


%% Function: FixPt_DataTypeSetup ===============================================
%% Abstract:
%%     Makes sure all fixed point data types fully registered
%%
%function FixPt_DataTypeSetup(index) void
  %with ::CompiledModel
      %%
      %assign curDT = FixPt_GetDataTypeFromIndex(index)
      %%
      %assign dTypeId = curDT.Id
      %%
      %% register data types in CompiledModel.DataTypes
      %%
      %if ISFIELD(curDT,"FracSlope")
        %%
        %<FixPt_DataTypePolish(index)>\
        %%
        %assign curDT = FixPt_GetDataTypeFromIndex(index)
        %%
        %% give special treatment to non-builtin types
        %%
        %if !LibIsBuiltInDataType(dTypeId)
            %%
            %assign dTypeRec  = FixPt_GetDataTypeFromIndex(dTypeId)
            %assign dTypeName = curDT.NativeType
            %%
            %% register additional data type properties if not already done
            %%
            %if ISFIELD(dTypeRec,"GroundName")
                %if dTypeRec.GroundName == ""
                    %assign dTypeRecNeedsAdditions = 1
                %else
                    %assign dTypeRecNeedsAdditions = 0
                %endif
            %else
                %assign dTypeRecNeedsAdditions = 1
            %endif
            %%
            %if dTypeRecNeedsAdditions
                %%
                %% register data type name
                %%
		%if !LibIsAliasDataType(dTypeId)  || LibIsDataTypeNewLongFixpt(dTypeId)
		  %<SLibSetDataTypeName(dTypeRec, dTypeName)>
		%endif
                %%
                %<SLibSetDataTypeConvertBetweenTLCFcnName(dTypeRec, "FixPt_DtConvertBetween")>
                %<SLibSetDataTypeIsPositiveTLCFcnName(    dTypeRec, "FixPt_DtIsPositive")>
                %%
                %<SLibSetDataTypeSignTLCFcnName(dTypeRec, "FixPt_DtSign")>
                %%
                %% register data type enumeration
                %%
                %% for now, determine native datatype Id from name and then
                %% set the enum to the correct value.
                %foreach nativeDtId = ::CompiledModel.DataTypes.NumSLBuiltInDataTypes
                    %if curDT.NativeType == LibGetDataTypeNameFromId(nativeDtId)
                        %assign enum = LibGetDataTypeEnumFromId(nativeDtId)
                        %<SLibSetDataTypeEnum(dTypeRec, enum)>
                        %undef enum
                        %break
                    %endif
                %endforeach
                %%
                %% register Data Type Ground
                %%
                
                %if ISFIELD(curDT,"StoredIntegerZero")
                  %assign storedIntegerZero = curDT.StoredIntegerZero
                %else
                  %assign storedIntegerZero = FixPt_Dbl2StoredInt(0.0,curDT)
                %endif
                
                %%
                %assign grndLabel = ::CompiledModel.Name + "_" +curDT.DTName + "_GND"
                %%
                %<SLibSetDataTypeGroundName(dTypeRec, grndLabel)>
                %<SLibSetDataTypeGroundValue(dTypeRec, storedIntegerZero)>
                %%
                %% register complex info
                %%
		%if !LibIsAliasDataType(dTypeId)
		  %<SLibSetDataTypeComplexName(dTypeRec, "c" + dTypeName)>
		%endif
		%<SLibSetDataTypeComplexGroundName(dTypeRec, grndLabel + "_Complex")>
            %endif
            %%
        %endif  %% handle non-builtin types
        %%
      %endif
  %endwith %% CompiledModel
%endfunction  %% FixPt_DataTypeSetup



%% Function: FixPt_Setup =================================================
%% Abstract:
%%   All fixed-point blocks call this function in their BlockInstanceSetup
%%   function.  This function
%%     1) Gets mask name for clearer comments, errors, etc.
%%     2) Convert rounding mode and saturate mode from integer codes to
%%        meaningful strings
%%
%function FixPt_Setup(block, system) void
  %%
  %% get name of mask to make code more readable
  %%   o Creates MaskBlockName to be used in each output function.  Using
  %%     the mask block block name versus the underlying S-Function name makes
  %%     the generated code more readable since the users may not even realize
  %%     that the fixed-point block is actually a masked subsystem block.
  %%
  %assign MaskBlockName = "'" + Name + "'"
  %assign block = block + MaskBlockName
  %%
  %% Convert rounding mode to a meaningful string
  %%
  %if ISFIELD(block,"FixPtRoundingMode")
      %%
      %switch FixPtRoundingMode
          %% Because the block (built-in or s-function) write to the .rtw file 
          %% fxpModeRounding Enum, so the Enum number didn't change even though 
          %% the order on the block dialog changed
          %%
          %% fixptdialoginfo.h does the mapping from block dialog to the Enum
          %% fxpModeRounding
          %%
          %% It is recommended to use STRING instead of number to set rndmeth param
          %%  FXP_ROUND_ZERO = 0,       RndMeth_Zero 
          %%  FXP_ROUND_NEAR = 1,       RndMeth_Nearest
          %%  FXP_ROUND_CEIL = 2,       RndMeth_Ceiling
          %%  FXP_ROUND_FLOOR = 3,      RndMeth_Floor
          %%  FXP_ROUND_SIMPLEST = 4,   RndMeth_Simplest
          %%  FXP_ROUND_NEAR_ML  = 5,   RndMeth_Round
          %%  FXP_ROUND_CONVERGENT = 6, RndMeth_Convergent
          %%
        %case 0
          %assign block.FixPtRoundingMode = "Zero"
          %break
        %case 1
          %assign block.FixPtRoundingMode = "Nearest"
          %break
        %case 2
          %assign block.FixPtRoundingMode = "Ceiling"
          %break
        %case 3
          %assign block.FixPtRoundingMode = "Floor"
          %break
        %case 4
          %assign block.FixPtRoundingMode = "Simplest"
          %break
        %case 5
          %assign block.FixPtRoundingMode = "Round"
          %break   
        %case 6
          %assign block.FixPtRoundingMode = "Convergent"
          %break
        %default
          %exit Simulink Coder Fatal: Unknown Rounding Mode: %<FixPtRoundingMode>
      %endswitch
  %endif
  %%
  %% Convert saturation mode to a meaningful string
  %%
  %if ISFIELD(block,"FixPtSaturationMode")
      %%
      %switch FixPtSaturationMode
        %case 0
          %assign block.FixPtSaturationMode = "Wrap"
          %break
        %case 1
          %assign block.FixPtSaturationMode = "Saturate"
          %break
        %default
          %exit Simulink Coder Fatal: Unknown Saturation Mode: %<FixPtSaturationMode>
      %endswitch
  %endif
  %%
%endfunction  %% FixPt_Setup



%function FixPt_NumChunks(requiredBits) void
  %assign nChunks = requiredBits / IntegerSizes.LongNumBits
  %if requiredBits % IntegerSizes.LongNumBits != 0
    %assign nChunks = nChunks + 1
  %endif
  %return nChunks
%endfunction



%% Function: FixPt_RequiredBits_2_ActualBits ==================================
%% Abstract:
%%
%function FixPt_RequiredBits_2_ActualBits(requiredBits) void
  %%
  %if requiredBits <= IntegerSizes.CharNumBits
    %%
    %assign actualBits = IntegerSizes.CharNumBits
    %%
  %elseif requiredBits <= IntegerSizes.ShortNumBits
    %%
    %assign actualBits = IntegerSizes.ShortNumBits
    %%
  %elseif requiredBits <= IntegerSizes.IntNumBits
    %%
    %assign actualBits = IntegerSizes.IntNumBits
    %%
  %elseif requiredBits <= IntegerSizes.LongNumBits
    %%
    %assign actualBits = IntegerSizes.LongNumBits
    %%
  %else
    %% oversized fixpt is represented using chunk array with each array element of IntegerSizes.LongNumBits size
    %assign nChunks = FixPt_NumChunks(requiredBits)
    %assign actualBits = IntegerSizes.LongNumBits * nChunks
    %%
  %endif
  %%
  %return actualBits
  %%
%endfunction %% FixPt_RequiredBits_2_ActualBits
  
            
%% Function: FixPt_ActualBits_TooBig ==================================
%% Abstract:
%%
%function FixPt_ActualBits_TooBig(actualBits) void
    %return ( actualBits > LibMaxCodeGenWordSize() )
%endfunction %% FixPt_ActualBits_TooBig
  
            
%% Function: FixPt_DataTypePolish ========================================
%% Abstract:
%%
%function FixPt_DataTypePolish(index) void
  %%
  %assign dataTypeRec = FixPt_GetDataTypeFromIndex(index)
  %%
  %assign dataTypeRecAliasThru = FixPt_GetAliasedThruDataTypeFromIndex(index)
  %%
  %% polish the data type, if this hasn't been done yet
  %%
  %if !(ISFIELD(dataTypeRec,"NativeType"))
    %%
    %% get name of the data type as it was registered with simulink
    %%    note force data type name to be a string, sometimes it
    %%    comes out of the .rtw file as "Identifier" type which
    %%    is sort of a string but can cause errors in some situations.
    %%
    %%
    %assign validType = 1
    %%
    %assign dtName = "%<dataTypeRecAliasThru.DTName>"
    %%
    %% Define the new data type
    %%
    %if ISFIELD(dataTypeRec, "Enum") && dataTypeRec.Enum == "SS_DOUBLE"
        %assign actualBits = dataTypeRec.RequiredBits
        %assign nativeType = "real_T"
    %elseif ISFIELD(dataTypeRec, "Enum") && dataTypeRec.Enum == "SS_SINGLE"
        %assign actualBits = dataTypeRec.RequiredBits
        %assign nativeType = "real32_T"
    %else
        %%
        %assign actualBits = FixPt_RequiredBits_2_ActualBits(dataTypeRec.RequiredBits)
        %%
        %if FixPt_ActualBits_TooBig(actualBits)
          %if Accelerator
            %%START_ASSERT
            %openfile errTxt
This model can't be used with the Accelerator.  The Data Type 
%<dtName> requires %<dataTypeRec.RequiredBits> bits, but the maximum supported
with the Accelerator on this computer is %<LibMaxCodeGenWordSize()> bits.
            %closefile errTxt
            %<LibReportFatalError(errTxt)>\
            %%END_ASSERT
          %endif
        %endif
        %%
        %% create the standard name
        %%
        %assign dtStart = dtName[0]+dtName[1]+dtName[2]
        %%
        %if dtStart == "flt"
            %%
            %assign nativeType = "real_T"
            %%
        %else
            %assign nChunk = FixPt_NumChunks(actualBits)
            %if nChunk > 1 
              %assign typeDenotation = "%<actualBits>m"
            %else
              %assign typeDenotation = "%<actualBits>"
            %endif
            
            %if dataTypeRec.IsSigned
                %%
                %assign nativeType = "int%<typeDenotation>_T"
            %else
                %assign nativeType = "uint%<typeDenotation>_T"
            %endif
            %%
            %<FixPt_PoundDefineOverSizedDataType( dataTypeRec )>\
            %%
        %endif
    %endif
    %%
    %% Add the new fields to the record
    %%
    %assign dtRec = FixPt_GetDataTypeFromIndex(index)
    %%
    %addtorecord dtRec  DataTypeName dtName
    %addtorecord dtRec  ActualBits   actualBits
    %addtorecord dtRec  NativeType   nativeType
    %%
    %% Report changes in word sizing
    %%
    %if validType && (actualBits != dataTypeRec.RequiredBits) && !SLibIsHostBasedSimulationTarget()
      %%
      %if CTargetSpecific.TypeEmulationWarnSuppressLevel < 2
        %openfile warnTxt
The data type "%<dtName>" uses a word size that is not available on the intended target.  
        %if CTargetSpecific.TypeEmulationWarnSuppressLevel < 1
    Fixed-point signals using this data type will be put inside a larger word or multi words.  When used, 
extra software will be generated to force this larger word or multi words to emulate a smaller
word.  This emulation is helpful when your prototype target and your final
production target are not the same.  If the smaller word size does NOT exist
on the final production target, then consider increasing the word size to
one that is supported.
          %%
          %assign ::CTargetSpecific.TypeEmulationWarnSuppressLevel = 1
        %endif
        %closefile warnTxt
        %warning %<warnTxt>
      %endif
    %endif
  %endif
  %%
%endfunction  %% FixPt_DataTypePolish



%% Function: FixPt_DefineDataType ========================================
%% Abstract:
%%
%function FixPt_DefineDataType(dataTypeRec) void
    %%
    %assign dtName = "%<dataTypeRec.DataTypeName>"
    %%
    %if ISFIELD(dataTypeRec, "Enum") && dataTypeRec.Enum == "SS_DOUBLE"
        %assign actualBits = dataTypeRec.RequiredBits
        %assign nativeType = "real_T"
    %elseif ISFIELD(dataTypeRec, "Enum") && dataTypeRec.Enum == "SS_SINGLE"
        %assign actualBits = dataTypeRec.RequiredBits
        %assign nativeType = "real32_T"
    %else
        %%
        %assign actualBits = FixPt_RequiredBits_2_ActualBits(dataTypeRec.RequiredBits)
        %%
        %if FixPt_ActualBits_TooBig(actualBits)
          %%START_ASSERT
          %if Accelerator
            %openfile errTxt
This model can't be used with the Accelerator.  The Data Type 
%<dtName> requires %<dataTypeRec.RequiredBits> bits, but the maximum supported
with the Accelerator on this computer is %<IntegerSizes.LongNumBits> bits.
            %closefile errTxt
            %<LibReportFatalError(errTxt)>\
          %else
            %%
            %openfile errTxt
This model can't generate code for the intended TARGET C Compiler.  The 
Data Type %<dtName> requires %<dataTypeRec.RequiredBits> bits, but
the maximum supported by the TARGET C Compiler is %<IntegerSizes.LongNumBits> 
bits.
            %closefile errTxt
            %<LibReportFatalError(errTxt)>\
          %endif
          %%END_ASSERT
        %endif
        %%
        %% create the standard name
        %%
        %assign dtStart = dtName[0]+dtName[1]+dtName[2]
        %%
        %if dtStart == "flt"
            %assign nativeType = "real_T"
        %else
            %if dataTypeRec.IsSigned
                %%
                %assign nativeType = "int%<actualBits>_T"
            %else
                %assign nativeType = "uint%<actualBits>_T"
            %endif
        %endif
    %endif
    %%
    %% Add the new fields to the record
    %%
    %if !(ISFIELD(dataTypeRec,"DataTypeName"))
      %addtorecord dataTypeRec  DataTypeName dtName
    %else
      %<SETFIELD(dataTypeRec,"DataTypeName",dtName)>\
    %endif
    %%
    %if !(ISFIELD(dataTypeRec,"ActualBits"))
      %addtorecord dataTypeRec  ActualBits   actualBits
    %else
      %<SETFIELD(dataTypeRec,"ActualBits",actualBits)>\
    %endif
    %%
    %if !(ISFIELD(dataTypeRec,"NativeType"))
      %addtorecord dataTypeRec  NativeType   nativeType
    %else
      %<SETFIELD(dataTypeRec,"NativeType",nativeType)>\
    %endif
    %%
%endfunction  %% FixPt_DefineDataType



%% Function: FixPt_IndexStruct ===================================================
%%
%% Abstract:
%%      This routine will return an optional index for a structure field. An
%%      index into to the signal is returned for wide signals.  Nothing is
%%      returned for scalar signals (this scalar expands them).
%%
%%      ""         - signal is scalar (width == 1)
%%      [ucv]      - width > 1, ucv specified
%%
%% Note must treat lcv different than "built in" because
%%  a pointer to the variable is not redefined just befor a loop
%%      [idx+lcv]  - width > 1, lcv specified
%%      [idx]      - otherwise
%%
%% Synopsis:
%%      FixPt_IndexStruct(width, ucv, lcv, idx)
%%
%%      width  - width of variable
%%      ucv    - user control variable
%%      lcv    - loop control variable
%%      idx    - index

%function FixPt_IndexStruct(width, ucv, lcv, idx) void
    %%
    %% scalar case
    %%
    %if width == 1
      %%
      %return ""
      %%
    %endif
    %%
    %% vector case
    %%
    %if TYPE(ucv) != "String"
      %%
      %assign ucvStr = "%<ucv>"
      %%
    %else
      %%
      %assign ucvStr = ucv
      %%
    %endif
    %%
    %if ucvStr != ""
      %%
      %return "%<ucvStr>"
      %%
    %elseif lcv != ""
        %%
        %if idx != 0
            %%
            %% must include offset
            %%
            %return "%<idx>+%<lcv>"
            %%
        %else
            %return "%<lcv>"
        %endif
    %else
      %return "%<idx>"
    %endif
%endfunction  %% FixPt_IndexStruct


%% Function: FixPt_GetDataTypeFromIndex ===============================================
%%
%% Abstract:
%%       For the specified input port, return an alias to the corresponding
%%       DataTypes record
%%
%function FixPt_GetDataTypeFromIndex(dataTypeIdx) void
  %%
  %assign curDT = ::CompiledModel.DataTypes.DataType[dataTypeIdx]
  %%
  %return curDT
  %%
%endfunction  %% FixPt_GetDataTypeFromIndex

%% Function: FixPt_GetAliasThruDataTypeFromIndex ===============================================
%%
%% Abstract:
%%       For the specified input port, return an alias to the corresponding
%%       DataTypes record
%%
%function FixPt_GetAliasedThruDataTypeFromIndex(dataTypeIdx) void
  %%
  %assign dataTypeIdxAliasThru = LibGetDataTypeIdAliasedThruToFromId(dataTypeIdx)
  %%
  %assign curDT = ::CompiledModel.DataTypes.DataType[dataTypeIdxAliasThru]
  %%
  %return curDT
  %%
%endfunction  %% FixPt_GetAliasedThruDataTypeFromIndex

%% Function: FixPt_GetInputDataType ===============================================
%%
%% Abstract:
%%       For the specified input port, return an alias to the corresponding
%%       DataTypes record
%%
%function FixPt_GetInputDataType(portIdx) void
  %%
  %assign dataTypeIdx = LibGetDataTypeIdAliasedThruToFromId(LibBlockInputSignalDataTypeId(portIdx))
  %%
  %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
  %%
  %return curDT
  %%
%endfunction  %% FixPt_GetInputDataType


%% Function: FixPt_CopyDataTypeWithBoolReplace ==================================
%%
%% Abstract:
%%       Copy data type record,
%%       if boolean, replace with uint8
%%
%function FixPt_CopyDataTypeWithBoolReplace(aDT) void
  %%
  %assign aIsBoolean = FixPt_DataTypeIsBoolean(aDT)
  %%
  %if aIsBoolean
    %assign localUint8DT = FixPt_GetDataTypeFromIndex(tSS_UINT8)
    %copyrecord aTempDT localUint8DT
  %else
    %copyrecord aTempDT aDT
  %endif
  %%
  %return aTempDT
  %%
%endfunction  %% FixPt_GetInputDataType



%% Function: FixPt_GetOutputDataTypeId ========================================
%%
%% Abstract:
%%       For the specified output port, return the data type id used in
%%       in Simulink.  
%%
%function FixPt_GetOutputDataTypeId(portIdx) void
  %%
  %% get the data type index (into DataTypes record).
  %%
  %assign dataTypeIdx = LibBlockOutputSignalDataTypeId(portIdx)
  %%
  %return LibGetDataTypeIdAliasedThruToFromId(dataTypeIdx)
  %%
%endfunction  %% FixPt_GetOutputDataTypeId



%% Function: FixPt_GetOutputDataType ==========================================
%%
%% Abstract:
%%       For the specified output port, return an alias to the corresponding
%%       DataTypes record
%%
%function FixPt_GetOutputDataType(portIdx) void
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if (IDNUM(op.SignalSrc[0])[0] == "F") %% FcnCall
    %return ""
  %else
    %assign dataTypeIdx = LibGetDataTypeIdAliasedThruToFromId(FixPt_GetOutputDataTypeId(portIdx))
    %%
    %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
    %%
    %return curDT
  %endif 
  %%
%endfunction  %% FixPt_GetOutputDataType



%% Function: FixPt_GetParameterDataTypeId ===============================================
%%
%% Abstract:
%%    For the scalar on the ith Row and jth Col of the specified parameter,
%%    return an alias to the corresponding DataTypes record
%%
%function FixPt_GetParameterDataTypeId(dataTypeIdMat,iRow,iCol) void
    %%
    %assign nRows = SIZE(dataTypeIdMat,0)
    %assign nCols = SIZE(dataTypeIdMat,1)
    %%
    %% scalar expand the parameter if necessary
    %%
    %if (nRows == 1) && (nCols == 1)
        %assign iRow = 0
        %assign iCol = 0
    %endif
    %%
    %% check range
    %%
    %if (nRows <= iRow) && (nCols <= iCol)
      %%
      %assign errTxt = "Specified row and/or column exceeds parameter size"
      %%
      %exit Simulink Coder Fatal: %<errTxt>
      %%
    %endif
    %%
    %assign retRes = dataTypeIdMat[iRow][iCol]
    %%
    %return retRes
%endfunction  %% FixPt_GetParameterDataTypeId

%% Function: FixPt_GetParameterDataType ===============================================
%%
%% Abstract:
%%    For the scalar on the ith Row and jth Col of the specified parameter,
%%    return an alias to the corresponding DataTypes record
%%
%function FixPt_GetParameterDataType(dataTypeIdMat,iRow,iCol) void
  %%
  %assign nRows = SIZE(dataTypeIdMat,0)
  %assign nCols = SIZE(dataTypeIdMat,1)
  %if (nRows > 1) || (nCols > 1)
      %%
      %error "rtwcgtlc: No matrix data types"
      %%
  %endif
  %%
  %assign dataTypeIdx = FixPt_GetParameterDataTypeId(dataTypeIdMat,iRow,iCol)
  %%
  %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
  %%
  %return curDT
  %%
%endfunction  %% FixPt_GetParameterDataType

%% Function: FixPt_GetGroundValueOrNameFromDataTypeRec ==================================
%% This function returns ground name for complex or multiword datatypes. 
%% Otherwise, it returns the ground value.
%function FixPt_GetGroundValueOrNameFromDataTypeRec(rec, isComplex) void
  %%
  %if ISFIELD(rec,"IdAliasedThruTo") && ISFIELD(rec,"IsFixedPoint")
    %if FixPt_DataTypeIsMultiWord(rec) || isComplex
      %assign grndValueOrName = SLibGetDtGroundName(rec.IdAliasedThruTo, isComplex, "")
      %if isComplex
        %<SLibSetDataTypeComplexGroundReqInMemory(rec.IdAliasedThruTo)>
      %endif
    %else
      %assign grndValueOrName = SLibGetGroundValueFromId(rec.IdAliasedThruTo)
    %endif
  %else
    %if isComplex
      %%START_ASSERT
      %<LibReportFatalError("The data type may not be complex.")>
      %%END_ASSERT
    %endif
    %% Get a ground value even if the data type is not a registered type.
    %% It does not support fixed point types with bias.
    %if FixPt_DataTypeIsFloat(rec)
      %if FixPt_DataTypeIsSingle(rec)
        %assign grndValueOrName = 0.0F
      %else
        %assign grndValueOrName = 0.0
      %endif
    %else
      %if ISFIELD(rec,"Bias") && rec.Bias != 0.0
        %%START_ASSERT
        %<LibReportFatalError("The data type may not have bias.")>
        %%END_ASSERT
      %endif
      %if FixPt_DataTypeIsUnsignedFixPt(rec)
        %assign grndValueOrName = 0U
      %else
        %assign grndValueOrName = 0
      %endif
    %endif
  %endif
  %%
  %return grndValueOrName
  %%
%endfunction %%FixPt_GetGroundValueOrNameFromDataTypeRec
  
%% Function: FixPt_GetParameterDataTypeRec ===============================================
%%
%%
%function FixPt_GetParameterDataTypeRec(param) void
  %%
  %%
  %assign dataTypeIdx = param.OriginalDataTypeIdx
  %%
  %assign curDT = FixPt_GetDataTypeFromIndex(dataTypeIdx)
  %%
  %return curDT
  %%
%endfunction  %% FixPt_GetParameterDataTypeRec

%% Function: FixPt_IsParameterDataSizeLargerThan32 ===============================
%%
%% Abstract:
%%    Determine whether the data size of parameter is larger than 32.
%function FixPt_IsParameterDataSizeLargerThan32(param) void
  %%
  %assign curDT = FixPt_GetParameterDataTypeRec(param)
  %%
  %if fxpIsDataTypeFixPt(curDT) && curDT.RequiredBits > 32
    %return 1
  %else
    %return 0
  %endif
%endfunction

%function fxpIsDataTypeFixPt(dataType) void
  %%
  %assert TYPE(dataType) == "Scope"
  %%
  %return ( dataType.NativeType != "real_T"   && ...
            dataType.NativeType != "real32_T" )
  %%
%endfunction


%function fxpIsDataTypeBoolean(dataType) void
    %%
    %assign res = TLC_FALSE
    %%
    %if ISFIELD(dataType,"Id")
      %%
      %assign uDTAliasThru = FixPt_GetAliasedThruDataTypeFromIndex(dataType.Id)
      %%
      %if uDTAliasThru.Id == tSS_BOOLEAN
        %%
        %assign res = TLC_TRUE
      %endif
    %endif
    %%
    %return res
    %%
%endfunction


%function fxpIsDataTypeFixPtNonBool(dataType) void
  %%
  %assert TYPE(dataType) == "Scope"
  %%
  %return ( fxpIsDataTypeFixPt(dataType      ) && ...
            !fxpIsDataTypeBoolean(dataType   ) )
  %%
%endfunction
  

%function fxpIsDataTypeFloatOrSclDbl(dataType) void
  %%
  %assert TYPE(dataType) == "Scope"
  %%
  %return ( dataType.NativeType == "real_T"   || ...
            dataType.NativeType == "real32_T" )
  %%
%endfunction


%function fhpIsDataTypeNoScaleNoBits(dataType) void
  %%
  %assert TYPE(dataType) == "Scope"
  %%
  %return ( ISEQUAL(dataType.RequiredBits, 0  ) && ...
            ISEQUAL(dataType.FixedExp,     0  ) && ...
            ISEQUAL(dataType.FracSlope,    1.0) && ...
            ISEQUAL(dataType.Bias,         0.0) )
  %%
%endfunction  


%function fxpIsDataTypeScaledDouble(dataType) void
  %%
  %assert TYPE(dataType) == "Scope"
  %%
  %return ( fxpIsDataTypeFloatOrSclDbl( dataType) && ...
            !fhpIsDataTypeNoScaleNoBits(dataType) )
  %%
%endfunction  


%function fxpIsDataTypeTrueFloat(dataType) void
    %%
    %assert TYPE(dataType) == "Scope"
    %%
    %return ( fxpIsDataTypeFloatOrSclDbl(dataType) && ...
              fhpIsDataTypeNoScaleNoBits(dataType) )
    %%
%endfunction
  
%function fxpIsDataTypeNotTrueFloat(dataType) void
    %%
    %return ( !fxpIsDataTypeTrueFloat(dataType) )
%endfunction


%% Function: FixPt_DataTypeIsFloat ==========================================
%%
%function FixPt_DataTypeIsFloat(dataType) void
    %%
    %return ( fxpIsDataTypeFloatOrSclDbl( dataType) )
    %%
%endfunction  %% FixPt_DataTypeIsFloat



%% Function: FixPt_DataTypeIsDouble ==========================================
%%
%function FixPt_DataTypeIsDouble(dataType) void
    %%
    %assert TYPE(dataType) == "Scope"
    %%
    %return ( dataType.NativeType == "real_T" )
    %%
%endfunction  %% FixPt_DataTypeIsDouble


%% Function: FixPt_DataTypeIsSingle ==========================================
%%
%function FixPt_DataTypeIsSingle(dataType) void
    %%
    %assert TYPE(dataType) == "Scope"
    %%
    %return ( dataType.NativeType == "real32_T" )
    %%
%endfunction  %% FixPt_DataTypeIsSingle


%% Function: FixPt_DataTypeIsBoolean =====================================
%%
%function FixPt_DataTypeIsBoolean(dataType) void
    %%
    %return fxpIsDataTypeBoolean(dataType)
    %%
%endfunction  %% FixPt_DataTypeIsBoolean


%% Function: FixPt_DataTypeIsMultiWord =============================================
%%
%function FixPt_DataTypeIsMultiWord(dataType) void
    %%
    %assert TYPE(dataType) == "Scope"
    %%
    %return (  dataType.IsFixedPoint && ...
               dataType.RequiredBits > IntegerSizes.LongNumBits && ...
               !FixPt_DataTypeIsFloat(dataType) )
    %%
%endfunction  %% FixPt_DataTypeIsMultiWord


%% Function: FixPt_DataTypeIsUnsignedFixPt =================================
%%
%function FixPt_DataTypeIsUnsignedFixPt(dataType) void
    %%
    %assert TYPE(dataType) == "Scope"
    %%
    %return ( !dataType.IsSigned && ...
              fxpIsDataTypeFixPt(dataType) )
    %%
%endfunction  %% FixPt_DataTypeIsUnsignedFixPt


%% Function: LibFixPointFormDataTypeName ==========================================
%%
%function LibFixPointFormDataTypeName(isSigned,requiredBits,fixedExp) void
    %%
    %if isSigned
        %assign dataTypeName  = "sfix%<requiredBits>_"
    %else
        %assign dataTypeName  = "ufix%<requiredBits>_"
    %endif
    %%
    %if fixedExp < 0
        %assign dataTypeName  = dataTypeName + "En%<-fixedExp>"
    %elseif fixedExp > 0
        %assign dataTypeName  = dataTypeName + "E%<fixedExp>"
    %endif
    %%
    %return dataTypeName
    %%
%endfunction  %% LibFixPointFormDataTypeName



%% FixPt_IsZeroNumericOrString
%%
%function FixPt_IsZeroNumericOrString(in) void
  %%
  %if ISEQUAL(0.0,in)
    %%
    %return TLC_TRUE
    %%
  %elseif TYPE(in) == "String"
    %%
    %if in[0] != "("
      %%
      %assign in = "(" + in + ")"
      %%
    %endif
    %%
    %% change ((*****)) to (******)
    %if in[0] == "(" && in[1] =="("
      %%
      %%Obtain the string length.
      %assign strLen  = SIZE(in, 1)
      %%
      %if in[strLen - 1] == ")" && in[strLen - 2] == ")"
      %%
      %assign in[0] = " "
      %%
      %assign in[strLen - 1] =" "
      %%
      %assign in = FEVAL("strtrim", in)
      %%
      %endif
    %endif
    %%
    %if ISEQUAL("(0)",in)
      %%
      %return TLC_TRUE
      %%
    %elseif in[1] == "0"
      %%
      %if in[2] == "."
        %%
        %return ISEQUAL("(0.0)",  in) || ...
                ISEQUAL("(0.0F)", in) || ...
                ISEQUAL("(0.0f)", in)
        %%
      %elseif in[2] == "U"
        %%
        %return ISEQUAL("(0U)",   in) || ...
                ISEQUAL("(0UL)",  in) || ...
                ISEQUAL("(0Ul)",  in)
        %%
      %elseif in[2] == "L"
        %%
        %return ISEQUAL("(0L)",   in) || ...
                ISEQUAL("(0LU)",  in) || ...
                ISEQUAL("(0Lu)",  in)
        %%
      %elseif in[2] == "u"
        %%
        %return ISEQUAL("(0u)",   in) || ...
                ISEQUAL("(0uL)",  in) || ...
                ISEQUAL("(0ul)",  in)
        %%
      %elseif in[2] == "l"
        %%
        %return ISEQUAL("(0l)",   in) || ...
                ISEQUAL("(0lU)",  in) || ...
                ISEQUAL("(0lu)",  in)
        %%
      %elseif in[2] == "x"
        %%
        %return ISEQUAL("(0x0)",        in) || ...
                ISEQUAL("(0x00)",       in) || ...
                ISEQUAL("(0x0000)",     in) || ...
                ISEQUAL("(0x00000000)", in)
        %%
      %else
        %return TLC_FALSE
      %endif  
    %else
      %return TLC_FALSE
    %endif
  %else
    %return TLC_FALSE
  %endif
%endfunction %% FixPt_IsZeroNumericOrString

%% FixPt_LibBlockSetIsExpressionCompliant
%%
%function FixPt_LibBlockSetIsExpressionCompliant(block,system) void
  %%
  %foreach portIdx = NumDataOutputPorts
    %%
    %if !LibBlockOutputSignalIsValidLValue(portIdx)
      %%
      %% Must be a port with a type and value
      %%
      %return ""
    %endif
    %%
    %assign yDT = FixPt_GetOutputDataType(portIdx)
    %%
    %if yDT.ActualBits != yDT.RequiredBits
      %%
      %% sign extension needed so no expression compliant
      %%
      %return ""
    %endif
  %endforeach
  %%
  %foreach portIdx = NumDataInputPorts
    %%
    %assign uDT = FixPt_GetInputDataType(portIdx)
    %%
    %if uDT.ActualBits != uDT.RequiredBits
      %%
      %% sign extension needed so no expression compliant
      %%
      %return ""
    %endif
  %endforeach
  %%
  %% did not return early, so no ports required sign extension
  %%
  %<LibBlockSetIsExpressionCompliant(block)>\
  %<LibBlockSetIntegerDowncastUnnecessary(block)>\
  %%
%endfunction %% FixPt_LibBlockSetIsExpressionCompliant



%% Function: FixPt_DtConvertBetween ==================================
%%
%% This function is designed to convert between any combination of
%% builtin and/or fixpt types.  It has not be designed to handle
%% non-fixpt custom data types.  (It could be but there is no
%% current need hence no bang for the buck).
%%
%function FixPt_DtConvertBetween(dTypeOut,dTypeIn,inLabel,options,outLabel) Output
    %%
    %assign roundMode = "Nearest"
    %assign satMode   = "Saturate"
    %%
    %if TYPE(options) == "Scope"
      %if ISFIELD(options,"roundMode")
        %assign roundMode = options.roundMode
      %endif
      %if ISFIELD(options,"satMode")
        %assign satMode = options.satMode
      %endif
    %endif
    %%
    %assign inDT  = FixPt_GetDataTypeFromIndex(dTypeIn )
    %assign outDT = FixPt_GetDataTypeFromIndex(dTypeOut)
    %%
    %<FixPt_Fix2FixAlwaysOutput(outLabel,outDT,inLabel,inDT,roundMode,satMode)>\
    %%
    %return 1
%endfunction  %% FixPt_DtConvertBetween



%% Function: FixPt_DtIsPositive ==========================================
%%
%function FixPt_DtIsPositive(dTypeIn,inLabel,options,outLabel) Output
  %%
  %assign inDT = FixPt_GetDataTypeFromIndex(dTypeIn)
  %%
  %if !LibIsDataTypeMultiWordFixpt(dTypeIn)
    %if inDT.Bias == 0.0                  
        %%
        %assign storedIntegerZero = "0"
        %%
    %else
        %%
        %assign storedIntegerZero = STRING(FixPt_Dbl2StoredInt(0.0,inDT))
        %%
    %endif
    %%
    %<outLabel> = ( (%<inLabel>) > (%<storedIntegerZero>) );
    %%
    %return 1
  %else
    %<boolDT.NativeType> %<tmpCmp1>;
    %<FixPt_MultiWordCompGT(tmpCmp1, boolDT, inLabel, inDT, storedIntegerZero, inDT, "Simplest", "Saturate")>
    %<outLabel> = %<tmpCmp1>;
  %endif
%endfunction  %% FixPt_DtIsPositive



%% Function: FixPt_DtSign ==========================================
%%
%function FixPt_DtSign(dTypeIn,inLabel,options,outLabel) Output
  %%
  %assign inDT = FixPt_GetDataTypeFromIndex(dTypeIn)
  %%
  %if !LibIsDataTypeMultiWordFixpt(dTypeIn)
    %if inDT.Bias == 0.0                  
        %%
        %assign storedIntegerZero = "0"
        %%
    %else
        %%
        %assign storedIntegerZero = STRING(FixPt_Dbl2StoredInt(0.0,inDT))
        %%
    %endif
    %%
    %if !(inDT.IsSigned) && ( inDT.Bias >= 0.0 )
        %%
        %% can only be positive
        %%
        %<outLabel> = ( (%<inLabel>) > (%<storedIntegerZero>) );
    %else
        %<outLabel> = ( ((%<inLabel>)<(%<storedIntegerZero>)) ? (-1) : ((%<inLabel>)>(%<storedIntegerZero>)) );
        %%
    %endif
    %%
    %return 1
  %else
    %% Multiword datatype
    %assign boolDT = DataTypes.DataType[tSS_BOOLEAN]
    %assign storedIntegerZero = FixPt_GetGroundValueOrNameFromDataTypeRec(inDT, TLC_FALSE)
    %assign tmpCmp1 = "tmpCmp1"
    %assign tmpCmp2 = "tmpCmp2"
    {
      %if !(inDT.IsSigned) && ( inDT.Bias >= 0.0 )
        %%
        %% can only be positive
        %%
        %<boolDT.NativeType> %<tmpCmp1>;
        %<FixPt_MultiWordCompGT(tmpCmp1, boolDT, inLabel, inDT, storedIntegerZero, inDT, "Simplest", "Saturate")>
        %<outLabel> = %<tmpCmp1>;
      %else
        %<boolDT.NativeType> %<tmpCmp1>, %<tmpCmp2>;
        %<FixPt_MultiWordCompGT(tmpCmp1, boolDT, inLabel, inDT, storedIntegerZero, inDT, "Simplest", "Saturate")>
        %<FixPt_MultiWordCompLT(tmpCmp2, boolDT, inLabel, inDT, storedIntegerZero, inDT, "Simplest", "Saturate")>
        %<outLabel> = ( (%<tmpCmp2>) ? (-1) : (%<tmpCmp1>) );
      %endif
    }
    %return 1
  %endif
%endfunction  %% FixPt_DtIsPositive


%function FixPt_helperUtilityNameAppendDT(yDT) void
  %%
  %if FixPt_DataTypeIsFloat(yDT)
    %%
    %assign utilityName = yDT.NativeType
    %%
  %elseif FixPt_DataTypeIsBoolean(yDT)
    %%
    %assign utilityName = "Bool"
    %%
  %else
    %if yDT.IsSigned
      %assign utilityName = "S"
    %else
      %assign utilityName = "U"
    %endif
    %assign utilityName = utilityName + STRING(yDT.RequiredBits)
  %endif
  %%
  %return utilityName
  %%
%endfunction %% FixPt_helperUtilityNameAppendDT


%function FixPt_UtilityNameAppendDT(utilityName,yDT) void
  %%
  %assign utilityName = utilityName + "_" + FixPt_helperUtilityNameAppendDT(yDT)
  %%
  %return utilityName
  %%
%endfunction %% FixPt_UtilityNameAppendDT


%function FixPt_UtilityNameAppendMode(utilityName,roundMode,satMode) void
  %%
  %if satMode == "Saturate"
    %assign utilityName = utilityName + "_SAT"
  %else
    %%%assign utilityName = utilityName + "_WRAP"
  %endif
  %%
  %if roundMode == "Zero"
    %assign utilityName = utilityName + "_ZERO"
  %elseif roundMode == "Nearest"
    %assign utilityName = utilityName + "_NEAR"
  %elseif roundMode == "Ceiling"
    %assign utilityName = utilityName + "_CEILING"
  %elseif roundMode == "Floor"
    %% do not append name
    %%%assign utilityName = utilityName + "_FLOOR"   
    %% do not append name
  %elseif roundMode == "Simplest"
    %assign utilityName = utilityName + "_SIMPLEST"
  %elseif roundMode == "Round"
    %assign utilityName = utilityName + "_ROUND"
  %elseif roundMode == "Convergent"
    %assign utilityName = utilityName + "_CONVERGENT"    
  %elseif roundMode == ""
    %% do not append name
    %% rounding not relavent
    %%
  %else
    %assign utilityName = utilityName + "_ROUNDERROR"   
  %endif
  %%
  %return utilityName
  %%
%endfunction %% FixPt_UtilityNameAppendDT

%% function FixPt_UtilityMakeName(name) void
%% Abstract:
%%   To ensure that fixpoint functions names
%%   are unique to this model so that when top model is built,
%%   no symbols collisions occur.
%%
%function FixPt_UtilityMakeName(name) void
  %if CodeFormat == "S-Function"
    %assign name = ::CompiledModel.Name + "_"+name
  %endif

  %return name
%endfunction

%% Function: FixPt_LoadFixPtUtils ==============================================
%% Abstract:
%%   This function generates and loads fixpoint utility function that have been
%%   created by CGIR in either rtwgen or from calls in TLC to the CGIR fixpt 
%%   lowering function
%%
%function FixPt_LoadFixPtUtils() void
  %if FEVAL("rtwprivate", "rtwcgtlc", "RTWCtxExists")
    %if FEVAL("rtwprivate", "rtwcgtlc", "WriteFixptUtilsFile")
      %include "%<LibGetModelName()>_fixpt_util.tlc"
      %<CGIRBlockRegisterFixPointFunctions()>
      %assign nMaxMWBits = FEVAL("rtwprivate", "rtwcgtlc", "fixPtWordSizeUsage")
      %<DeclareFixedPointWordSizeUsage(nMaxMWBits)>
    %else
      %error "rtwcgtlc: Failed to write the fixpoint utility TLC file"
    %endif
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Lookup Table Global "Enum-Style" Values
%%
%assign searchTrivial     = 0
%assign searchPow2        = 1
%assign searchEven        = 2
%assign searchUneven      = 3
%%
%assign interpolateTrivial     = 0
%assign interpolateBigProduct  = 1
%assign interpolateLambda      = 2
%assign interpolatePow2        = 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%include "fixptmul.tlc"
%include "fixptdiv.tlc"
%include "fixptcast.tlc"
%include "fixptadd.tlc"
%include "fixptrelop.tlc"
%include "fixpterror.tlc"
%include "fixpt_tunable_param_cast.tlc"
%include "fixpt_code_gen_time_calc.tlc"
%include "fixpt_matlab_callback_util.tlc"
%include "fixpt_preprocessor_guards.tlc"
%include "fixptmultiword.tlc"
%include "fixptcomment.tlc"

%endif %% _FIXPTLIB_

%% [EOF] %% $RCSfile: fixptlib.tlc,v $
